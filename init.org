#-*- mode: org -*-

#+TITLE=Main config file
#+STARTUP:overview

(What the world needs (I think) is not
      (a Lisp (with fewer parentheses))
      but (an English (with more.)))
-- Brian Hayes, http://tinyurl.com/3y9l2kf


(Emacs, (that tool (that converts (repetitive, tedious and bouring tasks) into (creative ones))))

 Emacs is a flexible platform for developing end-user applications
   –unfortunately it is generally perceived as merely a text editor.
Some people use it specifically for one or two applications.
   https://alhassy.github.io/init/

* init.el
** Generic settings
*** Personal data
#+BEGIN_SRC elisp
(setq user-full-name "Laura Brustenga i Moncusí"
      user-mail-address "laurea987@gmail.com")
#+END_SRC
*** Inhibits on start-up
#+BEGIN_SRC elisp
  (setq inhibit-splash-screen t
        inhibit-startup-echo-area-message t
        inhibit-startup-buffer-menu t
        inhibit-startup-screen t
        inhibit-startup-message t)
#+END_SRC

*** My init echo area message
    This may breaks in future versions, look at http://yann.hodique.info/blog/rant-obfuscation-in-emacs/
#+BEGIN_SRC elisp
(defun display-startup-echo-area-message nil
  (setq gc-cons-threshold gc-cons-threshold-usual)
  ;;(setq warning-minimum-log-level :warning)
  (message "gc-cons-threshold restored to %S; Emacs init time: %s!"
           gc-cons-threshold (emacs-init-time)))
#+END_SRC

*** Scratch message
#+BEGIN_SRC elisp
  ;; (setq initial-scratch-message ";;;;;;;;;;;;; Bon Dia!!!! ;;;;;;;;;;;;;;;;\n\n\n")
  (setq initial-scratch-message ";; ╔═╗┌─┐┬─┐┌─┐┌┬┐┌─┐┬ ┬\n;; ╚═╗│  ├┬┘├─┤ │ │  ├─┤\n;; ╚═╝└─┘┴└─┴ ┴ ┴ └─┘┴ ┴\n")

#+END_SRC
*** **message* buffer
#+BEGIN_SRC elisp
(setq message-log-max 1000)
#+END_SRC
*** not useful GUI modes
#+BEGIN_SRC elisp
(when (functionp 'menu-bar-mode)
  (menu-bar-mode -1))
(when (functionp 'set-scroll-bar-mode)
  (set-scroll-bar-mode 'nil))
(when (functionp 'mouse-wheel-mode)
  (mouse-wheel-mode -1))
(when (functionp 'tooltip-mode)
  (tooltip-mode -1))
(when (functionp 'tool-bar-mode)
  (tool-bar-mode -1))
;; (when (functionp 'blink-cursor-mode)
  ;; (blink-cursor-mode -1))
#+END_SRC
*** StartUp
**** Initial files
#+BEGIN_SRC elisp
  (defvar brust--local-init-files "~/.init-files.el")
  (defvar brust--init-files "~/.emacs.d/.init-files.el")

  (defun brust-init-files nil
    (cl-loop for -file in (with-temp-buffer
                            (insert-file-contents
                             (if (file-exists-p brust--local-init-files)
                                 brust--local-init-files
                               brust--init-files))
                            (delete-matching-lines ";;" (point-min) (point-max))
                            (split-string (buffer-string)))
             do (when (file-exists-p -file)
                  (find-file -file))))

  (add-hook 'emacs-startup-hook #'brust-init-files)
#+END_SRC

#+RESULTS:
| brust-init-files |
**** Create english-word file
   ;; Look at Spell header to undersand the reason of the following code.
    ;; It is used in company-ispell

#+BEGIN_SRC elisp
  (defun brust-create-english-word-file nil
    (let ((p nil))
      (with-temp-buffer
        (when (file-exists-p "~/Dropbox/config/english-words-saved.txt")
          (insert-file-contents "~/Dropbox/config/english-words-saved.txt")
          (end-of-buffer)
          (setq p t))
        (when (file-exists-p "~/Dropbox/config/personal-words.txt")
          (insert-file-contents "~/Dropbox/config/personal-words.txt")
          (end-of-buffer)
          (setq p t))
        (when p
          (write-file "~/.emacs.d/english-words.txt")))))

  (add-hook 'emacs-startup-hook #'brust-create-english-word-file)
#+END_SRC

#+RESULTS:
| brust-create-english-word-file | brust-init-files |

*** Clipboard
     Save whatever in the current (system) clipboard before replacing it with the Emacs' text.
#+BEGIN_SRC elisp
  (setq save-interprogram-paste-before-kill t
        kill-ring-max 50)
#+END_SRC

*** Do not ding
  Quiet, please! No dinging!

#+BEGIN_SRC elisp
  (setq visible-bell nil
        ring-bell-function
        `(lambda ()
           (let ((-face-background (face-background 'default)))
                 ;; (-face-font (face-font 'default))
                 ;; (set-face-font 'default "DodgerBlue")
                 (set-face-background 'default "DodgerBlue")
                 (set-face-background 'default -face-background))))
#+END_SRC

#+RESULTS:
| lambda | nil | (let ((-face-background (face-background (quote default)))) (set-face-background (quote default) DodgerBlue) (set-face-background (quote default) -face-background)) |

*** Echo keystrokes
    Nonzero means echo unfinished commands after this many seconds of pause.
#+BEGIN_SRC elisp
(setq echo-keystrokes 0.01)
#+END_SRC
*** COMMENT Commands history
    #+BEGIN_SRC elisp
  (setq list-command-history-max 10000)
  (global-set-key (kbd "C-h c") 'list-command-history)
#+END_SRC
*** Killing Emacs
#+BEGIN_SRC elisp
  (setq confirm-kill-emacs nil)
  (require 'cl)
  (defun brust-update-personal-words nil
    (when (and (file-exists-p "~/.aspell.en.pws")
               (file-exists-p "~/Dropbox/config/personal-words.txt"))
      (with-temp-buffer
        (insert-file-contents "~/.aspell.en.pws")
        (delete-region (point) (1+ (point-at-eol)))
        (insert-file-contents "~/Dropbox/config/personal-words.txt")
        (delete-duplicate-lines (point-min) (point-max))
        (write-file "~/Dropbox/config/personal-words.txt"))))

  (defadvice save-buffers-kill-emacs (around no-query-kill-emacs activate)
    (cl-flet ((process-list ()))
      (brust-update-personal-words)
      ad-do-it))
#+END_SRC

#+RESULTS:
: save-buffers-kill-emacs

*** Set Monoid font family.
#+BEGIN_SRC elisp
  (when (member "IBM Plex Mono" (font-family-list))
    (set-frame-font "IBM Plex Mono Light 13")
    (add-to-list 'initial-frame-alist '(font . "IBM Plex Mono Light"))
    (add-to-list 'default-frame-alist '(font . "IBM Plex Mono Light")))
#+END_SRC

#+RESULTS:
: ((font . IBM Plex Mono Light) (background-color . #282828) (font . Monoid HalfTight) (vertical-scroll-bars))

*** Sentences end with a single space
    In my world, sentences end with a single space. This makes
    sentence navigation commands work for me (Sacha Chua).
    But in elisp mode!

#+BEGIN_SRC emacs-lisp
  (setq sentence-end-double-space nil
        sentence-end "[.?!][]\"')]*\\($\\|\t\\| \\)[ \t\n]*")
#+END_SRC

#+RESULTS:
| y-sp | brust-elisp-sentence-end-double-sapce-t | n-auto-fill |
*** Idle update
#+BEGIN_SRC elisp
(setq idle-update-delay 2)
#+END_SRC

*** European agenda.

#+BEGIN_SRC elisp
(setq european-calendar-style t
      calendar-week-start-day 1)
#+END_SRC

*** Spelling
I use the default personal dictionary for aspell "~/aspell.en.pws".
A personal dictionary has a language assigned (look at the first line), so
when one fix a personal personal dictionary there are problems when one changes the dictionary.
#+BEGIN_SRC elisp
  (setq ispell-program-name "aspell"
        ispell-really-aspell t
        ispell-silently-savep t
        ispell-quietly t
        ;; ispell-personal-dictionary (file-truename "~/Dropbox/config/english-words.txt")
        ) ;; "~/.emacs.d/myDictionary.pws"
  (require 'flyspell)

  (setq flyspell-default-dictionary "en")
#+END_SRC

#+RESULTS:
: brust-ispell-change-dictionary

 %%% ispell-local-dictionary: "british" or "catalan"

*** Dialog
#+BEGIN_SRC elisp
  (setq use-file-dialog nil
        use-dialog-box nil)
#+END_SRC

*** Scroll

**** COMMENT Slow speed
     Font lock the whole buffer or just the visible part with idle:
#+BEGIN_SRC elisp
(setq jit-lock-defer-time 0.05)

#+END_SRC
**** Setting
#+BEGIN_SRC elisp
  (setq scroll-conservatively 1000
        scroll-error-top-bottom t
        scroll-preserve-screen-position 'keep) ; nil, 'keep 'always
#+END_SRC

*** Mark
    When popping the mark, continue popping until the cursor
    actually moves. (from endless)
#+BEGIN_SRC elisp
  (defun modi/multi-pop-to-mark (orig-fun &rest args)
    "Call ORIG-FUN until the cursor moves.
  Try the repeated popping up to 10 times."
    (let ((p (point)))
      (dotimes (i 10)
        (when (= p (point))
          (apply orig-fun args)))))

  (advice-add 'pop-to-mark-command :around
              #'modi/multi-pop-to-mark)

#+END_SRC

    Jump with C-u C-SPC, C-SPC... insted of C-u C-SPC, C-u C-SPC,...
#+BEGIN_SRC elisp
(setq set-mark-command-repeat-pop t)
#+END_SRC

*** Kill backward line
#+BEGIN_SRC elisp
  (defadvice kill-backward-line (before iterativefy activate)
    (and (= (point) (point-at-bol)) (kill-backward-chars 1)))

#+END_SRC

*** Big files
    Warn when opening files bigger than 10MB
#+BEGIN_SRC elisp
(setq large-file-warning-threshold 10000000)
#+END_SRC

*** Local Variables
    Set save all local variable and do not query.
#+BEGIN_SRC elisp
(setq enable-local-variables :all)
#+END_SRC

*** COMMENT Delete bad timers
#+BEGIN_SRC elisp
  (run-with-idle-timer 5 nil #'brust-delete-bad-idle-timers)
  ;; (run-with-idle-timer 5 nil #'brust-delete-bad-timers)

  (defun brust-delete-bad-idle-timers nil
    (setq timer-idle-list (cl-loop for -timer in timer-idle-list
                                   when (ignore-errors (fboundp (timer--function -timer)))
                                   collect -timer)))

  (defun brust-delete-bad-timers nil
    (setq timer-list (cl-loop for -timer in timer-list
                              when (ignore-errors (fboundp (timer--function -timer)))
                              collect -timer)))
#+END_SRC

#+RESULTS:
: brust-delete-bad-timers

*** Not edit the mini-buffer prompt
    Stop Cursor Going into mini-buffer prompt, from http://ergoemacs.org/emacs/emacs_stop_cursor_enter_prompt.html
#+BEGIN_SRC elisp
;; (customize-set-variable
 (setq minibuffer-prompt-properties
 (quote (read-only t cursor-intangible t face minibuffer-prompt)))

#+END_SRC
*** TODO Enable
    Learn to use =set-goal-column=!!
#+BEGIN_SRC elisp
;;; Enable disabled commands

(put 'erase-buffer    'disabled nil)
(put 'eval-expression 'disabled nil)   ; Let ESC-ESC work
(put 'upcase-region   'disabled nil)
(put 'downcase-region 'disabled nil)
(put 'list-timers     'disabled nil)
;; (put 'set-goal-column             'disabled nil)
;; (put 'company-coq-fold            'disabled nil)
;; (put 'TeX-narrow-to-group         'disabled nil)
;; (put 'LaTeX-narrow-to-environment 'disabled nil)
;; (put 'narrow-to-region            'disabled nil)
;; (put 'narrow-to-defun             'disabled nil)
;; (put 'narrow-to-page              'disabled nil)
#+END_SRC

*** Auto create non-existent files
#+BEGIN_SRC elisp
(setq confirm-nonexistent-file-or-buffer nil)
#+END_SRC

*** Answer any question with y or n
#+BEGIN_SRC elisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

*** COMMENT Use Caps as Super
#+BEGIN_SRC elisp
  (shell-command "setxkbmap -option caps:super")
  ;; (shell-command "xmodmap ~/.Xmodmap")
  (kill-buffer "*Shell Command Output*")
#+END_SRC

** Package.el
*** General setting
#+BEGIN_SRC elisp
  (require 'package)

  (cl-loop for pack in
           '(("org"          . "http://orgmode.org/elpa/")
             ;; ("gnu"          . "http://mirrors.163.com/elpa/gnu/")
             ("marmalade" . "http://marmalade-repo.org/packages/") ;;unsatable
             ("melpa"        . "http://melpa.org/packages/"))
           do (cl-pushnew pack package-archives))
#+END_SRC
*** Initialize
   Emacs run =(package-initialize)= after load the init file and before the =after-init-hook=
   this avoid it
#+BEGIN_SRC elisp
    (setq package-enable-at-startup nil)
#+END_SRC

#+BEGIN_SRC elisp
    (package-initialize)

    (unless package-archive-contents
      (package-refresh-contents))
#+END_SRC
*** Refresh before installing
    If the installation of some packages is required, then run =(package-refresh-contents)= before installing the first.
#+BEGIN_SRC elisp
  (defun my-package-install-refresh-contents (&rest args)
    (package-refresh-contents)
    (advice-remove 'package-install 'my-package-install-refresh-contents))

  (advice-add 'package-install :before 'my-package-install-refresh-contents)
#+END_SRC
** Use-package
*** If it is not installed
#+BEGIN_SRC elisp
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))

#+END_SRC

*** Setting
#+BEGIN_SRC elisp
    ;;(require 'use-package)
    (setq use-package-verbose t)
    (setq use-package-always-ensure t) ;;Avoid =:ensure t=

#+END_SRC
*** Complement packages
#+BEGIN_SRC elisp
  ;; Auto-compile ensure that is using the newer version of the packages.
  (use-package auto-compile
    :init
    (setq load-prefer-newer t)
    (auto-compile-on-load-mode))

  ;; (use-package diminish) I created my own mode line, which just shows the major-mode

  (use-package key-chord
    :init
    (setq key-chord-one-key-delay 0.16
          key-chord-two-keys-delay 0.8)
    (key-chord-mode 1)
    :config
    (defadvice key-chord-define (after bind-just-one-key-chord activate)
      "Undefine the transposed key chord that key chord defines by default."
      (let ((key1 (logand 255 (aref keys 0)))
            (key2 (logand 255 (aref keys 1))))
        (unless (eq key1 key2)
          (define-key keymap (vector 'key-chord key2 key1) nil))))
    (defun disable-key-chord-mode ()
      "Disable key chords locally"
      (set (make-local-variable 'input-method-function) nil))
    ;; Disable key-chors in minibuffer
    (add-hook 'minibuffer-setup-hook #'disable-key-chord-mode))

  (use-package use-package-chords
    :config
    (defmacro bind-chord (chord command &optional keymap)
      "Bind CHORD to COMMAND in KEYMAP (`global-map' if not passed)."
      (let ((key1 (logand 255 (aref chord 0)))
            (key2 (logand 255 (aref chord 1))))
        `(bind-key (vector 'key-chord ,key1 ,key2) ,command ,keymap))))

  (use-package bind-key)

  (use-package package-utils)
#+END_SRC
*** Load all my paths
    Handy hack to add to the load path all files and folder in a folder.
#+BEGIN_SRC elisp
  (let ((default-directory  "~/.emacs.d/lisp/"))
    (normal-top-level-add-subdirs-to-load-path))

  (cl-pushnew "~/.emacs.d/lisp" load-path)
#+END_SRC

#+RESULTS:
| ~/.emacs.d/lisp | ~/.emacs.d/lisp/Singular | /home/laury/.emacs.d/lisp/Singular/ | /home/laury/.emacs.d/elpa/org-ref-20190706.2059/citeproc/csl | /home/laury/.emacs.d/elpa/org-ref-20190706.2059/citeproc | ~/.emacs.d/lisp | /home/laury/.emacs.d/elpa/ace-window-20190708.933 | /home/laury/.emacs.d/elpa/adaptive-wrap-0.7 | /home/laury/.emacs.d/elpa/aggressive-indent-20190218.2331 | /home/laury/.emacs.d/elpa/anki-editor-20190608.1621 | /home/laury/.emacs.d/elpa/auto-compile-20181230.2216 | /home/laury/.emacs.d/elpa/avy-20190630.1538 | /home/laury/.emacs.d/elpa/beacon-20190104.1931 | /home/laury/.emacs.d/elpa/cdlatex-20190130.1419 | /home/laury/.emacs.d/elpa/company-auctex-20180725.1912 | /home/laury/.emacs.d/elpa/auctex-12.1.2 | /home/laury/.emacs.d/elpa/company-shell-20170518.541 | /home/laury/.emacs.d/elpa/company-statistics-20170210.1933 | /home/laury/.emacs.d/elpa/company-20190430.1852 | /home/laury/.emacs.d/elpa/counsel-org-clock-20190407.348 | /home/laury/.emacs.d/elpa/counsel-projectile-20190724.1903 | /home/laury/.emacs.d/elpa/counsel-20190726.1745 | /home/laury/.emacs.d/elpa/darktooth-theme-20190412.142 | /home/laury/.emacs.d/elpa/autothemer-20180920.923 | /home/laury/.emacs.d/elpa/diminish-20170419.1736 | /home/laury/.emacs.d/elpa/easy-kill-20181114.2330 | /home/laury/.emacs.d/elpa/expand-region-20190416.538 | /home/laury/.emacs.d/elpa/flyspell-correct-ivy-20181205.1932 | /home/laury/.emacs.d/elpa/flyspell-correct-20190408.1010 | /home/laury/.emacs.d/elpa/git-gutter-fringe+-20140729.1103 | /home/laury/.emacs.d/elpa/fringe-helper-20140620.2109 | /home/laury/.emacs.d/elpa/git-gutter+-20151204.1723 | /home/laury/.emacs.d/elpa/golden-ratio-20150819.1120 | /home/laury/.emacs.d/elpa/goto-chg-20190110.2114 | /home/laury/.emacs.d/elpa/helpful-20190723.2348 | /home/laury/.emacs.d/elpa/elisp-refs-20190323.1331 | /home/laury/.emacs.d/elpa/dash-functional-20180107.1618 | /home/laury/.emacs.d/elpa/ibuffer-vc-20181225.2227 | /home/laury/.emacs.d/elpa/ivy-bibtex-20190708.909 | /home/laury/.emacs.d/elpa/ivy-rich-20190707.107 | /home/laury/.emacs.d/elpa/ivy-yasnippet-20181002.1655 | /home/laury/.emacs.d/elpa/ledger-mode-20190709.548 | /home/laury/.emacs.d/elpa/loop-20160813.1407 | /home/laury/.emacs.d/elpa/mic-paren-20170731.1907 | /home/laury/.emacs.d/elpa/nyan-mode-20170423.740 | /home/laury/.emacs.d/elpa/org-bullets-20180208.2343 | /home/laury/.emacs.d/elpa/org-ref-20190706.2059 | /home/laury/.emacs.d/elpa/hydra-20190617.859 | /home/laury/.emacs.d/elpa/lv-20190716.1741 | /home/laury/.emacs.d/elpa/helm-bibtex-20190708.909 | /home/laury/.emacs.d/elpa/biblio-20190624.1408 | /home/laury/.emacs.d/elpa/biblio-core-20190624.1408 | /home/laury/.emacs.d/elpa/f-20190109.906 | /home/laury/.emacs.d/elpa/helm-20190729.513 | /home/laury/.emacs.d/elpa/helm-core-20190726.1001 | /home/laury/.emacs.d/elpa/htmlize-20180923.1829 | /home/laury/.emacs.d/elpa/package-utils-20180514.1415 | /home/laury/.emacs.d/elpa/packed-20180318.1729 | /home/laury/.emacs.d/elpa/parsebib-20181219.928 | /home/laury/.emacs.d/elpa/pdf-tools-20190701.202 | /home/laury/.emacs.d/elpa/popup-20160709.1429 | /home/laury/.emacs.d/elpa/projectile-20190626.1315 | /home/laury/.emacs.d/elpa/pkg-info-20150517.1143 | /home/laury/.emacs.d/elpa/epl-20180205.2049 | /home/laury/.emacs.d/elpa/request-20190727.1416 | /home/laury/.emacs.d/elpa/restart-emacs-20180601.1031 | /home/laury/.emacs.d/elpa/s-20180406.808 | /home/laury/.emacs.d/elpa/sage-shell-mode-20180215.835 | /home/laury/.emacs.d/elpa/deferred-20170901.1330 | /home/laury/.emacs.d/elpa/sass-mode-20190502.53 | /home/laury/.emacs.d/elpa/haml-mode-20190219.2102 | /home/laury/.emacs.d/elpa/smart-mode-line-20190527.1156 | /home/laury/.emacs.d/elpa/rich-minority-20190419.1136 | /home/laury/.emacs.d/elpa/smartparens-20190728.2037 | /home/laury/.emacs.d/elpa/smex-20151212.2209 | /home/laury/.emacs.d/elpa/swiper-20190726.1746 | /home/laury/.emacs.d/elpa/ivy-20190726.2134 | /home/laury/.emacs.d/elpa/tablist-20190414.643 | /home/laury/.emacs.d/elpa/transpose-frame-20151126.1426 | /home/laury/.emacs.d/elpa/twittering-mode-20181121.1402 | /home/laury/.emacs.d/elpa/undo-tree-0.6.5 | /home/laury/.emacs.d/elpa/use-package-chords-20181024.2322 | /home/laury/.emacs.d/elpa/bind-chord-20171204.2010 | /home/laury/.emacs.d/elpa/key-chord-20160227.1238 | /home/laury/.emacs.d/elpa/use-package-20190716.1829 | /home/laury/.emacs.d/elpa/bind-key-20180513.430 | /home/laury/.emacs.d/elpa/visual-fill-column-20190422.2154 | /home/laury/.emacs.d/elpa/visual-regexp-20190414.814 | /home/laury/.emacs.d/elpa/wgrep-20181229.40 | /home/laury/.emacs.d/elpa/which-key-20190723.1552 | /home/laury/.emacs.d/elpa/whitespace-cleanup-mode-20190106.2022 | /home/laury/.emacs.d/elpa/yasnippet-snippets-20190725.1049 | /home/laury/.emacs.d/elpa/yasnippet-20190724.1204 | /home/laury/.emacs.d/elpa/zone-nyan-20170818.1644 | /home/laury/.emacs.d/elpa/esxml-20171129.807 | /usr/share/emacs/site-lisp/elpa/ess-18.10.2/obsolete/ | /usr/share/emacs/site-lisp/elpa/ess-18.10.2/ | /usr/share/emacs/site-lisp/latex-cjk-thai | /usr/share/emacs/site-lisp/latex-cjk-common | /usr/share/emacs/site-lisp/auctex | /etc/emacs | /usr/local/share/emacs/26.1/site-lisp | /usr/local/share/emacs/site-lisp | /usr/share/emacs/site-lisp/dictionaries-common | /usr/share/emacs/site-lisp/autoconf | /usr/share/emacs/26.1/site-lisp | /usr/share/emacs/site-lisp | /usr/share/emacs/site-lisp/autoconf | /usr/share/emacs/site-lisp/elpa | /usr/share/emacs/site-lisp/elpa-src | /usr/share/emacs/site-lisp/latex-cjk-common | /usr/share/emacs/site-lisp/latex-cjk-thai | /usr/share/emacs/site-lisp/elpa/async-1.9.3 | /usr/share/emacs/site-lisp/elpa/dash-2.14.1 | /usr/share/emacs/site-lisp/elpa/ess-18.10.2 | /usr/share/emacs/site-lisp/elpa/ghub-3.0.0 | /usr/share/emacs/site-lisp/elpa/git-commit-2.90.1 | /usr/share/emacs/site-lisp/elpa/graphql-0.1.1 | /usr/share/emacs/site-lisp/elpa/let-alist-1.0.5 | /usr/share/emacs/site-lisp/elpa/magit-2.90.1 | /usr/share/emacs/site-lisp/elpa/magit-popup-2.12.5 | /usr/share/emacs/site-lisp/elpa/treepy-0.1.1 | /usr/share/emacs/site-lisp/elpa/with-editor-2.6.0 | /usr/share/emacs/site-lisp/elpa-src/async-1.9.3 | /usr/share/emacs/site-lisp/elpa-src/dash-2.14.1 | /usr/share/emacs/site-lisp/elpa-src/ess-18.10.2 | /usr/share/emacs/site-lisp/elpa-src/ghub-3.0.0 | /usr/share/emacs/site-lisp/elpa-src/git-commit-2.90.1 | /usr/share/emacs/site-lisp/elpa-src/graphql-0.1.1 | /usr/share/emacs/site-lisp/elpa-src/let-alist-1.0.5 | /usr/share/emacs/site-lisp/elpa-src/magit-2.90.1 | /usr/share/emacs/site-lisp/elpa-src/magit-popup-2.12.5 | /usr/share/emacs/site-lisp/elpa-src/treepy-0.1.1 | /usr/share/emacs/site-lisp/elpa-src/with-editor-2.6.0 | /usr/share/emacs/site-lisp/elpa/ess-18.10.2/etc | /usr/share/emacs/site-lisp/elpa-src/ess-18.10.2/etc | /usr/share/emacs/site-lisp/elpa/ess-18.10.2/etc/ESSR | /usr/share/emacs/site-lisp/elpa/ess-18.10.2/etc/icons | /usr/share/emacs/site-lisp/elpa/ess-18.10.2/etc/other | /usr/share/emacs/site-lisp/elpa-src/ess-18.10.2/etc/ESSR | /usr/share/emacs/site-lisp/elpa-src/ess-18.10.2/etc/icons | /usr/share/emacs/site-lisp/elpa-src/ess-18.10.2/etc/other | /usr/share/emacs/site-lisp/elpa/ess-18.10.2/etc/ESSR/R | /usr/share/emacs/site-lisp/elpa/ess-18.10.2/etc/other/pkg1 | /usr/share/emacs/site-lisp/elpa/ess-18.10.2/etc/other/pkg1/R | /usr/share/emacs/site-lisp/elpa/ess-18.10.2/etc/other/pkg1/man | /usr/share/emacs/26.1/lisp | /usr/share/emacs/26.1/lisp/vc | /usr/share/emacs/26.1/lisp/url | /usr/share/emacs/26.1/lisp/textmodes | /usr/share/emacs/26.1/lisp/progmodes | /usr/share/emacs/26.1/lisp/play | /usr/share/emacs/26.1/lisp/org | /usr/share/emacs/26.1/lisp/nxml | /usr/share/emacs/26.1/lisp/net | /usr/share/emacs/26.1/lisp/mh-e | /usr/share/emacs/26.1/lisp/mail | /usr/share/emacs/26.1/lisp/leim | /usr/share/emacs/26.1/lisp/language | /usr/share/emacs/26.1/lisp/international | /usr/share/emacs/26.1/lisp/image | /usr/share/emacs/26.1/lisp/gnus | /usr/share/emacs/26.1/lisp/eshell | /usr/share/emacs/26.1/lisp/erc | /usr/share/emacs/26.1/lisp/emulation | /usr/share/emacs/26.1/lisp/emacs-lisp | /usr/share/emacs/26.1/lisp/cedet | /usr/share/emacs/26.1/lisp/calendar | /usr/share/emacs/26.1/lisp/calc | /usr/share/emacs/26.1/lisp/obsolete | /usr/share/auctex | /home/laury/.emacs.d/lisp/Emacs-123-Menu-master | /home/laury/.emacs.d/lisp/Singular | /home/laury/.emacs.d/lisp/benchmark-init-el-master | /home/laury/.emacs.d/lisp/bibretrieve | /home/laury/.emacs.d/lisp/emms-mode-line-cycle-master | /home/laury/.emacs.d/lisp/jkitchin-words | /home/laury/.emacs.d/lisp/julia-emacs | /home/laury/.emacs.d/lisp/julia-repl | /home/laury/.emacs.d/lisp/keyfreq | /home/laury/.emacs.d/lisp/ob-julia | /home/laury/.emacs.d/lisp/sunshine | /home/laury/.emacs.d/lisp/vCard | /home/laury/.emacs.d/lisp/wc-mode | /home/laury/.emacs.d/lisp/ob-julia/HTML | /home/laury/.emacs.d/lisp/ob-julia/images | /home/laury/.emacs.d/lisp/ob-julia/jl | /home/laury/.emacs.d/lisp/ob-julia/lisp | /home/laury/.emacs.d/lisp/ob-julia/pdf | /home/laury/.emacs.d/lisp/ob-julia/tex | /home/laury/.emacs.d/lisp/sunshine/images |

** TODO Emacs looks
*** Color theme
#+BEGIN_SRC elisp
  (add-to-list 'custom-theme-load-path "~/.emacs.d/themes/")
  (load-theme 'tsdh-dark-brusten t)
  ;;(load-theme 'darktooth t)

  (use-package darktooth-theme
    :init
    (load-theme 'darktooth t))
#+END_SRC
*** TODO My mode line
    :PROPERTIES:
    :ID:       cb1d577a-ce25-4009-8385-4129785d5c4e
    :END:
**** Faces

#+BEGIN_SRC elisp
  ;; Extra mode line faces
  (make-face 'mode-line-read-only-face)
  (make-face 'mode-line-modified-face)
  (make-face 'mode-line-folder-face)
  (make-face 'mode-line-filename-face)
  (make-face 'mode-line-position-face)
  (make-face 'mode-line-mode-face)
  (make-face 'mode-line-minor-mode-face)
  (make-face 'mode-line-process-face)
  (make-face 'mode-line-80col-face)
  (make-face 'mode-line-bars-face)
  (make-face 'mode-line-top-line-number)

  (set-face-attribute
   'mode-line-top-line-number nil
   :inherit 'mode-line-face
   :foreground "gray60"
   :height 0.7)
  (set-face-attribute
   'mode-line-bars-face nil
   :inherit 'sml/col-number
   :weight 'bold)
  (set-face-attribute
   'mode-line-read-only-face nil
   :family "Sans Serif"
   :weight 'bold
   :foreground "#4271ae"
   :box '(:line-width 1 :color "#4271ae"))
  (set-face-attribute
   'mode-line-modified-face nil
   ;; :inherit 'mode-line-face
   :family "Sans Serif"
   :weight 'bold
   :foreground "#c82829"
   :background "#FDF4C1"
   :box '(:line-width 1 :color "#c82829"))
  (set-face-attribute
   'mode-line-folder-face nil
   :inherit 'mode-line-face
   :foreground "gray60")
  (set-face-attribute
   'mode-line-filename-face nil
   :inherit 'mode-line-face
   :foreground "#eab700"
   :weight 'bold)
  (set-face-attribute
   'mode-line-position-face nil
   :inherit 'mode-line-face
   :family "Menlo" :height 100)
  (set-face-attribute
   'mode-line-mode-face nil
   :inherit 'mode-line-face
   :foreground "gray80")
  (set-face-attribute
   'mode-line-minor-mode-face nil
   :inherit 'mode-line-mode-face
   :foreground "gray40"
   :height 110)
  (set-face-attribute
   'mode-line-process-face nil
   :inherit 'mode-line-face
   :foreground "#718c00")
  (set-face-attribute
   'mode-line-80col-face nil
   :inherit 'sml/col-number
   :foreground "black"
   :background "#eab700")
  (set-face-attribute
   'mode-line-highlight nil
   :inherit 'mode-line-face
   :box '(:line-width 1 :color "orange red" :style released-button))
#+END_SRC

#+RESULTS:
**** COMMENT Mode line bigger
     https://www.gonsie.com/blorg/modeline.html
#+begin_src elisp
(set-face-attribute 'mode-line nil
                    :background "#353644"
                    :foreground "white"
                    :box '(:line-width 8 :color "#353644")
                    :overline nil
                    :underline nil)

(set-face-attribute 'mode-line-inactive nil
                    :background "#565063"
                    :foreground "white"
                    :box '(:line-width 8 :color "#565063")
                    :overline nil
                    :underline nil)
#+end_src

**** TODO Key bind
      :TODO: help-echo not show these functions!!!
       It's nice to get the file path in a fast way and where doesn't bother.
#+BEGIN_SRC elisp
(setq mode-line-buffer-identification-keymap
  ;; Add menu of buffer operations to the buffer identification part
  ;; of the mode line.or header line.
  (let ((map (make-sparse-keymap)))
    ;; Bind down- events so that the global keymap won't ``shine
    ;; through''.
    (define-key map [mode-line mouse-1] 'xah-copy-file-path)
    (define-key map [mode-line mouse-3] 'brust-copy-directory-only) ;; copy file path to kill ring
    (define-key map [header-line mouse-1] 'xah-copy-file-path)
    (define-key map [header-line mouse-3] 'brust-copy-directory-only)
    (define-key map [header-line down-mouse-1] 'ignore)
    (define-key map [header-line down-mouse-3] 'ignore)
    map))

#+END_SRC
**** Mode-Line-Buffer-Identification:

   #+BEGIN_SRC elisp
     (with-eval-after-load 'subr-x
       (setq-default
        mode-line-buffer-identification
        '(:eval
          (format-mode-line
           (propertized-buffer-identification
            (or
             (when-let (buffer-file-truename buffer-file-truename)
               (file-name-nondirectory buffer-file-truename))
             "%b"))))))
   #+END_SRC

**** Smart-mode-line colors
#+BEGIN_SRC elisp
  (defface sml/global '((t :inverse-video nil)) "" :group 'smart-mode-line-faces)
  (defface sml/modes '((t :inherit sml/global)) "" :group 'smart-mode-line-faces)
  (defface sml/line-number '((t :inherit sml/modes :weight bold)) "" :group 'smart-mode-line-faces)
  (defface sml/col-number '((t :inherit sml/global)) "" :group 'smart-mode-line-faces)

  (custom-set-faces
   '(sml/global ((t :foreground "gray50" :inverse-video nil)))
   '(sml/modes ((t :inherit sml/global :foreground "White"))))
#+END_SRC

#+RESULTS:

**** Verison-control-mode
***** Define faces.
#+begin_src elisp
  (defface brust-vc-base
    '((t (:inherit mode-line-face :weight bold :height 0.7)))
    "VC status tag base face for files that are under version control."
    :group 'brust-vc-mode-line-face)

  (defface brust-vc-added
    '((t (:inherit brust-vc-base :background "#FFAA55" :foreground "black")))
    "VC status tag face for files that are under version control
  but which have been added."
    :group 'brust-vc-mode-line-face)

  (defface brust-vc-edited
    '((t (:inherit brust-vc-base :background "#F05B80" :foreground "black"))) ; "#F04040" maybe?
    "VC status tag face for files that are under version control
  but which have been edited."
    :group 'brust-vc-mode-line-face)

  (defface brust-vc-in-sync
    '((t (:inherit brust-vc-base :background "#60CC60"  :foreground "black")))
    "VC status tag face for files that are under version control
  and which are in sync with the respository."
    :group 'brust-vc-mode-line-face)

  (defface brust-vc-unknown
    '((t (:inherit brust-vc-base :background "#FF0000"  :foreground "white")))
    "VC status tag face for files whose version-control status
  cannot be determined."
    :group 'brust-vc-mode-line-face)
#+end_src

#+RESULTS:
: brust-vc-unknown

***** Function
#+begin_src elisp
  (defvar my-vc-mode-attrs
    '(;; (""  . (" Non vc " . my/mode:vc-none))
      ("-" . brust-vc-in-sync)
      (":" . brust-vc-edited)
      ("@" . brust-vc-added))
    "Lookup table to translate vc-mode character into another string/face.")

  ;; This function helps me understand the version-control status.
  (defun my-mode-line-vc-info nil
    "Return version-control status information about the file in
    the current buffer, as a fontified string.

    The mode-line variable `vc-mode' is nil if the file is not under
    version control, and displays a hyphen or a colon depending on whether
    the file has been modified since check-in.  I can never keep those
    straight.

    This function returns \"NoVC\" if the file is not under version
    control.  It displays a string with an = sign if the file is in sync
    with its version control, and a string with a > sign if the file has
    been modified since its last check-in."
    (cond
     ;; If not under version-control print nothing
     ((not vc-mode) "")
     ;; If under version-control decode the -:@ character
     ((string-match "\\` ?\\(?:CVS\\|Git\\)\\([-:@]\\)\\([^^:~ \x00-\x1F\\\\/]+\\)?" vc-mode)
      (propertize (concat " " (match-string-no-properties 2 vc-mode) " ")
                  'face
                  (cdr (assoc (match-string-no-properties 1 vc-mode) my-vc-mode-attrs))))
     ;; Otherwise, indicate confusion
     (t (propertize "?vc?" 'face brust-vc-unknown))))
#+end_src

#+RESULTS:
: my-mode-line-vc-info

**** Display time.
    Show the time in 24hr format, the date and time
    and not show the average of loads.

#+BEGIN_SRC elisp
  ;; Display time
  (display-time-mode t)

  (defun brust-kill-date nil
    (interactive)
    (kill-new (format-time-string "%a, %b %e %Y" (current-time))))

  ;; Time format
  (customize-set-variable 'display-time-string-forms
                          '((propertize (concat dayname
                                                " " 12-hours ":" minutes am-pm " ")
                                        'help-echo (format-time-string "%a, %b %e %Y" now)
                                        'mouse-face 'mode-line-highlight
                                        'keymap '(mode-line keymap
                                                            (mouse-1 . brust-kill-date)))))

  ;; Update display-time-string
  (display-time-update)

  ;; Remove display-time-string from global-mode-string
  (add-hook 'after-init-hook #'(lambda nil (setq global-mode-string (delq 'display-time-string global-mode-string)) (display-time-update)))

  ;; (setq display-time-24hr-format t
  ;;       display-time-day-and-date t
  ;;       display-time-default-load-average nil)
#+END_SRC

#+RESULTS:
|   | (:eval mu4e-alert-mode-line) |
**** Battery percentage
#+begin_src elisp
  (require 'battery)
  (display-battery-mode 1)
  (setq global-mode-string (delq 'battery-mode-line-string global-mode-string)
        battery-update-interval (* 30 1)
        battery-mode-line-format "%b%p%%, %th")

  (defface sml/charging
    '((t :inherit sml/global :foreground "ForestGreen")) "" :group 'smart-mode-line-faces)
  (defface sml/discharging
    '((t :inherit sml/global :foreground "Red")) "" :group 'smart-mode-line-faces)

  (defun brust-battery-mode-line-string nil
    (if (string-equal "AC" (cdr (assoc 76 (funcall battery-status-function))))
        (propertize battery-mode-line-string 'face 'sml/charging)
      (propertize battery-mode-line-string 'face 'sml/discharging)))


  ;;   (defadvice battery-update (before my/pl-colorize-battery-advice activate)
  ;;     "Colorize the battery load string depending on its status (dis/charging)."
  ;;     (if (string-equal "AC" (cdr (assoc 76 (funcall battery-status-function))))
  ;;         (copy-face 'sml/charging 'sml/battery)
  ;;       (copy-face 'sml/discharging 'sml/battery)))
  ;;
  ;;   (defadvice battery-update (after sml/after-battery-update-advice () activate)
  ;;     "Change battery color."
  ;;     (when battery-mode-line-string
  ;;       (setq battery-mode-line-string
  ;;             (concat (propertize battery-mode-line-string 'face 'sml/battery) " "))))
#+end_src

#+RESULTS:
: brust-battery-mode-line-string

**** My customization
#+BEGIN_SRC elisp
  (setq-default
   mode-line-format
   '("%e"
     ;;   mode-line-mule-info
     ;;   mode-line-client
     ;; Position, including warning for 80 columns
     ;; (:propertize " --[" face mode-line-bars-face)
     ;; (:eval mu4e-alert-mode-line)
     (:propertize "||" face mode-line-bars-face)
     ;; (:propertize "|" face mode-line-bars-face)
     (:propertize display-time-string face mode-line-buffer-id)
     ;;mode-line-misc-info
     ;;(:propertize "|" face mode-line-bars-face)
     ;; " "
     (:eval
      (cond (buffer-read-only
             (propertize " RO " 'face 'mode-line-read-only-face))
            ((buffer-modified-p)
             (propertize " ** " 'face 'mode-line-modified-face))
            (t "   ")))
     " "
     (:propertize "\[" face mode-line-bars-face)
     (:propertize "%l" face mode-line-buffer-id)
     (:eval (propertize (save-excursion (goto-char (point-max)) (format-mode-line "/%l")) 'face 'mode-line-top-line-number))
     ;; (line-number-at-pos (point-max))
     (:propertize ":" face mode-line-buffer-id)
     (:eval (propertize "%c" 'face
                        (if (< (current-column) 80)
                            'sml/col-number
                          'mode-line-80col-face)))
     ;; (:eval (propertize (format "/%s" (- (line-end-position) (line-beginning-position))) 'face 'mode-line-top-line-number))
     (:propertize "\] " face mode-line-bars-face)
     ;; (:propertize "|| " face mode-line-bars-face)
     ;; mode-line-front-space
     ;;      (vc-mode vc-mode)
     ;; sml/pre-modes-separator
     ;; mode-line-frame-identification
     mode-line-buffer-identification
     ;; (:propertize " |[  " face mode-line-bars-face)
     (:propertize (" " "\[" mode-name "\] ") face mode-line-buffer-id)
     (:eval (my-mode-line-vc-info))
     ;; (:propertize global-mode-string face mode-line-buffer-id)
     ;; mu4e-alert-mode-line
     inbox-mode-line-string
     ;; mode-line-misc-info
     ;; mode-line-modes
     ;;(:propertize "| " face mode-line-bars-face)
     ;; (vc-mode vc-mode)
     ;; (vc-mode vc-status)
     (:propertize "|" face mode-line-bars-face)
     ;; nyan-create
     (:eval (nyan-create))
     ;;(:propertize "|| " face mode-line-bars-face)
     ;;(:eval (list (nyan-create)))
     ;;(:propertize "||" face mode-line-bars-face)
     ;;mode-line-percent-position
     ;; mode-line-position
     (:propertize "| " face mode-line-bars-face)
     (:eval (brust-battery-mode-line-string))
     (:propertize "||-%-" face mode-line-bars-face)
     mode-line-end-spaces))
#+END_SRC

#+RESULTS:
| %e | (:propertize |   | face mode-line-bars-face) | (:propertize display-time-string face mode-line-buffer-id) | (:eval (cond (buffer-read-only (propertize  RO  (quote face) (quote mode-line-read-only-face))) ((buffer-modified-p) (propertize  **  (quote face) (quote mode-line-modified-face))) (t    ))) |   | (:propertize [ face mode-line-bars-face) | (:propertize %l face mode-line-buffer-id) | (:eval (propertize (save-excursion (goto-char (point-max)) (format-mode-line /%l)) (quote face) (quote mode-line-top-line-number))) | (:propertize : face mode-line-buffer-id) | (:eval (propertize %c (quote face) (if (< (current-column) 80) (quote sml/col-number) (quote mode-line-80col-face)))) | (:propertize ]  face mode-line-bars-face) | mode-line-buffer-identification | (:propertize (  [ mode-name ] ) face mode-line-buffer-id) | (:eval (my-mode-line-vc-info)) | (:propertize inbox-mode-line-string face brust-vc-edited) | (:propertize | face mode-line-bars-face) | (:eval (nyan-create)) | (:propertize | face mode-line-bars-face) | (:eval (brust-battery-mode-line-string)) | (:propertize |   | -%- face mode-line-bars-face) | mode-line-end-spaces |

** My key binding
*** Global and genric

#+BEGIN_SRC elisp
  (bind-keys*
   ;; ("s-c"        . easy-kill)
   ;; ("s-v"        . hydra-yank-pop/brust-org-yank-or-yank)
   ("M-j"        . undo)
   ("M-h"        . brust-cycle-whitespace)
   ("C-M-h"      . brust-delete-indentation)
   ;; ("M-c"        . brust-endless/capitalize)
   ;; ("M-l"        . brust-endless/downcase)
   ;; ("M-C"        . endless/upcase)
   ;; ("C-+"        . universal-argument)
   ;; ("C-ç"        . negative-argument)
   ;; ("C--"        . undo)
   ("C-x C-S-F"  . xah-open-in-external-app)
   ("C-<f4>"     . save-macro)
   ("M-<f4>"     . kmacro-bind-to-key)
   ;; ("M-ç"        . hippie-expand)
   ;; ("C-9"        . close-quoted-open-paren-right)
   ("M-SPC"      . close-quoted-open-paren-right-or-left)
   ("s-SPC"      . brust-open-paren-hydra/lambda-SPC)
   ;; ("C-)"        . close-all-open-paren-right)
   ;; ("C-8"        . close-quoted-open-paren-left)
   ;; ("C-("        . close-all-open-paren-left)
   ("M-<f3>"      . kmacro-query-my)
   ("C-S-p"      . package-list-packages)
   ("M-\""       . brust-term-bash)
   ("<f5> <f5>"  . brust-toggle-menu-tool-bars)
   ("C-x e"      . eval-defun)
   ("C-d"        . backward-delete-char-untabify)
   ("C-f"        . delete-char)
   ;; ("M-d"     . backward-kill-word)
   ;; ("M-f"     . kill-word)
   ("<home>"     . delete-other-windows)
   ("<end>"      . delete-window)
   ("C-x n l"    . endless/narrow-or-widen-dwim)
   ("s-n"        . endless/narrow-or-widen-dwim))

  (global-set-key (kbd "C-x C-S-e")
                  (lambda (str end) "Eval region" (interactive "r")
                    (eval-region str end)))
  (global-set-key (kbd "S-SPC")
                  (lambda nil "Insert SPC forward" (interactive) (insert " ") (forward-char -1)))
  ;;(global-set-key (kbd "C-<menu>")
  ;;                (lambda nil "Inverse delete indentation" (interactive) (delete-indentation t)))
#+END_SRC

#+RESULTS:
| lambda | nil | Insert SPC forward | (interactive) | (insert  ) | (forward-char -1) |
*** Chords
#+BEGIN_SRC elisp
  (cl-loop for -ch in
           '(("bg" . ivy-switch-buffer)
             ("bf" . brust-ace-window)
             ("ww" . zap-up-to-char)
             ;; ("sç" . save-buffer)
             (".a" . endless/ispell-word-then-abbrev)
             (".s" . flyspell-correct-previous))
           do (key-chord-define-global (car -ch) (cdr -ch)))
#+END_SRC

#+RESULTS:

*** Motion
    The keys were:
    =M-u= fix-word-upcase ; Now bind to M-S-c
    =M-i= tab-to-tab-stop
    =M-o= set-face-*/ center-line/paragraph  hydra-outline/body
    =M-p= nothing
    =M-h= mark-paragraph org-mark-element
    =M-j= indent-new-comment-line
    =M-k= kill-sentence
    =M-l= fix-word-brust-endless/downcase ; Now bind to C-l

    =M-S-u= ==
    =M-S-i= ==
    =M-S-o= ==
    =M-S-p= ==
    =M-S-h= ==
    =M-S-j= ==
    =M-S-k= ==
    =M-S-l= ==

#+BEGIN_SRC elisp
  (bind-keys*
   ("C-a" . brust-smart-move-beginning-of-line)
   ("C-e" . brust-smart-move-end-of-line)
   ("M-<" . brust-toggle-begin&end-of-buffer))

  (bind-keys
   ("s-h" . recenter-top-bottom)
   ("s-M-u" . backward-word)
   ("s-M-i" . backward-paragraph)
   ;; ("s-o" . forward-word)
   ("s-M-o" . forward-word)
   ;; ("s-S-O" . forward-word)
   ("s-M-j" . backward-char)
   ("s-M-k" . forward-paragraph)
   ("s-M-l" . forward-char)
   ("s-l" . bln-forward-half)
   ("s-j" . bln-backward-half)
   ("s-k" . next-line)
   ("s-i" . previous-line)
   ;; ("s-o" . scroll-up-command)
   ("s-m" . scroll-up-command)
   ("s-u" . scroll-down-command)
   ("s-<left>"  . backward-word)
   ("s-<right>" . forward-word)
   ("s-<up>"    . brust-smart-move-beginning-of-line)
   ("s-<down>"  . brust-smart-move-end-of-line)
   ;;  ("s-U" . backward-paragraph)
   ;;  ("s-I" . backward-page)
   ;;  ("s-O" . forward-paragraph)
   ;;  ;;("s-P" . )
   ;;  ;;("s-H" . )
   ;;  ("s-J" . sp-backward-sexp)
   ;;  ("s-K" . forward-page)
   ;;  ("s-L" . sp-forward-sexp)
   ;;  ("C-s-u" . backward-paragraph)
   ;;  ("C-s-i" . backward-page)
   ;;  ("C-s-o" . forward-paragraph)
   ;;  ;;("s-P" . )
   ;;  ;;("s-H" . )
   ;;  ("C-s-j" . sp-backward-sexp)
   ;;  ("C-s-k" . forward-page)
   ;;  ("C-s-l" . sp-forward-sexp)
   )

#+END_SRC

#+RESULTS:
: brust-smart-move-end-of-line

*** Outline
#+BEGIN_SRC elisp
  (bind-keys*
   ("s-J" . outline-hide-more)
   ("s-L" . outline-show-more)
   ("s-H" . outline-up-heading)                ; Up
   ("s-K" . outline-next-visible-heading)      ; Next
   ("s-I" . outline-previous-visible-heading)  ; Previous
   ("s-O" . outline-forward-same-level)        ; Forward - same level
   ("s-U" . outline-backward-same-level)      ; Backward - same level
   )
#+END_SRC

#+RESULTS:
: outline-backward-same-level

*** Delete
#+BEGIN_SRC elisp
  (bind-keys*
   ("s-f" . kill-word)
   ("s-d" . backward-kill-word))

#+END_SRC
** The build-in modes
*** Abbrev's
**** Setting
#+BEGIN_SRC elisp
  (setq pre-abbrev-expand-hook (quote (ignore))
        abbrev-file-name "~/Dropbox/config/abbrev-def.el"
        save-abbrevs 'silently)

  (setq-default abbrev-mode t)

  (quietly-read-abbrev-file)
#+END_SRC

#+RESULTS:

**** To use it as snippet
#+BEGIN_SRC elisp
(defun my-after-abbrev-expand nil
  (when (looking-back "\"\"\\|''\\|()\\|\\[\\]\\|{}")
    (backward-char 1))
  t)

(defun abbrev-possition-cursor nil
  (cdlatex-position-cursor)
  (my-after-abbrev-expand))

(put 'my-after-abbrev-expand  'no-self-insert t)
(put 'abbrev-possition-cursor 'no-self-insert t)

;;Examples of use: ("rr" "\\quetal{}" my-after-abbrev-expand 0)
#+END_SRC

**** Endless ispell & abbrev
     It comes from [[http://endlessparentheses.com/ispell-and-abbrev-the-perfect-auto-correct.html][Ispell and abbrev]], to find the misspelled work plain =ispell= is used, I adapted it to use =flyspell=, now I just get words which are underlined as misspelled (red curvi line under the word).
     That's useful in TeX files where plain ispell has many false misspellings, but it could be a problem on buffers without =flyspell= minormode.
#+BEGIN_SRC elisp
  (defun endless/simple-get-word ()
    (car-safe (save-excursion (ispell-get-word nil))))

  (defun endless/ispell-word-then-abbrev (p)
    "Call `ispell-word', then create an abbrev for it.
  With prefix P, create local abbrev. Otherwise it will
  be global.
  If there's nothing wrong with the word at point, keep
  looking for a typo until the beginning of buffer. You can
  skip typos you don't want to fix with `SPC', and you can
  abort completely with `C-g'."
    (interactive "P")

    (let ((top (window-start))
          (bot (window-end))
          (position (point))
          incorrect-word-pos
          position-at-incorrect-word
          bef aft)
      (save-excursion
        (save-restriction
          ;; make sure that word under point is checked first
          (forward-word)

          ;; narrow the region
          (narrow-to-region top bot)
          (overlay-recenter (point))

          (let ((overlay-list (overlays-in (point-min) (+ position 1)))
                (overlay 'dummy-value))

            (while overlay
              (setq overlay (car-safe overlay-list))
              (setq overlay-list (cdr-safe overlay-list))
              (when (and overlay
                         (flyspell-overlay-p overlay))
                (setq incorrect-word-pos (overlay-start overlay))

                ;; try to correct word
                (save-excursion
                  (goto-char incorrect-word-pos)
                  (setq bef (endless/simple-get-word))
                  ;; `flyspell-correct-at-point' returns t when there is
                  ;; nothing to correct. In such case we just skip current word.
                  (unless (flyspell-correct-at-point)
                    (setq overlay nil)
                    (setq aft (endless/simple-get-word)))))))))
      (if (and aft bef (not (equal aft bef)))
          (let ((aft (downcase aft))
                (bef (downcase bef)))
            (define-abbrev
              (if p local-abbrev-table global-abbrev-table)
              bef aft)
            (message "\"%s\" now expands to \"%s\" %sally"
                     bef aft (if p "loc" "glob")))
        (user-error "No typo at or before point"))))
#+END_SRC

#+RESULTS:
: endless/ispell-word-then-abbrev

*** Auto composition
    Disabled it, I never use it.
#+BEGIN_SRC elisp
(global-auto-composition-mode 0)
#+END_SRC

*** Auto revert
    I need this to work with Git and branching.
    Auto refresh all buffers when files have changed on disk.
#+BEGIN_SRC elisp
  (global-auto-revert-mode 1)
  (setq global-auto-revert-ignore-modes (quote (PDFView))
        auto-revert-check-vc-info t)
#+END_SRC

*** Backup and auto-save
    Backup files and auto-save files are two methods by which Emacs tries to protect the user from the consequences of crashes or of the user's own errors.
    Auto-saving preserves the text from earlier in the current editing session;
    backup files preserve file contents prior to the current session.
**** Backup's
     Files into backups and auto-save-list.
 #+BEGIN_SRC elisp
   (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
         delete-old-versions t
         version-control t
         kept-new-versions 6
         kept-old-versions 2
         vc-make-backup-files t)
 #+END_SRC

**** Auto save
 #+BEGIN_SRC elisp
   (setq auto-save-interval 100
         auto-save-timeout 5
         auto-save-file-name-transforms '((".*" "~/.emacs.d/backups/" t)))
 #+END_SRC

**** Is there directory?
     When I am intalling Emacs on a new computer ;)
#+BEGIN_SRC elisp
  (unless (file-exists-p "~/.emacs.d/backups/")
    (make-directory "~/.emacs.d/backups/"))
#+END_SRC

*** Bookmarks
#+BEGIN_SRC elisp
(setq bookmark-default-file "~/.emacs.d/backups/bookmarks"
      bookmark-save-flag 1) ;; autosave each change
#+END_SRC

*** COMMENT Desktop save
    Type =M-x desktop-clear= to empty the Emacs desktop.

#+BEGIN_SRC elisp
  (require 'desktop)
  (setq desktop-dirname "~/.emacs.d/backups/"
        desktop-path '("~/.emacs.d/backups/")
        desktop-base-file-name "emacs-desktop"
        desktop-save t
        ;; When desktop is not load from a file, always overwrite the file.
        desktop-file-modtime (nth 5 (file-attributes (concat desktop-dirname desktop-base-file-name)))
        ;; desktop-files-not-to-save   "^$" ;reload tramp paths
        ;; desktop-auto-save-timeout (* 10 60)
        desktop-load-locked-desktop t)

  ;; (add-hook 'after-init-hook #'desktop-read)
  ;; (add-hook 'kill-emacs-hook #'desktop-save-in-desktop-dir)
  (desktop-save-mode 1)
  ;; (run-with-timer 0 (* 30 60) #'desktop-save-in-desktop-dir)

  ;;  (defun desktop-save-in-desktop-dir (&optional release)
  ;;    "Save the desktop in directory `desktop-dirname'."
  ;;    (interactive)
  ;;    (if desktop-dirname
  ;;        (desktop-save desktop-dirname release)
  ;;      (call-interactively 'desktop-save))
  ;;    (message "Desktop saved in %s" (abbreviate-file-name desktop-dirname)))

  (cl-loop for mm in
           '(dired-mode Info-mode info-lookup-mode fundamental-mode)
           do (cl-pushnew mm desktop-modes-not-to-save))
#+END_SRC

*** Delete selection on type.

#+BEGIN_SRC elisp
(delete-selection-mode 1)
;; (setq delete-selection-save-to-register 'kill-ring)

#+END_SRC

*** Dired
     In Dired, visit this file or directory instead of the Dired buffer.
**** General setting

#+BEGIN_SRC elisp
  (require 'dired)

  (customize-set-variable 'diredp-hide-details-initially-flag nil)
  ;; (put 'dired-find-alternate-file 'disabled nil)
  (setq ls-lisp-dirs-first t
        ;; -F marks links with @
        dired-ls-F-marks-symlinks t
        delete-by-moving-to-trash t
        ;; Auto refresh dired
        global-auto-revert-non-file-buffers t
        wdired-allow-to-change-permissions t
        dired-listing-switches "-al --group-directories-first"
        ;; allow dired to delete or copy dir
        ;; “always” means no asking
        dired-recursive-copies 'always
        ;; “top” means ask once
        dired-recursive-deletes 'always
        ;; copy other frame
        dired-dwim-target t
        ;; dired-x-hands-off-my-keys t
        dired-hide-details-hide-information-lines t
        )

  (add-hook 'dired-mode-hook #'brust-dired-mode-hook)

  (bind-keys*
   ("C-x C-j" . dired-jump)) ;;auto-load function

  (use-package dired-x
    :ensure nil
    :init
    (setq-default dired-omit-files-p t
                  dired-omit-files "^\\.?#\\|^\\.$\\|^\\.\\.$\\|^\\.")
    :config
    (add-to-list 'dired-omit-extensions ".DS_Store"))

  (use-package dired-aux
    :ensure nil
    :init (use-package dired-async
            :ensure nil))

  ;; (use-package dired+)
#+END_SRC

#+RESULTS:
**** Hook function
#+BEGIN_SRC elisp
  (defun brust-dired-mode-hook nil
    (hl-line-mode 1)
    ;; (hydra-dired/body) ;; problems with it!!
    (toggle-truncate-lines 1)
    (dired-omit-mode 1)
    (dired-hide-details-mode 1)
    (bind-keys :map dired-mode-map
               ("i" . diredp-previous-line) ;; was dired-maybe-insert-subdir
               ("k" . diredp-next-line) ;; was dired-do-kill-lines
               ("M-o" . my/dired-open)
               ;; ("^" . brust-dired-to-upper-dir)
               ;; ("o" . dired-find-alternate-file)
               ("y" . hydra-dired/body))
    ;; (hydra-dired/body)
    )
#+END_SRC

#+RESULTS:
: brust-dired-mode-hook

**** Defuns
#+BEGIN_SRC elisp
    (defun ora-dired-up-directory nil
      (interactive)
      (let ((buffer (current-buffer)))
        (dired-up-directory)
        (unless (equal buffer (current-buffer))
          (kill-buffer buffer))))

  (with-current-buffer (current-buffer) (forward-word))
    (defun ora-ediff-files nil
      (interactive)
      (let ((files (dired-get-marked-files)))
        (if (= 2 (length files))
            (let ((file1 (car files))
                  (file2 (cadr files)))
              (if (file-newer-than-file-p file1 file2)
                  (ediff-files file2 file1)
                (ediff-files file1 file2)))
          (error "two files should be marked"))))

    (defun brust-dired-to-upper-dir nil
      (interactive)
      (let ((-marked-files (dired-get-marked-files nil t)))
        (dired-do-shell-command
         (format
          "mv ? %s" (file-name-directory (directory-file-name (dired-current-directory))))
         t
         -marked-files)))

    ;;    (dired-up-directory)
    ;;    (setq -marked-files
    ;;          (cl-loop for xx in -marked-files
    ;;                   append (file-name-nondirectory xx)))
    ;;    (dired-mark-if (lambda nil
    ;;                     (memq (dired-get-filename) -marked-files)))))
    ;;
#+END_SRC

#+RESULTS:
: brust-dired-to-upper-dir

*** Display time
    Not show the average of load times.
#+BEGIN_SRC elisp
(setq display-time-default-load-average nil)
(display-time-mode 1)
#+END_SRC
*** Ediff
   The default Ediff behavior is confusing and not desirable. This fixes it.
#+BEGIN_SRC elisp
(setq ediff-window-setup-function 'ediff-setup-windows-plain
      ediff-split-window-function 'split-window-horizontally)
#+END_SRC

   Make it compatible with =org-mode=
#+BEGIN_SRC elisp
(defun ora-ediff-prepare-buffer nil
  (when (memq major-mode '(org-mode emacs-lisp-mode))
    (outline-show-all)))

(add-hook 'ediff-prepare-buffer-hook 'ora-ediff-prepare-buffer)
#+END_SRC

#+BEGIN_SRC elisp
  (defun ediff-copy-both-to-C nil
    (interactive)
    (ediff-copy-diff
     ediff-current-difference nil 'C nil
     (concat
      (ediff-get-region-contents
       ediff-current-difference 'A ediff-control-buffer)
      (ediff-get-region-contents
       ediff-current-difference 'B ediff-control-buffer))))

  (defun add-d-to-ediff-mode-map nil
    (define-key ediff-mode-map "d" #'ediff-copy-both-to-C))

  (add-hook 'ediff-keymap-setup-hook #'add-d-to-ediff-mode-map)

#+END_SRC

*** Electric indent mode
    Now, I have aggressive indent insted.
#+BEGIN_SRC elisp
(add-hook 'after-change-major-mode-hook (lambda nil (electric-indent-mode -1)))
#+END_SRC

*** Elisp
#+BEGIN_SRC elisp
  (defun brust-elisp-sentence-end-double-sapce-t nil
    (mapc #'make-local-variable '(sentence-end-double-space sentence-end))
    (setq sentence-end nil
          sentence-end-double-space t))

  (add-hook 'emacs-lisp-mode-hook
            #'brust-elisp-sentence-end-double-sapce-t)
#+END_SRC

*** ESS (julia interaction)
**** COMMENT To install it
     - It need Emacs Speaks Statistics (ess)
 #+begin_src bash
 sudo apt install ess -y
 #+end_src
**** Load it
     - To be load before org-mode (we need this varibale setted to load ob-julia).
     - ob-julia.el does not work properly see [[https://stackoverflow.com/questions/52043705/emacs-org-babel-with-ob-julia-el-does-not-work-anymore-with-julia-v1-0][StackOverflow disscution]]
 #+begin_src elisp
   (require 'ess-site)
   (setq inferior-julia-program "~/scr/julia-1.2.0/bin/julia")
   (bind-keys :map ess-mode-map
              ("C-c C-c" . ess-eval-region-or-line-and-step)
              ("C <RET>" . ess-eval-region-or-function-or-paragraph-and-step))
   (setq comint-prompt-read-only nil
         ess-history-directory "~/.emacs.d/backups"
         ess-history-file ".julia_history")

   (add-hook 'comint-mode-hook #'brust-math-software-hookfun-to-intangify-prompt)
 #+end_src

 #+RESULTS:
 | brust-math-software-hookfun-to-intangify-prompt | brust-math-software-hookfun-to-intangify-promp |

**** Non-editable prompt
#+begin_src elisp
        (defvar brust-math-software-buffers-prompts
          '(("*julia*"    . "^julia>")
            ("*singular*" . "^>"))
          "List of cons with buffer names runing some math software and a regex for its promp string")

        (defun brust-math-software-intangify-buffer-text (-regexp beg end)
          "Set cursor-intangible property to all buffer text maching regular expresion `-regexp` between `beg` and  `end`"
          (save-excursion
            (goto-char beg)
            (save-match-data
              (while (re-search-forward -regexp end t)
                (add-text-properties (1- (match-beginning 0)) (match-end 0) '(cursor-intangible t rear-nonsticky nil))))))

        (defun brust-math-software-intangify-cursor-on-prompt (beg end length)
          "Set cursor-intangible in math software buffers prompts"
          (let ((-prompt (cdr (assoc (buffer-name) brust-math-software-buffers-prompts))))
            (when -prompt
              (brust-math-software-intangify-buffer-text -prompt beg end))))

        (defun brust-math-software-hookfun-to-intangify-prompt nil
          (cursor-intangible-mode 1)
          (add-hook 'after-change-functions #'brust-math-software-intangify-cursor-on-prompt nil t))
#+end_src

#+RESULTS:
: brust-math-software-hookfun-to-intangify-prompt

**** Turn on latexsubs

#+begin_src elisp
(defadvice ess-indent-or-complete (after julia-latexsubs activate)
  (unless (use-region-p)
    (call-interactively 'julia-latexsub-or-indent)))
#+end_src

#+RESULTS:
: ess-indent-or-complete

**** COMMENT Hook for comint in julia-mode
     I do not know how to retive the name of the directory from which julia have been called.
#+begin_src elisp
  (defun brust-julia-hook-setting-REPL nil
    "Handy hook for *julia*"
    (make-local-variable ess-history-directory)
    (setq ess-history-directory "~/Dropbox/Math/Leipzig2019/LocDim")
#+end_src

**** COMMENT System environment parameter.
#+begin_src elisp
  (setenv "JULIA_HISTORY"  ".julia_history")
  (setenv "JULIA_ANSWER_COLOR" "blue")
  (setenv "JULIA_NUM_THREADS" "3")
#+end_src

#+RESULTS:
: 3

**** COMMENT Non-editable prompt when comint-mode is used

[[file:/sudo:root@localhost:/usr/share/emacs/26.1/lisp/comint.el.gz::'(cursor-intangible%20t%20read-only%20t%20front-sticky%20(read-only)))))][File to edit]] (if it changes with some update)

'(cursor-intangible t read-only t front-sticky (read-only)))))

#+begin_src elisp
  ;; The purpose of using this filter for comint processes
  ;; is to keep comint-last-input-end from moving forward
  ;; when output is inserted.
  (eval-after-load 'comint
    '(defun comint-output-filter (process string)
      (let ((oprocbuf (process-buffer process)))
        ;; First check for killed buffer or no input.
        (when (and string oprocbuf (buffer-name oprocbuf))
          (with-current-buffer oprocbuf
            ;; Run preoutput filters
            (let ((functions comint-preoutput-filter-functions))
              (while (and functions string)
                (if (eq (car functions) t)
                    (let ((functions
                           (default-value 'comint-preoutput-filter-functions)))
                      (while (and functions string)
                        (setq string (funcall (car functions) string))
                        (setq functions (cdr functions))))
                  (setq string (funcall (car functions) string)))
                (setq functions (cdr functions))))

            ;; Insert STRING
            (let ((inhibit-read-only t)
                  ;; The point should float after any insertion we do.
                  (saved-point (copy-marker (point) t)))

              ;; We temporarily remove any buffer narrowing, in case the
              ;; process mark is outside of the restriction
              (save-restriction
                (widen)

                (goto-char (process-mark process))
                (set-marker comint-last-output-start (point))

                ;; Try to skip repeated prompts, which can occur as a result of
                ;; commands sent without inserting them in the buffer.
                (let ((bol (save-excursion (forward-line 0) (point)))) ;No fields.
                  (when (and (not (bolp))
                             (looking-back comint-prompt-regexp bol))
                    (let* ((prompt (buffer-substring bol (point)))
                           (prompt-re (concat "\\`" (regexp-quote prompt))))
                      (while (string-match prompt-re string)
                        (setq string (substring string (match-end 0)))))))
                (while (string-match (concat "\\(^" comint-prompt-regexp
                                             "\\)\\1+")
                                     string)
                  (setq string (replace-match "\\1" nil nil string)))

                ;; insert-before-markers is a bad thing. XXX
                ;; Luckily we don't have to use it any more, we use
                ;; window-point-insertion-type instead.
                (insert string)

                ;; Advance process-mark
                (set-marker (process-mark process) (point))

                (unless comint-inhibit-carriage-motion
                  ;; Interpret any carriage motion characters (newline, backspace)
                  (comint-carriage-motion comint-last-output-start (point)))

                ;; Run these hooks with point where the user had it.
                (goto-char saved-point)
                (run-hook-with-args 'comint-output-filter-functions string)
                (set-marker saved-point (point))

                (goto-char (process-mark process)) ; In case a filter moved it.

                (unless comint-use-prompt-regexp
                  (with-silent-modifications
                    (add-text-properties comint-last-output-start (point)
                                         '(front-sticky
                                           (field inhibit-line-move-field-capture)
                                           rear-nonsticky t
                                           field output
                                           inhibit-line-move-field-capture t))))

                ;; Highlight the prompt, where we define `prompt' to mean
                ;; the most recent output that doesn't end with a newline.
                (let ((prompt-start (save-excursion (forward-line 0) (point)))
                      (inhibit-read-only t))
                  (when comint-prompt-read-only
                    (with-silent-modifications
                      (or (= (point-min) prompt-start)
                          (get-text-property (1- prompt-start) 'read-only)
                          (put-text-property (1- prompt-start)
                                             prompt-start 'read-only 'fence))
                      (add-text-properties prompt-start (point)
                                           '(cursor-intangible t rear-nonsticky nil read-only t front-sticky (read-only)))))
                  (when comint-last-prompt
                    ;; There might be some keywords here waiting for
                    ;; fontification, so no `with-silent-modifications'.
                    (font-lock--remove-face-from-text-property
                     (car comint-last-prompt)
                     (cdr comint-last-prompt)
                     'font-lock-face
                     'comint-highlight-prompt))
                  (setq comint-last-prompt
                        (cons (copy-marker prompt-start) (point-marker)))
                  (font-lock-prepend-text-property prompt-start (point)
                                                   'font-lock-face
                                                   'comint-highlight-prompt)
                  (add-text-properties prompt-start (point) '(rear-nonsticky t)))
                (goto-char saved-point))))))))
#+end_src

*** Font lock.
#+BEGIN_SRC elisp
  (setq font-lock-support-mode 'jit-lock-mode)
  (setq font-lock-maximum-decoration t
        font-lock-maximum-size nil
        ;; fast-lock-cache-directories '("~/.emacs-flc")
        ;; jit-lock-stealth-time 16
        ;; jit-lock-defer-contextually t
        ;; jit-lock-stealth-nice 0.5
        )
  ;; (setq-default font-lock-multiline nil) ;; I do not know what it does, but it's a mess.
  ;; With it set to 't' font-lock-support-mode 'jit-lock-mode does _not_ works!
  ;;  we need set it to nil and fontify the whole buffer at start, slowing down a lot open files
  ;; (Now every thing is normal again :)
  (global-font-lock-mode t)
#+END_SRC

#+RESULTS:
: t

*** COMMENT Hippie Expand
#+BEGIN_SRC elisp
  (setq hippie-expand-try-functions-list
        '(try-complete-file-name-partially
          try-complete-file-name
          pcomplete
          try-expand-all-abbrevs
          ;; try-expand-list
          try-expand-dabbrev
          ;; try-expand-by-dict
          ))
#+END_SRC

#+RESULTS:
| try-complete-file-name-partially | try-complete-file-name | pcomplete | try-expand-all-abbrevs | try-expand-dabbrev |

*** Info mode
  Add some browser styled nav keys for `Info-mode'.
  The following keys are added:
  【Backspace】 for `help-go-back'
  【Shift+Backspace】 for `help-go-forward'.
#+BEGIN_SRC elisp
  (define-key help-mode-map (kbd "<s-backspace>") #'help-go-forward)
  (define-key help-mode-map (kbd "<backspace>") #'help-go-back)

  ;;(add-hook 'Info-mode-hook 'add-browser-backspace-key-to-Info-mode)
#+END_SRC

#+RESULTS:
: Info-history-back

*** Search
**** Setting
#+BEGIN_SRC elisp
  (setq isearch-allow-scroll t)

  (bind-keys :map isearch-mode-map
             ("<backspace>" . isearch-delete-something)
             ;; Set arrow keys in isearch. left/right is backward/forward, up/down is history. Press Return to exit. (From Xah-Lee)
             ("<up>"    . isearch-ring-retreat)
             ("<down>"  . isearch-ring-advance)
             ("<left>"  . isearch-repeat-backward) ; single key, useful
             ("<right>" . isearch-repeat-forward)) ; single key, useful
  (bind-keys :map minibuffer-local-isearch-map
             ("<right>" . isearch-forward-exit-minibuffer) ; single key, useful
             ("<left>"  . isearch-reverse-exit-minibuffer))

#+END_SRC

**** Finish at the start
    Isearch is a useful navigation mechanism. For me, it works a little
    better if isearch puts you at the start of the search, not the end:
#+BEGIN_SRC elisp
  (add-hook 'isearch-mode-end-hook 'my-goto-match-beginning)

  (defun my-goto-match-beginning nil
    (when (and isearch-forward isearch-other-end)
      (goto-char isearch-other-end)))

  ;; (when isearch-forward (goto-char isearch-other-end))
#+END_SRC
**** Improve backspace
     New improved funtion of backspace in isearch mode.
     It doesn't require binding.
#+BEGIN_SRC elisp
(defun isearch-delete-something nil
  "Delete non-matching text or the last character."
  ;; Mostly copied from `isearch-del-char' and Drew's answer on the page above
  (interactive)
  (if (= 0 (length isearch-string))
      (ding)
    (setq isearch-string
          (substring isearch-string
                     0
                     (or (isearch-fail-pos) (1- (length isearch-string)))))
    (setq isearch-message
          (mapconcat #'isearch-text-char-description isearch-string "")))
  (if isearch-other-end (goto-char isearch-other-end))
  (isearch-search)
  (isearch-push-state)
  (isearch-update))
#+END_SRC

#+RESULTS:
: isearch-delete-something
*** Line and column numbers
    Show line and column numbers just in the =mode-line=
#+BEGIN_SRC elisp
(global-linum-mode 0)
(setq-default line-number-mode t
              column-number-mode t)
#+END_SRC

#+RESULTS:
: t

*** Org mode
**** Main congif
 #+BEGIN_SRC elisp
   (use-package org
     :ensure nil
     :init
           ;;; To make compatible org-scr-tab-acts-natively with yasnipets
     ;;    (defun yas/org-very-safe-expand nil
     ;;     (let ((yas/fallback-behavior 'return-nil)) (yas/expand)))
     ;;   (add-hook 'org-mode-hook
     ;;             (lambda nil
     ;;               (yas-global-mode 1)
     ;;               (make-variable-buffer-local 'yas-trigger-key)
     ;;               (setq yas-trigger-key [tab])
     ;;               (add-to-list 'org-tab-first-hook 'yas/org-very-safe-expand)
     ;;               (define-key yas-keymap [tab] 'yas-next-field)))
           ;;;;;;;;;;;;;;;;;
     (setq org-src-window-setup (quote other-window)
           ;; When t, ‘C-a’ will bring back the cursor to the beginning of the
           ;; headline text
           org-special-ctrl-a/e t
           org-use-speed-commands t
           org-cycle-global-at-bob t
           org-startup-folded t
           org-hide-emphasis-markers t
           ;;org-ellipsis " ▼"
           ;;org-completion-use-ido t
           org-outline-path-complete-in-steps nil
           org-src-fontify-natively t   ;; Pretty code blocks
           ;; org-src-tab-acts-natively t
           org-src-ask-before-returning-to-edit-buffer nil
           org-edit-src-auto-save-idle-delay 20
           org-confirm-babel-evaluate nil
           org-todo-keywords '((sequence "TODO(t)" "DOING(g)" "|" "DONE(d)")
                               (sequence "|" "CANCELED(c)"))
           org-return-follows-link 1
           org-link-frame-setup (quote ((file . find-file)))
           org-agenda-todo-list-sublevels nil
           org-deadline-warning-days 3
           org-agenda-skip-scheduled-if-done 1
           org-agenda-skip-deadline-if-done 1
           org-agenda-skip-deadline-if-done 1)

     (add-hook 'org-babel-after-execute-hook 'org-display-inline-images)
     (add-hook 'org-mode-hook 'org-display-inline-images)

     ;; org-mode my agenda view
     (setq org-agenda-files (quote ("~/Dropbox/Org/" "~/Dropbox/bibliography/notes.org"))
           org-directory "~/Dropbox/Org/"
           org-agenda-custom-commands
           '(("h" "My agenda view"
              ((agenda "")
               (todo)))))
     :config
     ;; Org speed keys
     (cl-loop for new-key in
              `(,(cons "P" 'org-set-property)
                ,(cons "d" 'org-deadline)
                ,(cons "h" 'outline-up-heading)
                ,(cons "k" (lambda nil "Next visible"
                             (org-speed-move-safe 'org-next-visible-heading)))
                ,(cons "i" (lambda nil "Previous visible"
                             (org-speed-move-safe 'org-previous-visible-heading)))
                ,(cons "l" (lambda nil "Forward same level"
                             (org-speed-move-safe 'org-forward-heading-same-level)))
                ,(cons "o" (lambda nil "Backward same level"
                             (org-speed-move-safe 'org-backward-heading-same-level)))
                ,(cons "n" (lambda nil "Insert -n-ew header below"
                             (forward-char 1)
                             (call-interactively
                              '(org-insert-heading-respect-content))))
                ,(cons "ñ" 'interleave-mode) ;; Start interleave mode
                ,(cons "m" 'org-mark-subtree)   ;; Mark a subtree
                ,(cons "S" 'widen)   ;; Widen
                ,(cons "K" (lambda ()   ;; kill a subtree
                             (org-mark-subtree)
                             (kill-region
                              (region-beginning)
                              (region-end))))
                ,(cons "q" (lambda ()   ;; Jump to headline
                             (avy-with avy-goto-line
                               (avy--generic-jump "^\\*+" nil avy-style)))))
              do (push new-key org-speed-commands-user))
     ;; Org babel
     (org-babel-do-load-languages 'org-babel-load-languages
                                  '(
                                    ;; (R . t)
                                    ;; (Singular . t) ;; it doesn't exits https://orgmode.org/manual/Languages.html#Languages
                                    ;; (gnuplot . t)
                                    (latex . t)
                                    ;; (org . t)
                                    ;; (sh . t)
                                    ;; (lisp . t)
                                    (shell . t)
                                    (julia . t) ;; see https://stackoverflow.com/questions/52043705/emacs-org-babel-with-ob-julia-el-does-not-work-anymore-with-julia-v1-0
                                    ))

     (font-lock-add-keywords            ;; A bit silly but my headers are now
      'org-mode                         ;; shorter, and that is nice canceled
      (mapcar (lambda (xx)
                `(,(concat "^\\*+ +\\(\\|COMMENT +\\)\\(" (car xx) "\\)")
                  (2 (progn (compose-region (match-beginning 2) (match-end 2) ,(cdr xx))
                            nil))))
              '(("TODO"       . "⚑")
                ("DOING"      . "⚐")
                ("CANCELED"   . "✘")
                ("DONE"       . "✔"))))
     :bind
     ;; ("C-c l" . org-store-link)
     ;; ("C-c c" . org-capture)
     ("C-c a" . org-agenda)
     ("C-c b" . org-iswitchb)
     (:map org-mode-map
           ("s-b" . org-text-bold)
           ("s-v" . org-text-italics)
           ("s-c" . org-text-code)
           ("<" . brust-org<)))
 #+END_SRC

 #+RESULTS:
**** Org bullets
      Use org-bullets-mode for utf8 symbols as org bullets
 #+BEGIN_SRC elisp
   (use-package org-bullets
     :after org
     ;; make available "org-bullet-face" such that I can control the font size individually
     :init
     (add-hook 'org-mode-hook (lambda nil (org-bullets-mode 1)))
     (setq org-bullets-bullet-list '("✙" "✟" "†" "☥" "✣" "✛" "♰" "♱" "✞" "✥" "✝" "✠" "✚" "✜"  "✢" "✤" )))
 #+END_SRC

 #+RESULTS:
**** Org capture
 #+BEGIN_SRC elisp
   (use-package org-capture
     :ensure nil
     :after org
     :preface
     (defvar my/org-ledger-card-template
       "%(org-read-date) %^{Payee}
       Expenses:%^{Account}  €%^{Amount}
       Liabilities:DebidCard:Mediolanum"
       "Template for devid card transaction with ledger.")

     (defvar my/org-ledger-cash-template
       "%(org-read-date) * %^{Payee}
       Expenses:%^{Account}  €%^{Amount}
       Assets:Cash:Wallet"
       "Template for cash transaction with ledger.")
     :custom
     (org-capture-templates
      `(("l" "Ledger")
        ("lb" "Bank" plain (file ,(format "~/Dropbox/Org/ledger-%s.dat" (format-time-string "%Y"))),
         my/org-ledger-card-template
         :empty-lines 1
         :immediate-finish t)
        ("lc" "Cash" plain (file ,(format "~/Dropbox/Org/ledger-%s.dat" (format-time-string "%Y"))),
         my/org-ledger-cash-template
         :empty-lines 1
         :immediate-finish t)
        ("o"
         "TODO respond to email"
         entry
         (file YOUR_TODO_FILE.org)
         "* TODO %^{Description}\n%A\n%?\n"))))
 #+END_SRC

 #+RESULTS:

*** Outline mode
    Set symbol and face for ellipsis, from http://emacs.stackexchange.com/questions/17806/set-face-of-outline-ellipsis
#+BEGIN_SRC elisp
  (defun brust-outline-mode-set-ellipsis nil
    (let ((display-table
           (if buffer-display-table
               buffer-display-table
             (make-display-table))))
      (unless buffer-display-table
        (setq buffer-display-table display-table))
      (set-display-table-slot display-table 4
                              (vconcat (mapcar (lambda (c)
                                                 (make-glyph-code c 'mode-line-top-line-number)) " ↴")))))


  (add-hook 'outline-mode-hook #'brust-outline-mode-set-ellipsis)
  (add-hook 'outline-minor-mode-hook #'brust-outline-mode-set-ellipsis)
#+END_SRC

#+RESULTS:
| brust-outline-mode-set-ellipsis |

*** Save cursor position
#+BEGIN_SRC elisp
  (save-place-mode 1)
  (setq-default save-place t)
  (setq save-place-file "~/.emacs.d/backups/saved-places")
#+END_SRC
*** Save history
    Save kill ring, regexp-search-ring
#+BEGIN_SRC elisp
  (require 'savehist)
  (setq history-length 100
        desktop-load-locked-desktop t
        history-delete-duplicates t
        savehist-autosave-interval 60
        savehist-save-minibuffer-history t
        savehist-ignored-variables
        '(bookmark-history
          bibtex-key-history
          counsel-describe-symbol-history
          TeX-command-history
          file-name-history
          minibuffer-history)
        savehist-additional-variables
        '(kill-ring
          search-ring
          ;; global-mark-ring
          regexp-history
          regexp-search-ring
          ;; buffer-name-history
          ;; minibuffer-history
          query-replace-history
          read-expression-history
          ;; input-method-history
          extended-command-history
          shell-command-history
          ;; file-name-history
          ;; org-mark-ring
          ;; org-tags-history
          ;; kmacro-ring
          ;; counsel-colors-emacs-history
          ;; counsel-colors-web-history
          ;; counsel-descbinds-history
          ;; counsel-describe-symbol-history
          ;; counsel-faces-history
          ;; counsel-git-grep-cmd-history
          counsel-git-grep-history
          counsel-locate-history
          counsel-org-agenda-headlines-history
          ;; counsel-rhythmbox-history
          ;; counsel-set-variable-history
          ;; counsel-unicode-char-history
          ivy-history
          occur-collect-regexp-history
          swiper-history
          dired-regexp-history
          dired-shell-command-history
          ;; Info-history
          Info-search-history
          ;; pdf-occur-history
          )
        savehist-file "~/.emacs.d/backups/history")
  (savehist-mode 1)
#+END_SRC

#+RESULTS:
: t

*** Server
#+BEGIN_SRC elisp
  (require 'server)
  (unless (server-running-p) (server-start))

;; see delete keys new generic functions -> kill buffer.

;; ;; To kill a server buffer with the usual key
;; (add-hook 'server-switch-hook
;;           (lambda nil
;;             (when (current-local-map)
;;               (use-local-map (copy-keymap (current-local-map))))
;;             (when server-buffer-clients
;;               (local-set-key (kbd "C-x k") 'server-edit))))
;;
#+END_SRC
*** Shift select
    When non-nil, shifted motion keys activate the mark momentarily.
    Time ago I used to use it, now I am an Emacs rock!
    (In this way I have more bindings =s-S-*=)
#+BEGIN_SRC elisp
(setq shift-select-mode nil)
#+END_SRC

*** Zap (up) to char
#+BEGIN_SRC elisp
(autoload 'zap-up-to-char "misc"
  "Kill up to, but not including ARGth occurrence of CHAR.")
(global-set-key (kbd "M-z") #'zap-up-to-char)
(global-set-key (kbd "M-Z") #'zap-to-char)

#+END_SRC
** New generic functions
*** Beginning<->end of a buffer
#+BEGIN_SRC elisp
  (defun brust-toggle-begin&end-of-buffer nil
    "Go to beginning of buffer or toggle between
  the beginning and end of current buffer is you are already there."
    (interactive)
    (if (bobp) (goto-char (point-max))
      (unless (eobp) (push-mark (point)))
      (goto-char (point-min))))
#+END_SRC

#+RESULTS:
: brust-toggle-begin&end-of-buffer
*** Add blank pages to a pdf
#+BEGIN_SRC elisp
  (defun brust-pdf-add-blank-pages (-file init-page)
    (interactive
     (list  (read-file-name "Pdf to modify: ")
            (read-number "Page to start adding blank pages: ")))
    (let (-num -page (i init-page) -commstr)
      (with-temp-buffer
        (insert (shell-command-to-string (format "pdftk %s dump_data" -file)))
        (goto-char (point-min))
        (re-search-forward "NumberOfPages: \\([0-9]+\\)$" nil t)
        (setq -num (- (string-to-number (match-string 1)) i))
        (setq -page
              (if (re-search-forward "PageMediaDimensions: \\([0-9]+\\) \\([0-9]+\\)$" nil t)
                  (concat (match-string 1) "x" (match-string 2))
                "a4")))
      (setq -commstr
            (concat (format "A1-%d " i)
                    (cl-loop repeat -num
                             concat (format "B1 A%d " (setq i (1+ i))))))
      (let ((-blanche (concat (file-name-directory -file) "pageblanche.pdf"))
            (-mod (concat (file-name-directory -file) "mod_" (file-name-base -file) ".pdf"))
            (-out (concat (file-name-directory -file) "print_" (file-name-base -file) ".pdf")))
        (shell-command (format "convert xc:none -page %s %s" -page -blanche))
        (shell-command (format "pdftk A=%s B=%s cat %s output %s" -file -blanche -commstr -mod))
        (shell-command (format "rm %s" -blanche)))))
  ;; (shell-command (format "pdfnup %s --nup 2x1 --landscape --outfile %s" -mod -out))
  ;; (shell-command (format "rm %s && rm %s" -mod -blanche)))))
#+END_SRC

#+RESULTS:
: brust-pdf-add-blank-pages

*** COMMENT PDF From MR to pdf
commands to work with MangaRock comics
#+BEGIN_SRC bash
  cd "~/Dropbox/files/26897765-1546816941953/"
  parallel convert '{} {.}.pdf' ::: * && pdftk `ls | grep "pdf" | sort -n` cat output Vol-2.pdf
#+END_SRC

#+RESULTS:

*** Bounded min/maximum
#+BEGIN_SRC elisp
  (defun list-util-bounded-max (nums bound)
     "Return the maximum of the list 'nums' that is under 'bound'"
     (cl-loop for n in nums
           when (< n bound) maximizing n into maximum
           finally return maximum))
#+END_SRC

#+BEGIN_SRC elisp
  (defun list-util-bounded-min (nums bound)
    "Return the minimum of the list 'nums' greater than 'bound'"
    (cl-loop for n in nums
          when (< bound n) minimizing n into minimum
          finally return minimum))
#+END_SRC

*** Binary navigaton
    They are from [[https://github.com/mgrachten/bln-mode][Binary line navigation]]. But come on, a minor mode just adding two functions?
    I've changed the code drastically.

#+BEGIN_SRC elisp
  (defvar bln-beg-end '(-1 . -1))
  (defvar bln-functions-list '(bln-backward-half
                               bln-forward-half))
  (defvar bln-beg-end-v '(-1 . -1))
  (defvar bln-functions-list-v '(bln-backward-half-v
                                 bln-forward-half-v))
  (defvar bln-column-v -1)

  ;;;###autoload
  (defun bln-backward-half ()
    "This function is used in combination with `bln-forward-half' to provide binary line navigation (see `bln-mode')."
    (interactive)
    (setq bln-beg-end
          (if (member last-command bln-functions-list)
              `(,(car bln-beg-end) . ,(point))
            `(,(save-excursion
                 (beginning-of-visual-line)
                 (point))
              . ,(point))))
    (goto-char (/ (+ (car bln-beg-end) (cdr bln-beg-end)) 2)))

  ;;;###autoload
  (defun bln-forward-half ()
    "This function is used in combination with `bln-backward-half' to provide binary line navigation (see `bln-mode')."
    (interactive)
    (setq bln-beg-end
          (if (member last-command bln-functions-list)
              ;; (/= (point) bln-prev-point))
              `(,(point) . ,(cdr bln-beg-end))
            `(,(point) . ,(save-excursion
                            (end-of-visual-line)
                            (1+ (point))))))
    (goto-char (/ (+ (car bln-beg-end) (cdr bln-beg-end)) 2)))

  (defun bln--visual-line-borders (-which)
    "When `which' is t (resp. nil), returns the position at the beginning (resp. end) of the current visual line."
    (save-excursion
      (if which
          (beginning-of-visual-line)
        (end-of-visual-line))
      (point)))

  (defun bln--window-visual-lines nil
    (let ((p0 (point))
          (i 1)
          (j 1))
      (save-excursion
        (goto-char (window-start))
        (while (< (point) p0)
          (forward-line 1)
          (setq i (1+ i)))
        (setq j i)
        (while (< (point) (window-end))
          (forward-line 1)
          (setq j (1+ j))))
      (cons i j)))



  ;;;###autoload
  (defun bln-backward-half-v ()
    "This function is used in combination with `bln-forward-half' to provide binary line navigation (see `bln-mode')."
    (interactive)
    (if (member last-command bln-functions-list-v)
        (setq bln-beg-end-v
              `(,(car bln-beg-end-v) . ,(line-number-at-pos (point))))
      (setq bln-beg-end-v
            `(,(line-number-at-pos (window-start)) . ,(line-number-at-pos (point)))
            bln-column-v (- (point) (line-beginning-position))))
    (forward-line (/ (- (car bln-beg-end-v) (cdr bln-beg-end-v)) 2))
    (if (< bln-column-v (- (line-end-position) (line-beginning-position)))
        (forward-char bln-column-v)
      (move-end-of-line 1)))

  ;;;###autoload
  (defun bln-forward-half-v ()
    "This function is used in combination with `bln-backward-half' to provide binary line navigation (see `bln-mode')."
    (interactive)
    (if (member last-command bln-functions-list-v)
        (setq bln-beg-end-v
              `(,(line-number-at-pos (point)) . ,(cdr bln-beg-end-v)))
      (setq bln-beg-end-v
            `(,(line-number-at-pos (point)) . ,(line-number-at-pos (window-end)))
            bln-column-v (- (point) (line-beginning-position))))
    (forward-line (/ (- (cdr bln-beg-end-v) (car bln-beg-end-v)) 2))
    (if (< bln-column-v (- (line-end-position) (line-beginning-position)))
        (forward-char bln-column-v)
      (move-end-of-line 1)))
#+END_SRC

#+RESULTS:
: bln-forward-half-v

*** Close<->open parents
**** Parenthesis syntax.
#+BEGIN_SRC elisp
  (defconst all-paren-syntax-table
     (let ((table (make-syntax-table)))
       (modify-syntax-entry ?{  "(}" table)
       (modify-syntax-entry ?}  "){" table)
       (modify-syntax-entry ?\( "()" table)
       (modify-syntax-entry ?\) ")(" table)
       (modify-syntax-entry ?\[ "(]" table)
       (modify-syntax-entry ?\] ")[" table)
       (modify-syntax-entry ?\\ "'"  table)
       ;; (modify-syntax-entry ?\< "(>" table)
       ;; (modify-syntax-entry ?\> ")<" table)
       table)
     "A syntax table giving all parenthesis parenthesis syntax.")
#+END_SRC

**** Generic function
#+BEGIN_SRC elisp
  (defun close-quoted-open-paren (args dir)
      "dir=0 -> right, dir=1 -> left"
      (with-syntax-table all-paren-syntax-table
        (cl-loop repeat args do
                 (let* ((i dir)
                        (pos (save-excursion (up-list (1- (* 2 dir))) (point)))
                        (closing (matching-paren (char-after (- pos dir)))))
                   (while (eq (char-before (- pos i)) ?\\)
                     (setq i (1+ i)))
                   (cl-loop repeat (- i dir) do (insert "\\"))
                   (insert closing)
                   (backward-char (* dir i)))))
                   t)
#+END_SRC

**** By right
#+BEGIN_SRC elisp
  (defun close-quoted-open-paren-right (&optional args)
    (interactive "P")
    (close-quoted-open-paren (if (numberp args) args 1) 0))

  (defun close-all-open-paren-right nil
    (interactive)
    (while (ignore-errors (close-quoted-open-paren-right))))

#+END_SRC
**** By left
#+BEGIN_SRC elisp
  (defun close-quoted-open-paren-left (&optional args)
    (interactive "P")
    (close-quoted-open-paren (if (numberp args) args 1) 1))

  (defun close-all-open-paren-left nil
    (interactive)
    (while (ignore-errors (close-quoted-open-paren-left))))
#+END_SRC
**** By right or left
#+BEGIN_SRC elisp
  (defun my-texmathp nil
    (interactive)
    (when (texmathp)
      (let ((pnt (point))
            (p (ignore-errors
                 (goto-char (cdr texmathp-why))
                 (sp-forward-sexp 1))))
        (goto-char pnt)
        p)))

  (defun close-quoted-open-paren-right-or-left (&optional args)
    (interactive "P")
    (or args (setq args 1))
    (cl-loop repeat args do
             (if (and (fboundp 'texmathp)
                      (my-texmathp))
                 (unless (and (ignore-errors (close-quoted-open-paren-right))
                              (if (my-texmathp) t (delete-char -2) nil))
                   (unless (and (ignore-errors (close-quoted-open-paren-left))
                                (if (my-texmathp) t (delete-char 2) nil))))
               (unless (ignore-errors (close-quoted-open-paren-right))
                 (unless (ignore-errors (close-quoted-open-paren-left)))))))
#+END_SRC

#+RESULTS:
: close-quoted-open-paren-right-or-left

**** COMMENT New paren
#+BEGIN_SRC elisp

    (defvar brust-open-paren-last 1 "Number corresponding to last inserted paren by `brust-open-paren-alist'")

    (defvar brust-open-paren-alist '((1 . "(")
                                     (2 . "[")
                                     (3 . "{")
                                     (4 . "<"))
      "List with open paren to cycle through")

    (defun brust-open-paren-insert (-paren)
      (insert (cdr (assoc (setq brust-last-open-paren -paren)
                          brust-open-paren-alist))))

    (defun brust-open-paren-cycle (&optional args)
      (interactive "P")
      (if (string= (cdr (assoc brust-last-open-paren
                               brust-open-paren-alist))
                   (buffer-substring-no-properties (1- (point)) (point)))
          (delete-char -1)
        (setq brust-open-paren-last 0))
      (brust-open-paren-insert
       (setq brust-open-paren-last
             (if (< brust-open-paren-last (length brust-open-paren-alist))
                 (1+ brust-open-paren-last)
               1))))

    (defun brust-open-paren-add-more nil
      "Copy previous char"
      (interactive)
      (insert (buffer-substring-no-properties (1- (point)) (point))))

    (defun brust-open-paren-insert-backslash nil
      "Insert backslash before previous char"
      (interactive)
      (save-excursion
        (forward-char -1)
        (insert "\\")))

  (defun brust-open-paren-leave-just-backslash nil
    (interactive)
    (delete-char -1)
    (insert "\\"))

  (defun brust-open-paren-ordered-string-of-options nil
    (cl-loop for xx in brust-open-paren-alist
             concat (cdr xx)))

  (defhydra brust-open-paren-hydra nil
    "

    ^ Open paren %(brust-open-paren-ordered-string-of-options): "
    ("SPC" (brust-open-paren-cycle) "Cycle")
    ("a" (brust-open-paren-add-more) "Add another")
    ("b" (brust-open-paren-insert-backslash) "Add backslash")
    ("q" (brust-open-paren-leave-just-backslash) "Just backslash"))
#+END_SRC

#+RESULTS:
: brust-open-paren-hydra/body

*** Copy file path to kill ring (by Xah Lee)
**** Copy file path
#+BEGIN_SRC elisp
(defun xah-copy-file-path (&optional φdir-path-only-p)
  "Copy the current buffer's file path or dired path to `kill-ring'.
Result is full path.
If `universal-argument' is called first, copy only the dir path.
URL `http://ergoemacs.org/emacs/emacs_copy_file_path.html'
Version 2015-12-02"
  (interactive "P")
  (let ((ξfpath
         (if (equal major-mode 'dired-mode)
             (expand-file-name default-directory)
           (if (null (buffer-file-name))
               (user-error "Current buffer is not associated with a file.")
             (buffer-file-name)))))
    (kill-new
     (if (null φdir-path-only-p)
         (progn
           (message "File path copied: 「%s」" ξfpath)
           ξfpath
           )
       (progn
         (message "Directory path copied: 「%s」" (file-name-directory ξfpath))
         (file-name-directory ξfpath))))))
#+END_SRC

**** Copy directory path
#+BEGIN_SRC elisp
  (defun brust-copy-directory-only nil
    (interactive)
    (xah-copy-file-path t))
#+END_SRC
*** Customize face at point
    A handy function for customization
#+BEGIN_SRC elisp
  (defun customize-face-at-point nil
    "Customize face which point is at."
    (interactive)
    (let ((face (get-text-property (point) 'face)))
      (if face
          (customize-face face)
        (message "No face defined at point"))))

#+END_SRC
*** Change font size
#+begin_src elisp
  (defun zoom-in ()
    (interactive)
    (set-face-attribute 'default nil :height (+ (face-attribute 'default :height) 10)))

  (defun zoom-out ()
    (interactive)
    (set-face-attribute 'default nil :height (- (face-attribute 'default :height) 10)))

  (define-key global-map (kbd "C-2") 'zoom-in)
  (define-key global-map (kbd "C-1") 'zoom-out)
#+end_src

#+RESULTS:
: zoom-out

*** Delete indentation "reversed"
#+BEGIN_SRC elisp
  (defun brust-delete-indentation (args)
    (interactive "P")
    (delete-indentation (not args)))
#+END_SRC

#+RESULTS:
: brust-delete-indentation

*** Double Capitals
    Convert words in DOuble CApitals to Single Capitals.
    [[https://emacs.stackexchange.com/questions/13970/fixing-double-capitals-as-i-type][From StackExange]]

**** The function
#+BEGIN_SRC elisp
(defun dcaps-to-scaps nil
  "Convert word in DOuble CApitals to Single Capitals."
  (interactive)
  (and (= ?w (char-syntax (char-before)))
       (save-excursion
         (and (if (called-interactively-p)
                  (skip-syntax-backward "w")
                (= -3 (skip-syntax-backward "w")))
              (let (case-fold-search)
                (looking-at "\\b[[:upper:]]\\{2\\}[[:lower:]]"))
              (capitalize-word 1)))))

#+END_SRC
**** New minor mode
#+BEGIN_SRC elisp
(define-minor-mode dubcaps-mode
  "Toggle `dubcaps-mode'.  Converts words in DOuble CApitals to
Single Capitals as you type."
  :init-value nil
  :lighter ("") ;; String to show in mode-line
  (if dubcaps-mode
      (add-hook 'post-self-insert-hook #'dcaps-to-scaps nil 'local)
    (remove-hook 'post-self-insert-hook #'dcaps-to-scaps 'local)))


#+END_SRC
**** Activation
#+BEGIN_SRC elisp
(add-hook 'text-mode-hook #'dubcaps-mode)

#+END_SRC
*** Emacs info recoder
    http://manuel-uberti.github.io//emacs/2018/05/25/display-version/

#+BEGIN_SRC elisp
(defun mu--os-version ()
  "Call `lsb_release' to retrieve OS version."
  (replace-regexp-in-string
   "Description:\\|[\t\n\r]+" ""
   (shell-command-to-string "lsb_release -d")))

(defun mu--gnome-version ()
  "Call `gnome-shell' to retrieve GNOME version."
  (replace-regexp-in-string
   "[\t\n\r]+" ""
   (shell-command-to-string "gnome-shell --version")))

;;;###autoload
(defun mu-display-version ()
  "Display Emacs version and system details in a temporary buffer."
  (interactive)
  (let ((buffer-name "*version*"))
    (with-help-window buffer-name
      (with-current-buffer buffer-name
        (insert (emacs-version) "\n")
        (when emacs-repository-version
          (insert "\nRepository revision: " emacs-repository-version "\n"))
        (when (and system-configuration-options
                   (not (equal system-configuration-options "")))
          (insert "\nConfigured using:\n"
                  system-configuration-options))
        (insert "\n\nOperating system: " (mu--os-version) "\n")
        (insert "Window system: " (getenv "XDG_SESSION_TYPE") "\n")
        (insert "Desktop environment: " (mu--gnome-version))))))
#+END_SRC

*** Find file sudo
#+BEGIN_SRC elisp
  (defadvice find-file (after find-file-sudo activate)
    "Find file as root if necessary."
    (when (and
           buffer-file-name
           (not (file-writable-p buffer-file-name))
           ;; (called-interactively-p "any")
           (y-or-n-p "File not writable. Open it as root?"))
      (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name))))

#+END_SRC

#+RESULTS:
: find-file

*** Kill buffer
#+BEGIN_SRC elisp
  (defun brust-kill-buffer-delete-window (arg)
    (interactive "P")
    (when arg (save-buffer))
    (when (if (not server-buffer-clients)
              (kill-buffer)
            (server-edit) t)
      (delete-window)))

  (defun brust-kill-buffer (arg)
    (interactive "P")
    (when arg (save-buffer))
    (if server-buffer-clients
        (server-edit)
      (kill-buffer)))

  (bind-key "<C-delete>" #'brust-kill-buffer-delete-window)
  (bind-key* "<delete>" #'brust-kill-buffer)
#+END_SRC

#+RESULTS:
: brust-kill-buffer

*** Macro query
#+BEGIN_SRC elisp
(defun kmacro-query-my (arg)
  "Prompt for input using minibuffer during kbd macro execution.
   With prefix argument, allows you to select what prompt string to use.
   If the input is non-empty, it is inserted at point."
  (interactive "P")
  (let* ((prompt (if arg (read-from-minibuffer "PROMPT: ") "Input: "))
         (input (minibuffer-with-setup-hook (lambda nil (kbd-macro-query t))
                  (read-from-minibuffer prompt))))
    (unless (string= "" input) (insert input))))


#+END_SRC

#+RESULTS:
: kmacro-query-my

*** Narrow or widen dwin
 There's a nice helper from [[http://endlessparentheses.com/emacs-narrow-or-widen-dwim.html][Endless Parentheses]] that defines a do-what-I-mean version
 of the narrow-or-widen so I don't have to keep remembering which is which.
#+BEGIN_SRC elisp
  (defun endless/narrow-or-widen-dwim (p)
    "Widen if buffer is narrowed, narrow-dwim otherwise.
  Dwim means: region, org-src-block, org-subtree, or
  defun, whichever applies first. Narrowing to
  org-src-block actually calls `org-edit-src-code'.

  With prefix P, don't widen, just narrow even if buffer
  is already narrowed."
    (interactive "P")
    (declare (interactive-only))
    (cond ((and (buffer-narrowed-p)
                (not p))
           (widen)
           (let ((recenter-redisplay t))
             (recenter nil)))
          ((region-active-p)
           (narrow-to-region (region-beginning)
                             (region-end))
           (deactivate-mark)
           (goto-char (point-min)))
          ((derived-mode-p 'org-mode)
           ;; `org-edit-src-code' is not a real narrowing
           ;; command. Remove this first conditional if
           ;; you don't want it.
           (cond ((ignore-errors (org-edit-src-code) t)
                  (delete-other-windows))
                 ((ignore-errors (org-narrow-to-block) t))
                 (t (org-narrow-to-subtree))))
          ((and (derived-mode-p 'latex-mode)
                (ignore-errors (LaTeX-narrow-to-environment))))
          ((derived-mode-p 'emacs-lisp-mode)
           (narrow-to-defun))
          (t
           (brust-narrow-to-paragraph))))
#+END_SRC

#+RESULTS:
: endless/narrow-or-widen-dwim

*** By five
#+BEGIN_SRC elisp
  (defun brust-by-five (-function args)
    (funcall-interactively -function (if (numberp args)
                                         (* 5 args)
                                       5)))
#+END_SRC

*** Mouse wheel
    Mouse wheel: try it with S and C
**** Functions
#+BEGIN_SRC elisp
(defun up-slightly (args) (interactive "p") (brust-by-five #'scroll-up args))
(defun down-slightly (args) (interactive "p") (brust-by-five #'scroll-down args))

(defun up-one nil (interactive) (scroll-up 1))
(defun down-one nil (interactive) (scroll-down 1))

(defun up-a-lot nil (interactive) (scroll-up))
(defun down-a-lot nil (interactive) (scroll-down))

#+END_SRC
**** Keybindings
#+BEGIN_SRC elisp
(global-set-key [mouse-4] 'down-slightly)
(global-set-key [mouse-5] 'up-slightly)

(global-set-key [S-mouse-4] 'down-one)
(global-set-key [S-mouse-5] 'up-one)

(global-set-key [C-mouse-4] 'down-a-lot)
(global-set-key [C-mouse-5] 'up-a-lot)

#+END_SRC

*** COMMENT Narrow to paragraph
#+BEGIN_SRC elisp
  (defun brust-narrow-to-paragraph nil
    (interactive)
    (save-excursion
      (backward-paragraph)
      (let ((-pos (point)))
        (forward-paragraph)
        (narrow-to-region -pos (point)))))
#+END_SRC

*** Open fast usual files (by Xah Lee)
    This is an adaptation to my needs of [[http://ergoemacs.org/emacs/emacs_hotkey_open_file_fast.html][Emacs: Hotkey to Open File Fast]] by Xah Lee.
**** Lists
#+BEGIN_SRC elisp
  (defvar brust-file-list-list
    '((xah-filelist . (
                       ;; ("Doc-Org"    . "~/Dropbox/Org/Doc.org")
                       ("Th-master"  . "~/Dropbox/Thesis/classicthesis/master.tex")
                       ("My-theory"  . "~/Dropbox/Math/Doctorat11/Apunts/basic-algebraic-geometry.tex")
                       ;; ("Com-in-Alg" . "~/Dropbox/Math/Doctorat_Laura/Com_in_Alg/PauBrustenga_Urcf4.tex")
                       ;; ("pdf-notes"  . "~/Dropbox/bibliography/notes.org")
                       ("MyFinances" . "~/Dropbox/Org/ledger-2018.dat")
                       ("WebPage"    . "~/Dropbox/WebPage/LauraBMo.github.io/index.html")
                       ("MyBib"      . "~/Dropbox/bibliography/my.bib")
                       ))
      (config-files . (
                       ("Org-init"     . "~/.emacs.d/init.org")
                       ("el-init"      . "~/.emacs.d/init.el")
                       ("LaTeX-config" . "~/.emacs.d/lisp/brusts-latex-config.org")
                       ("abbrevs-tbl"  . "~/Dropbox/config/abbrev-def.el")
                       ))
      (org-files    . (
                       ("My-Org"   . "~/Dropbox/Org/my.org")
                       ("Recetari" . "~/Dropbox/Org/recetari.org")
                       ("Travels"  . "~/Dropbox/Org/travels.org")
                       ("Media"    . "~/Dropbox/Org/MyMedia.org")
                       ("Doctorat" . "~/Dropbox/Org/Doc.org")
                       )))
    "List of association list of file/dir paths. Used by `xah-open-file-fast'. Key is a short abbrev string, Value is file path string.")
#+END_SRC

#+RESULTS:
: brust-file-list-list

**** Function to open it fast.
#+BEGIN_SRC elisp
  (defun xah-open-file-fast nil
    "Prompt to open a file from `xah-filelist'.
      URL `http://ergoemacs.org/emacs/emacs_hotkey_open_file_fast.html'
      Version 2015-04-23"
    (interactive)
    (let* ((-list (cl-loop for xx in (mapcar 'cdr brust-file-list-list)
                           append xx))
           (ξabbrevCode (ivy-read "Open (%d) :" (mapcar 'car -list))))
      (if (file-exists-p ξabbrevCode)
          (find-file (cdr (assoc ξabbrevCode -list)))
        (error "File do not exits, update your list of files!"))))
#+END_SRC

**** Create and bind direct functions
     Really handy joinly with =which-key=.

#+BEGIN_SRC elisp
  (let ((i 0))
    (cl-loop
     for xx in (mapcar 'cdr brust-file-list-list) do
     (let ((j 1)
           (file (car xx))
           (prfx (if (< i 1) "<f2>"
                   (if (< i 2) (format "<f2> <f%d>" i)
                     (format "<f2> <f%d>" (1+ i))))))
       (setq i (1+ i))
       (while file
         (let ((name (intern (format "Open:%s" (car file)))))
           (fset name
                 `(lambda nil
                    (interactive) (find-file ,(cdr file))))
           (setq file (nth j xx))
           (unless (< j 10) (setq file nil j 0))
           (global-set-key (kbd (format "%s %d" prfx j)) name)
           (setq j (1+ j)))))))

  (global-set-key (kbd "<f2> <f2>") 'xah-open-file-fast)

#+END_SRC
*** Open file in external app


    #+BEGIN_SRC elisp
  (defun xah-open-in-external-app (&optional ξfile)
    "Open the current file or dired marked files in external app.
  The app is chosen from your OS's preference.

  URL `http://ergoemacs.org/emacs/emacs_dired_open_file_in_ext_apps.html'
  Version 2015-01-26"
    (interactive)
    (let* ((ξfile-list
            (if ξfile (list ξfile)
              (if (string-equal major-mode "dired-mode")
                  (dired-get-marked-files)
                (list (buffer-file-name)))))
           (ξdo-it-p (if (<= (length ξfile-list) 5)
                         t
                       (y-or-n-p "Open more than 5 files? "))))

      (when ξdo-it-p
        (cond
         ((string-equal system-type "windows-nt")
          (mapc
           (lambda (fPath)
             (w32-shell-execute "open" (replace-regexp-in-string "/" "\\" fPath t t))) ξfile-list))
         ((string-equal system-type "darwin")
          (mapc
           (lambda (fPath) (shell-command (format "open \"%s\"" fPath)))  ξfile-list))
         ((string-equal system-type "gnu/linux")
          (mapc
           (lambda (fPath) (let ((process-connection-type nil)) (start-process "" nil "xdg-open" fPath))) ξfile-list))))))

#+END_SRC

*** Org-Mode functions
**** COMMENT Meet notes
#+BEGIN_SRC elisp
(defun meeting-notes nil
  "Call this after creating an org-mode heading for where the notes for the meeting
should be. After calling this function, call 'meeting-done' to reset the environment."
  (interactive)
  (outline-mark-subtree)                              ;; Select org-mode section
  (narrow-to-region (region-beginning) (region-end))  ;; Only show that region
  (deactivate-mark)
  (delete-other-windows)                              ;; Get rid of other windows
  (text-scale-set 2)                                  ;; Text is now readable by others
  (fringe-mode 0)
  (message "When finished taking your notes, run meeting-done."))

(defun meeting-done nil
  "Attempt to 'undo' the effects of taking meeting notes."
  (interactive)
  (widen)                                       ;; Opposite of narrow-to-region
  (text-scale-set 0)                            ;; Reset the font size increase
  (fringe-mode 1)
  (winner-undo))                                ;; Put the windows back in place

#+END_SRC
**** Org surround text
***** Generic surround text
    Usually used in Org-mode

#+BEGIN_SRC elisp
;;; My improved surround-text ;;;

(defun brust-char-at-point nil
  (buffer-substring-no-properties (point) (1+ (point))))

(defun brust-move-untill (-step -regexp -to-test)
  (cl-loop until (string-match-p -regexp (funcall -to-test)) do
           (forward-char -step))
  (backward-char -step)
  (point))

(defun brust-string-at-point nil
  "Return the bounds of the chain of caraters at point delemited by any space char (space, new line, tab,...)"
  (save-excursion
    (cons (brust-move-untill -1 "[ \t\n\r]+\\'" 'brust-char-at-point)
          (1+ (brust-move-untill 1 "[ \t\n\r]+\\'" 'brust-char-at-point)))))

(defun brust-surround-text (str)
  "Surround selection or brust-string-at-point with str"
  (interactive "sSurrounding string:")
  (save-excursion
    (let ((-poss-cons
           (if (use-region-p)
               `(,(region-beginning) . ,(region-end))
             (brust-string-at-point))))
      (goto-char (cdr -poss-cons)) (insert str) ;; First, the larger postion.
      (goto-char (car -poss-cons)) (insert str))))
#+END_SRC

***** Org surround
#+BEGIN_SRC elisp
        (defun org-text-bold nil "Wraps the region with asterisks."
               (interactive)
               (brust-surround-text "*"))
        (defun org-text-italics nil "Wraps the region with slashes."
               (interactive)
               (brust-surround-text "/"))
        (defun org-text-code nil "Wraps the region with equal signs."
               (interactive)
               (brust-surround-text "="))
#+END_SRC
**** Eval elisp blocks under current header
#+BEGIN_SRC elisp
(defun brust-endless/org-eval-current-header nil
  (interactive)
  (brust-endless/org-eval-eblocks
   (and (org-copy-subtree)
        (pop kill-ring))))
#+END_SRC

*** Save and load my keyboard macros
    From https://www.emacswiki.org/emacs/KeyboardMacrosTricks

#+BEGIN_SRC elisp
  (defvar brust-my-macro-file "~/.emacs.d/lisp/brusts-macros.el"
    "File with all my keyboard macros")

  (defun save-macro (name)
    "Save last defined macro. Take a name as argument
        and save the last defined macro under
        this name at the end of your file of macros"
    (interactive "SName of the macro :")  ; ask for the name of the macro
    (kmacro-name-last-macro name)         ; use this name for the macro
    (find-file brust-my-macro-file)       ; open ~/.emacs or other user init file
    (goto-char (point-max))               ; go to the end of the .emacs
    (newline)                             ; insert a newline
    (insert-kbd-macro name)               ; copy the macro
    (newline)                             ; insert a newline
    (switch-to-buffer nil))               ; return to the initial buffera


  (load-file brust-my-macro-file)

#+END_SRC

*** COMMENT Search synonyms
#+BEGIN_SRC elisp
  (require 'browse-url) ; part of gnu emacs

  (defun brust-xah-lee-lookup-synonyms (arg)
    "Look up the word under cursor in Thesaurus.com.
  If there is a text selection (a phrase), use that.

  This command switches to browser."
    (interactive "P")
    (let ((*url
           (concat "http://www.thesaurus.com/browse/"
                   (if (use-region-p)
                       (buffer-substring-no-(point)roperties (region-beginning) (region-end))
                     (current-word)))))
      ;;(setq word (replace-regexp-in-string " " "_" word))
      (if arg (eww *url)
        (browse-url *url))))

  (global-set-key (kbd "C-c s") #'brust-xah-lee-lookup-synonyms)

#+END_SRC

#+RESULTS:
: brust-xah-lee-lookup-synonyms

*** Smarter navigation inside a line
    "Move point back to indentation of beginning of line.

    Move point to the first non-whitespace character on this line.
    If point is already there, move to the beginning of the line.
    Effectively toggle between the first non-whitespace character and
    the beginning of the line.

    If ARG is not nil or 1, move forward ARG - 1 lines first.  If
    point reaches the beginning or end of the buffer, stop there."

    Inspired from Sacha Chua's http://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/ and
    =move-beginning-of-line= of ergoemacs-mode.
**** to beginnings
#+BEGIN_SRC elisp
  (defun brust-smart-move-beginning-of-line (arg)
    "Cicle through beginnings of the current line:
    beginning of line, first non space char and first non sapce
    char after comment chars"
    (interactive "^p")
    ;; Move lines first
    (when (and arg (or (< 1 arg) (< arg 0)))
      (let ((line-move-visual nil))
        (forward-line (1- arg))))
    ;; Use org functions in org headers
    (cond ((and (string= major-mode 'org-mode)
                (let* ((element (save-excursion (beginning-of-line)
                                                (org-element-at-point)))
                       (type (org-element-type element)))
                  (memq type '(headline inlinetask))))
           (org-beginning-of-line))
          ;; move beginning of latex equation
          ((and (string= major-mode 'latex-mode)
                (texmathp)
                (not (= (point) (+ (cdr texmathp-why) (length (car texmathp-why))))))
           (goto-char (+ (cdr texmathp-why) (length (car texmathp-why)))))
          ;; respect the promp in buffers runing a process
         (;; (get-text-property (point-at-bol) 'cursor-intangible)
          ;; (beginning-of-line-text))
          (if-let ((-prompt (cdr (assoc (buffer-name) brust-math-software-buffers-prompts))))
              (goto-char (+ (point-at-bol) (length -prompt)))
            nil))
          (t
           (let ((pt (point))
                 (pnts `(,(point-at-bol)))
                 to-go)
             ;; List of interesting points
             (save-excursion
               (move-beginning-of-line 1)
               (skip-chars-forward " \t" (point-at-eol))
               (cl-pushnew (point) pnts)
               (when (re-search-forward
                      (concat "\\([%;]\\|"
                              (format "%s" comment-start-skip)
                              "\\)")
                      (point-at-eol) t)
                 (skip-chars-forward ";% \t" (point-at-eol))))
             (when (bound-and-true-p visual-line-mode)
               (save-excursion
                 (beginning-of-visual-line)
                 (unless (or (< (point) pt) (cdr pnts))
                   (backward-char 1)
                   (beginning-of-visual-line))
                 (push (point) pnts)))
             ;; Where to go
             (setq to-go (list-util-bounded-max pnts pt))
             (if to-go (goto-char to-go)
               (unless (= pt (point-at-eol))
                 (goto-char (list-util-bounded-max pnts (point-at-eol)))))))))
#+END_SRC

#+RESULTS:
: brust-smart-move-beginning-of-line

**** to ends
#+BEGIN_SRC elisp
  (defun brust-smart-move-end-of-line (arg)
    "Goes to the following end of the current line: last non sapce char before
      comments chars, last non space char of the line and the end of line.
      If you know that you are at the end of the current line, then you go to the following line."
    (interactive "^p")
    ;; Move lines first
    (when (and arg (or (< 1 arg) (< arg 0)))
      (let ((line-move-visual nil))
        (forward-line (1- arg))))
    ;; Use org functions in org headers
    (if (and (string= major-mode 'org-mode)
             (let* ((element (save-excursion (beginning-of-line)
                                             (org-element-at-point)))
                    (type (org-element-type element)))
               (memq type '(headline inlinetask))))
        (org-end-of-line)
      (let ((pt (point)) ;; Where I start.
            (pnts `(,(point-at-eol))) ;; all posible end of the line.
            to-go) ;; The point where we will go.
        ;; Create the list of interesting points
        (save-excursion ;; The end of the current visual line.
          (when (bound-and-true-p visual-line-mode)
            (end-of-visual-line)
            (unless (< pt (point)) (forward-char 1) (end-of-visual-line))
            (cl-pushnew (point) pnts)))
        (save-excursion ;; The last non-space char before coments
          (when (re-search-forward
                 (concat "\\([%;]\\|"
                         (format "%s" comment-start-skip)
                         "\\)")
                 (point-at-eol) t)
            (goto-char (match-beginning 0))
            (skip-syntax-backward "\t " (point-at-bol)) (cl-pushnew (point) pnts))
          (goto-char (point-at-eol)) ;; The last non-space char.
          (skip-syntax-backward "\t " (point-at-bol)) (cl-pushnew (point) pnts))
        (setq to-go (list-util-bounded-min pnts pt)) ;; Which point to go, if it is.
        (if to-go (goto-char to-go)
          (when (string= last-command 'brust-smart-move-end-of-line)
            (when (< 0 (forward-line 1)) (insert "\n")) ;; Insert new line at the end of the buffer.
            (back-to-indentation))))))
#+END_SRC

**** COMMENT Keybinding
     Remap =C-a= to `brust-smart-move-beginning-of-line'
     Remap =C-e= to `brust-smart-move-end-of-line'
     Remap =M-<= to `brust-toggle-begin&end-of-buffer'
#+BEGIN_SRC elisp
  (global-set-key [remap move-beginning-of-line]
                  'brust-smart-move-beginning-of-line)
  (global-set-key [remap move-end-of-line]
                  'brust-smart-move-end-of-line)
  (global-set-key [remap beginning-of-buffer]
                  'brust-toggle-begin&end-of-buffer)
#+END_SRC

*** Smart yanking
    Worng behavior: it yank two things.
**** COMMENT Original idea
    From [[http://mbork.pl/2018-07-02_Smart_yanking]]
    and [[https://gist.github.com/mbork/9ee1bd8216424e07342e88739fe65547][The code at github]]
#+BEGIN_SRC elisp
  (defun has-space-at-boundary-p (string)
    "Check whether STRING has any whitespace on the boundary.
  Return 'left, 'right, 'both or nil."
    (let ((result nil))
      (when (string-match-p "^[[:space:]]+" string)
        (setq result 'left))
      (when (string-match-p "[[:space:]]+$" string)
        (if (eq result 'left)
            (setq result 'both)
          (setq result 'right)))
      result))

  (defun is-there-space-around-point-p ()
    "Check whether there is whitespace around point.
  Return 'left, 'right, 'both or nil."
    (let ((result nil))
      (when (< (save-excursion
                 (skip-chars-backward "[:space:]")   )
               0)
        (setq result 'left))
      (when (> (save-excursion
                 (skip-chars-forward "[:space:]"))
               0)
        (if (eq result 'left)
            (setq result 'both)
          (setq result 'right)))
      result))

  (defun set-point-before-yanking (string)
    "Put point in the appropriate place before yanking STRING."
    (let ((space-in-yanked-string (has-space-at-boundary-p string))
          (space-at-point (is-there-space-around-point-p)))
      (cond ((and (eq space-in-yanked-string 'left)
                  (eq space-at-point 'left))
             (skip-chars-backward "[:space:]"))
            ((and (eq space-in-yanked-string 'right)
                  (eq space-at-point 'right))
             (skip-chars-forward "[:space:]")))))

  (defun set-point-before-yanking-if-in-text-mode (string)
    "Invoke `set-point-before-yanking' in text modes."
    (when (derived-mode-p 'text-mode)
      (set-point-before-yanking string)))

  (advice-add
   'insert-for-yank
   :before
  #'set-point-before-yanking-if-in-text-mode)
#+END_SRC

#+RESULTS:

**** My own
***** Auxiliary functions
#+BEGIN_SRC elisp
  (defun brust--is-there-two-spaces-around-point-p nil
    (save-excursion
      (skip-chars-backward "[:space:]")
      (eq (skip-chars-forward "[:space:]") 2)))

  (defun brust--is-there-one-space-around-point-p nil
    (save-excursion
      (skip-chars-backward "[:space:]")
      (eq (skip-chars-forward "[:space:]") 1)))
#+END_SRC

***** COMMENT Main function
#+BEGIN_SRC elisp
  (defun brust-set-point-before-yanking-text-mode (-string)
    (when (derived-mode-p 'text-mode)
      (skip-chars-backward "[:space:]")
      (cond
       ((brust--is-there-one-space-around-point-p)
        (insert " ")
        (setq -string (s-trim -string)))
       ((brust--is-there-two-spaces-around-point-p)
        (forward-char 1)
        (setq -string (s-trim -string))))))
#+END_SRC

***** COMMENT Advice
#+BEGIN_SRC elisp
  (advice-add
   'insert-for-yank
   :before
   #'brust-set-point-before-yanking-text-mode)
#+END_SRC

#+RESULTS:

*** String start-p
#+BEGIN_SRC elisp
  (defun string-starts-with-p (string prefix)
    "Return t if STRING starts with prefix."
    (and (string-match (rx-to-string `(: bos ,prefix) t) string) t))
#+END_SRC
*** Term
#+BEGIN_SRC elisp
  (defun brust-term-bash nil
    (interactive)
    (term (getenv "SHELL")))

(setq password-cache-expiry nil) ;;don’t let passwords expire
#+END_SRC
*** Toggle bars
#+BEGIN_SRC elisp
  (defun brust-toggle-menu-tool-bars nil
    "Toggle Emacs menu and tool bar"
    (interactive)
    (let ((active-p
           (if (or menu-bar-mode tool-bar-mode) -1 1)))
      (menu-bar-mode active-p) (tool-bar-mode active-p)))
#+END_SRC

*** Word count
#+BEGIN_SRC elisp
  (defun brust-wc-get-word-count-list-of-current-project nil
    (let ((project-master (expand-file-name (TeX-master-file t nil t))))
      (with-temp-buffer
        (call-process-shell-command
         (concat "texcount -opt="
                 (expand-file-name "~/Dropbox/config/TeXcount-emacs.txt")
                 " -dir="
                 (file-name-directory project-master)
                 " "
                 project-master)
         nil t)
        (re-search-backward
         "new\\([0-9]+\\)w\\([0-9]+\\)im\\([0-9]+\\)dm\\([0-9]+\\)cd\\([0-9]+\\)h\\([0-9]+\\)file" nil t)
        (cl-loop for xx from 1 to 6
                 if (= xx 3) collect (number-to-string (- (string-to-number (match-string-no-properties 3))
                                                          (string-to-number (match-string-no-properties 4))))
                 else
                 collect (match-string-no-properties xx)))))

  (defun brust-wc-save-words nil
    (interactive)
    (let ((wc-sat (brust-wc-get-word-count-list-of-current-project)))
      (find-file (concat
                  (file-name-directory (expand-file-name (TeX-master-file t nil t)))
                  "wc-statistics.txt"))
      (goto-char (point-max))
      (insert "\n" (format-time-string "%x, %X, ")
              (cl-loop for xx in wc-sat
                       concat (concat xx ", ")))
      (save-buffer)
      (kill-buffer)))

  (defun brust-wc-save-words-my-thesis nil
    (interactive)
    (find-file "~/Dropbox/Math/Doctorat_Laura/Thesis/master.tex")
    (brust-wc-save-words))
#+END_SRC

*** Whitespace cycle
    :PROPERTIES:
    :ID:       d7f7cfc9-9da0-4eb6-b8a9-2cd69279a0d2
    :END:
    This is a remake and merge of `cycle-spacing' `delete-blank-lines' and `xah-shrink-whitespaces'.
#+BEGIN_SRC elisp
  (defun brust-cycle-whitespace nil
    (interactive)
    (let* ((--pt0 (point))
           (--inline-skip-chars " \t\v\f")
           (--skip-chars " \t\v\f\n")
           (--beg (progn
                    (skip-chars-backward --skip-chars)
                    (constrain-to-field nil --pt0)
                    (point)))
           (--end (progn
                    (skip-chars-forward --skip-chars)
                    (constrain-to-field nil --pt0)
                    (point)))
           (--indent (buffer-substring-no-properties
                      (progn
                        (skip-chars-backward --inline-skip-chars)
                        (point))
                      --end))
           (--contex (buffer-substring --beg --end))
           (--lnum (1- (length (split-string --contex "\n")))))
      (cond
       ((or (not (equal last-command this-command))
            (not brust-cycle-whitespace--context))
        ;; Special handling for case where there was no space at all.
        (cond ((< --beg --end)
               (setq brust-cycle-whitespace--context ;;Save for later.
                     (cons --pt0 --contex))
               (delete-region --beg --end)
               (when (and (< (1+ --beg) --end)   ;; more than one space
                          (< --end (point-max))  ;; erase whitespace at eobp
                          (< (point-min) --beg)) ;; and at bobp
                 (insert
                  (cond ((< --lnum 2) " ")
                        ((< --lnum 3) (concat "\n" --indent))
                        (t (concat "\n\n" --indent))))))
              (t ;; indent when it is called without surrounding whitespaces.
               (end-of-line)
               (brust-cycle-whitespace))))
       ;; Final call: (and (equal last-command this-command) (equal --beg --end))
       ((not (< --beg --end))
        (insert (cdr brust-cycle-whitespace--context))
        (goto-char (car brust-cycle-whitespace--context))
        (setq cycle-spacing--context nil))
       ;; Intermadiate calls (and (equal last-command this-command) (< --beg --end))
       (t
        (delete-region --beg --end)
        (insert
         (cond ((< --lnum 1) "")
               ((< --lnum 2) " ")
               ((< --lnum 3) (concat "\n" --indent))
               (t (concat "\n\n" --indent))))))))
    ;; (more-expansions #'(brust-cycle-whitespace)))

  (defvar brust-cycle-whitespace--context nil
    "Store context used in consecutive calls to `brust-cycle-whitespace' command.
       The first time `brust-cycle-whitespace' runs, it saves in this variable:
       the original point position, and the original spacing around point.")

#+END_SRC

** External modes
*** Ace window
   With one "universal-argument" swap the selected and current window.
   With two "universal-argument" delete the selected window.
   there is "ace-window-display-mode" (I don't know...)
#+BEGIN_SRC elisp
  (use-package ace-window
    :init
    (setq aw-keys '(?q ?w ?e ?r))
    ;;aw-dispatch-always t ;; This work together!! :(
    ;;aw-dispatch-alist
    ;;'((?d aw-delete-window     "Ace - Delete Window")
    ;;  (?s aw-swap-window       "Ace - Swap Window")
    ;;  (?\' aw-flip-window)
    ;;  (?v aw-split-window-vert "Ace - Split Vert Window")
    ;;  (?h aw-split-window-horz "Ace - Split Horz Window")
    ;;  (?x delete-other-windows "Ace - Maximize Window")
    ;;  (?\, delete-other-windows)
    ;;  (?b balance-windows "Balance")
    ;;  (?u winner-undo)
    ;;  (?y winner-redo)))
    (defun brust-ace-window (&optional args)
      (interactive "p")
      (if (< 1 (count-windows)) (ace-window args)
        (mode-line-other-buffer)))
    :bind
    ("<f12>" . brust-ace-window)
    ("C-n" . brust-ace-window))

#+END_SRC

*** Aggressive indent
#+BEGIN_SRC elisp
  (use-package aggressive-indent
    :init
    (global-aggressive-indent-mode)
    ;; (add-hook 'org-mode-hook #'aggressive-indent-mode)
    (add-hook 'LaTeX-mode-hook #'aggressive-indent-mode))
#+END_SRC

#+RESULTS:
|

*** COMMENT Anki Editor
 The web [[https://github.com/louietan/anki-editor][Git Hub repository]]
#+BEGIN_SRC elisp
  (use-package anki-editor)
#+END_SRC

#+RESULTS:

*** TODO Avy
    :TODO: Learn which =avy-goto-??= is my favorite!
    :TODO: Find easy type and remember =chords=
#+BEGIN_SRC elisp
  (use-package avy
    :chords
    ("qq" . avy-goto-char-timer)
    ;; ("gg" . avy-goto-word-2)
    ;; ("qq" . avy-goto-word-2)
    :bind
    ("M-g g"   . avy-goto-line)
    ("s-."     . avy-goto-char-timer)
    ;; ("M-SPC" . avy-goto-char)
    :config
    (set-face-attribute 'avy-lead-face nil :foreground "deep sky blue" :weight 'bold :height 1.0)
    (setq avy-background t
          avy-timeout-seconds 0.16)
    ;; (setq avy-styles-alist '((avy-goto-word-or-subword-1 . de-brujin)))
    ;; (bind-key "s-." 'avy-goto-word-or-subword-1)
    )
#+END_SRC
*** Beacon mode
    Beacon, iluminació del cursor.
#+BEGIN_SRC elisp
  (use-package beacon
    :init
    (setq beacon-push-mark 35
          beacon-blink-delay 0.3
          beacon-blink-duration 0.3
          beacon-blink-when-buffer-changes t
          beacon-blink-when-point-moves-vertically 15
          beacon-color "#66999D"
          beacon-size 25)
    (beacon-mode 1))
#+END_SRC

#+RESULTS:
|

*** Company
**** General config.
#+BEGIN_SRC elisp
  (use-package company
    :defer t
    :init
    (setq  company-idle-delay 0.1
           company-lighter-base ""
           company-minimum-prefix-length 2
           company-auto-complete-chars (quote (32 95 40 41 119 46 62))
           company-show-numbers t
           company-tooltip-align-annotations t)
    (add-hook 'after-init-hook #'global-company-mode)
    :bind (:map company-active-map
                ("<return>" . company-complete-selection)
                ("TAB"      . brust-company-abort-cdlatex-or-yas)
                ("<tab>"    . brust-company-abort-cdlatex-or-yas)
                ("s-l"      . company-complete-common)
                ("s-i"      . company-select-previous)
                ("s-k"      . company-select-next)
                ("s-o"      . company-complete-selection)
                ("s-g"      . company-abort)
                ("<f1>"     . company-show-doc-buffer)
                ("C-h"      . company-show-doc-buffer)
                ("s-h"      . company-show-doc-buffer)
                ("s-j"      . company-show-location)
                ("C-l"      . company-show-location))
    :config
    (defun brust-company-abort-cdlatex-or-yas nil
      (interactive)
      (company-abort)
      (if (fboundp 'cdlatex-tab)
          (cdlatex-tab)
        (when (fboundp 'yas-expand)
          (yas-expand))))

    (defun brust-generic-company-setup (-ll)
      (make-local-variable 'company-backends)
      (cl-loop for -add-backend in (reverse -ll) do
               (add-to-list 'company-backends `,-add-backend)))

    (defun toggle-company-ispell nil
      (interactive)
      (cond
       ((memq 'company-ispell company-backends)
        (setq company-backends (delete 'company-ispell company-backends))
        (message "company-ispell disabled"))
       (t
        (add-to-list 'company-backends 'company-ispell t)
        (message "company-ispell enabled!"))))

    (defun text-mode-hook-company-setup nil
      (brust-generic-company-setup '(company-ispell))
      ;; OPTIONAL, if `company-ispell-dictionary' is nil, `ispell-complete-word-dict' is used
      ;;  but I prefer hard code the dictionary path. That's more portable.
      (when (file-exists-p "~/Dropbox/config/english-words.txt")
        (setq company-ispell-dictionary (file-truename "~/Dropbox/config/english-words.txt"))))

    (add-hook 'text-mode-hook #'text-mode-hook-company-setup)

    (use-package company-shell
      :init
      (defun shell-mode-hook-company-setup nil
        (brust-generic-company-setup '((company-shell company-fish-shell))))
      (add-hook 'shell-mode-hook #'shell-mode-hook-company-setup))

    (use-package company-statistics
      :init
      (setq company-statistics-file "~/.emacs.d/backups/company-statistics-cache.el")
      (company-statistics-mode))

    ;; (use-package company-math)
    (use-package company-auctex
      :after auctex)
    ;; local configuration for TeX modes
    (defun LaTeX-mode-hook-company-setup nil
      ;; (require 'dabbrev)
      (make-local-variable 'company-backends)
      (setq company-backends '(company-semantic company-files company-dabbrev-code company-dabbrev company-ispell))
      (company-auctex-init))

    ;;    (brust-generic-company-setup
    ;;     '(;; company-auctex-labels
    ;;       ;; company-auctex-bibs
    ;;       (company-auctex-macros
    ;;        company-auctex-symbols
    ;;        company-auctex-environments
    ;;        ;; company-math-symbols-latex
    ;;        company-latex-commands))))

    ;; use numbers 0-9 to select company completion candidates (from abo-abo's config file.
    ;;   (let ((map company-active-map))
    ;;     (mapc (lambda (x) (define-key map (format "%d" x)
    ;;                         `(lambda nil (interactive) (company-complete-number ,x))))
    ;;           (number-sequence 0 9)))
    )
#+END_SRC

#+RESULTS:

**** COMMENT Company-box
#+BEGIN_SRC elisp
(use-package company-box
  :after company
  :hook (company-mode . company-box-mode))
#+END_SRC

#+RESULTS:
| company-box-mode | company-mode-set-explicitly |

*** Easy kill
    * What can =M-w= copy and how
      - =M-w w=: save word at point
      - =M-w s=: save sexp at point
      - =M-w l=: save list at point (enclosing sexp)
      - =M-w d=: save defun at point
      - =M-w D=: save current defun name
      - =M-w f=: save file at point
      - =M-w b=: save buffer-file-name or default-directory. - changes the kill to the directory name, + to full name and 0 to basename.
    * The following keys modify the selection:
      - =@=: append selection to previous kill and exit.
      - =C-w=: kill selection and exit
      - =+=, =-= and =1..9=: expand/shrink selection
      - =0= shrink the selection to the initial size i.e. before any expansion
      - =C-SPC=: turn selection into an active region
      - =C-g=: abort
      - =?=: show this help
#+BEGIN_SRC elisp
  (use-package easy-kill
    :init
    (global-set-key [remap kill-ring-save] 'easy-kill)
    ;;(global-set-key [remap mark-word] #'easy-mark-word)
    ;;(global-set-key [remap zap-to-char] 'easy-mark-to-char)
    ;;(global-set-key [remap mark-sexp] #'easy-mark)
    ;;(global-set-key [remap ] 'easy-kill)
    :bind
    ("C-S-k"  . kill-backward-line-or-append)
    ("C-k"    . kill-forward-line-or-append)
    ("C-w"    . xah-cut-line-or-region) ; cut
    ;; ("M-w"  . xah-copy-line-or-region) ; copy
    ("C-S-w"  . brust-cut-previous-line))
#+END_SRC

#+RESULTS:

**** COMMENT Copy
      I don't use it, I use =easy-kill= enstead.
#+BEGIN_SRC elisp
  (defun xah-copy-line-or-region nil
    "Copy current line, or text selection.
    When `universal-argument' is called first, copy whole buffer (but respect `narrow-to-region')."
    (interactive)
    (if (null current-prefix-arg)
        (progn (if (use-region-p)
                   (progn (setq p1 (region-beginning))
                          (setq p2 (region-end)))
                 (progn (setq p1 (line-beginning-position))
                        (setq p2 (line-beginning-position 2)))))
      (progn (setq p1 (point-min))
             (setq p2 (point-max))))
    (kill-ring-save p1 p2))
#+END_SRC

**** Cut/kill
#+BEGIN_SRC elisp
  (defun xah-cut-line-or-region (args)
    "Cut current line, or text selection. When `universal-argument' is called first, cut whole buffer (but respect `narrow-to-region')."
    (interactive "P")
    (kill-region (or (and args (point-min)) (line-beginning-position))
                 (or (and args (point-max)) (line-beginning-position 2))
                 (use-region-p))
    (when (and (derived-mode-p 'text-mode)
               (brust--is-there-two-spaces-around-point-p))
      (skip-chars-backward "[:space:]")
      (delete-char 1)))

  (defun brust-cut-previous-line nil
    (interactive)
    (previous-line) (kill-whole-line))
#+END_SRC

**** Kil beginning/end of line
#+BEGIN_SRC elisp
    (defun kill-backward-line-or-append nil
      "Cut from begin of line to point"
      (interactive)
      (if (< (line-beginning-position) (point))
          (kill-region (line-beginning-position) (point))
        (delete-indentation)))

  (defun kill-forward-line-or-append nil
      "Cut from begin of line to point"
      (interactive)
      (if (< (point) (line-end-position))
          (kill-region (point) (line-end-position))
        (delete-indentation t)))
#+END_SRC
*** Expand region

#+BEGIN_SRC elisp
  (use-package expand-region)
    ;;:bind
    ;;("s-ç" . er/mark-LaTeX-math) ;; was (quoted-insert ARG)
    ;; :init (setq-default er/try-expand-list
    ;;                    '(er/mark-word
    ;;                      er/mark-symbol
    ;;                      ;; er/mark-symbol-with-prefix
    ;;                      ;; er/mark-next-accessor
    ;;                      ;; er/mark-method-call
    ;;                      er/mark-inside-quotes
    ;;                      er/mark-outside-quotes
    ;;                      er/mark-inside-pairs
    ;;                      er/mark-outside-pairs
    ;;                      er/mark-comment
    ;;                      er/mark-url
    ;;                      er/mark-email
    ;;                      ;; er/mark-defun
    ;;                      ))
    ;; :chords
    ;; ("xx" . er/expand-region)
    ;; ("<-" . er/expand-region)
    ;; ("jj" . er/expand-region)
    ;; ("<." . goto-last-change)
    ;; ("<," . brust-toggle-begin&end-of-buffer)
#+END_SRC

#+RESULTS:
: brust-toggle-begin&end-of-buffer

*** COMMENT Evil mode
#+BEGIN_SRC elisp
(use-package evil
  :config
  (evil-mode 1))

;; Make magit and evil play nice
(use-package evil-magit)
#+END_SRC
*** TODO Fix word - Capitalize
**** Eneble subword
     It is needed
#+BEGIN_SRC elisp
(subword-mode 1)

#+END_SRC

**** COMMENT TODO Smart capitalize from Endless
     From Endless!!
     Given:: Languages are fleeting. But Emacs is forever.
     ;;;;;;; With the cursor on 'B' type M-l ;;;;;;;
     Gets:: Languages are fleeting, but Emacs is forever.

     - Functions Originals from Endless::
***** COMMENT TODO Convert punctuation
#+BEGIN_SRC elisp
 (defun endless/convert-punctuation (rg rp)
   "Look for regexp RG around point, and replace with RP.
 Only applies to text-mode."
   (let ((f "\\(%s\\)\\(%s\\)")
         (space "?:[[:blank:]\n\r]*"))
     ;; We obviously don't want to do this in prog-mode.
     (if (and (derived-mode-p 'text-mode)
              (or (looking-at (format f space rg))
                  (looking-back (format f rg space))))
         (replace-match rp nil nil nil 1))))

#+END_SRC

***** COMMENT Capitalize
#+BEGIN_SRC elisp
(defun endless/capitalize nil
  "Capitalize region or word.
Also converts commas to full stops, and kills
extraneous space at beginning of line."
  (interactive)
  (endless/convert-punctuation "," ".")
  (if (use-region-p)
      (call-interactively 'capitalize-region)
    ;; A single space at the start of a line:
    (when (looking-at "^\\s-\\b")
      ;; get rid of it!
      (delete-char 1))
    (call-interactively 'subword-capitalize)))


#+END_SRC

***** COMMENT Downcase
#+BEGIN_SRC elisp
(defun endless/downcase nil
  "Downcase region or word.
Also converts full stops to commas."
  (interactive)
  (endless/convert-punctuation "\\." ",")
  (if (use-region-p)
      (call-interactively 'downcase-region)
    (call-interactively 'subword-downcase)))


#+END_SRC

***** COMMENT Upcase
#+BEGIN_SRC elisp
(defun endless/upcase nil
  "Upcase region or word."
  (interactive)
  (if (use-region-p)
      (call-interactively 'upcase-region)
    (call-interactively 'subword-upcase)))
#+END_SRC

**** Brust-Endless
***** Convert punctuation
#+BEGIN_SRC elisp
  (defun brust-endless/convert-punctuation (rg rp)
    "Look for regexp RG at the end of the previous word, and replace with RP.
  Only applies to text-mode."
    ;; We obviously don't want to do this in prog-mode.
    (unless (looking-back "\\b")
      (backward-word))
    (save-excursion
      (let ((f (format "\\([%s]\\)" rg)))
        (when (and (derived-mode-p 'text-mode)
                   (progn (backward-word) (forward-word) (looking-at f)))
          (replace-match rp nil nil nil 1)))))

#+END_SRC

***** Capitalize
#+BEGIN_SRC elisp
  (defun brust-endless/capitalize nil
    "Capitalize word or region.
  Also converts commas to full stops."
    (interactive)
   (if (use-region-p)
       (call-interactively 'capitalize-region)
     (brust-endless/convert-punctuation "," ".")
     (call-interactively 'subword-capitalize)
     (forward-word) (backward-word)))

#+END_SRC
***** Downcase
#+BEGIN_SRC elisp
  (defun brust-endless/downcase nil
    "Downcase word.
  Also converts commas to full stops, and kills
  extraneous space at beginning of line."
    (interactive)
    (if (use-region-p)
        (call-interactively 'downcase-region)
      (brust-endless/convert-punctuation "." ",")
      (call-interactively 'subword-downcase)
      (forward-word) (backward-word)))

#+END_SRC

***** Upcase
#+BEGIN_SRC elisp
(defun endless/upcase nil
  "Upcase region or word."
  (interactive)
  (if (use-region-p)
      (call-interactively 'upcase-region)
    (call-interactively 'subword-upcase)))

#+END_SRC

**** COMMENT Fix word
     The most interesting is =fix-word-define-command=
     Define `fix-word'-based command named NAME.
     FNC is the processing function and DOC is documentation string.
#+BEGIN_SRC elisp
(use-package fix-word
  :config
  (fix-word-define-command fix-word-brust-endless/capitalize #'brust-endless/capitalize)
  (fix-word-define-command fix-word-brust-endless/downcase   #'brust-endless/downcase)
  ;;(fix-word-define-command fix-word-endless/upcase     #'endless/upcase)

  (global-set-key (kbd "M-u") #'fix-word-upcase)
  (global-set-key (kbd "M-l") #'fix-word-brust-endless/downcase)
  (global-set-key (kbd "M-c") #'fix-word-brust-endless/capitalize))
#+END_SRC
**** COMMENT Xah cicle
#+BEGIN_SRC elisp
;;; Cycle Letter Case
;; http://ergoemacs.org/emacs/modernization_upcase-word.html
(defun xah-cycle-letter-case (arg)
  "Cycle the letter case of the selected region or the current word.
Cycles from 'lower' -> 'Capitalize' -> 'UPPER' -> 'lower' -> ..
        C-u M-x xah-cycle-letter-case -> Force convert to upper case.
    C-u C-u M-x xah-cycle-letter-case -> Force convert to lower case.
C-u C-u C-u M-x xah-cycle-letter-case -> Force capitalize."
  (interactive "p")
  (let (p1 p2
           (deactivate-mark nil)
           (case-fold-search nil))
    (if (use-region-p)
        (setq p1 (region-beginning)
              p2 (region-end))
      (let ((bds (bounds-of-thing-at-point 'word)))
        (setq p1 (car bds)
              p2 (cdr bds))))

    (cl-case arg
      (4  (put this-command 'next-state "UPPER"))      ; Force convert to upper case
      (16 (put this-command 'next-state "lower"))      ; Force convert to lower case
      (64 (put this-command 'next-state "Capitalize")) ; Force capitalize
      (t (when (not (eq last-command this-command))
           (save-excursion
             (goto-char p1)
             (cond
              ;; lower -> Capitalize
              ((looking-at "[[:lower:]]")            (put this-command 'next-state "Capitalize"))
              ;; Capitalize -> UPPER
              ((looking-at "[[:upper:]][[:lower:]]") (put this-command 'next-state "UPPER"))
              ;; Default: UPPER -> lower
              (t                                     (put this-command 'next-state "lower")))))))

    (cl-case (string-to-char (get this-command 'next-state)) ; `string-to-char' returns first character in string
      (?U (upcase-region p1 p2)
          ;; UPPER -> lower
          (put this-command 'next-state "lower"))
      (?l (downcase-region p1 p2)
          ;; lower -> Capitalize
          (put this-command 'next-state "Capitalize"))
      (t (upcase-initials-region p1 p2)
         ;; Capitalize -> UPPER
(put this-command 'next-state "UPPER")))))
#+END_SRC
*** Fuzzi file finder
#+begin_src elisp
(use-package fzf)

#+end_src

#+RESULTS:

*** COMMENT GAP modes
#+BEGIN_SRC elisp
  ;; gap mode
  (autoload 'gap-mode "gap-mode" "Gap editing mode" t)
  (setq auto-mode-alist (append (list '("\\.g\\'" . gap-mode)
                                      '("\\.gap\\'" . gap-mode))
                                auto-mode-alist))
  (autoload 'gap "gap-process" "Run GAP in emacs buffer" t)
  (setq gap-executable "~/scr/gap-4.10.2/bin/gap.sh")
  (setq gap-start-options (list "-l" "-m" "2m"))

#+END_SRC
*** Git gutter fringe+
#+BEGIN_SRC elisp
  (use-package git-gutter-fringe+
    :init
    ;; Please adjust fringe width if your own sign is too big.
    (setq-default left-fringe-width 10)
    (setq git-gutter-window-width 1
          git-gutter+-lighter ""
          git-gutter+-modified-sign "⚑"
          git-gutter+-added-sign "☀"
          git-gutter+-deleted-sign "✘")

    (add-hook 'after-init-hook #'global-git-gutter+-mode)
    :bind
    (:map git-gutter+-mode-map
          ("C-x v p" . git-gutter+-previous-hunk)
          ("C-x v n" . git-gutter+-next-hunk)
          ("C-x v =" . git-gutter+-show-hunk)
          ;; ("C-x r" . git-gutter+-revert-hunks)
          ;; ("C-x t" . git-gutter+-stage-hunks)
          ;; ("C-x c" . git-gutter+-commit)
          ("C-x v C" . git-gutter+-stage-and-commit)
          ;; ("C-x U" . git-gutter+-unstage-whole-buffer)
          ("C-x v C-y" . git-gutter+-stage-and-commit-whole-buffer)))
#+END_SRC

#+RESULTS:

*** COMMENT Golden ratio
    There we some estrange movements.
#+BEGIN_SRC elisp
  (use-package golden-ratio
    :init
    (setq golden-ratio-auto-scale t
          split-width-threshold 1000
          golden-ratio-exclude-modes
          '("dired-mode"
            "ediff-mode"
            ;; "eshell-mode"
            "neotree-mode"
            "sr-speedbar-mode"))
    (golden-ratio-mode 1)
    :config
    ;; Make a nice interaction with ediff
    (add-hook 'ediff-before-setup-hook
              (lambda nil
                (golden-ratio-mode -1)
                (balance-windows)))
    (add-hook 'ediff-cleanup-hook (lambda nil (golden-ratio-mode 1)))

    (add-to-list 'golden-ratio-extra-commands #'brust-ace-window)
    (add-to-list 'golden-ratio-extra-commands #'avy-goto-char-timer)
    (add-to-list 'golden-ratio-extra-commands #'avy-goto-word-1)
    ;; (add-to-list 'golden-ratio-exclude-buffer-names "")
    ;; (add-to-list 'golden-ratio-inhibit-functions #'brust-not-resize-on-mouse)
    (add-to-list 'golden-ratio-exclude-buffer-regexp "^\\*magit: +.*")
    (remove-hook 'mouse-leave-buffer-hook #'golden-ratio--mouse-leave-buffer-hook))
#+END_SRC

#+RESULTS:
: t

*** Zoom
#+begin_src elisp
  (use-package zoom
    :init
    (setq zoom-size '(0.618 . 0.618)
          zoom-ignored-major-modes '("dired-mode"
                                     "ediff-mode"
                                     ;; "eshell-mode"
                                     ;; "neotree-mode"
                                     "sr-speedbar-mode")
          zoom-ignored-buffer-name-regexps '("^*calc" "^\\*magit: +.*"))
    :config
    (zoom-mode 1)
    (defun brust-zoom-off nil
      (zoom-mode -1)
      ;;(balance-windows)
      )
    (defun brust-zoom-on nil
      (zoom-mode 1)
      ;;(balance-windows)
      )

    (add-hook 'ediff-before-setup-hook 'brust-zoom-off)
    (add-hook 'ediff-cleanup-hook 'brust-zoom-on)
    )

    ;; (remove-hook 'mouse-leave-buffer-hook #'golden-ratio--mouse-leave-buffer-hook))
#+end_src

#+RESULTS:
: t

*** Go to last change
#+BEGIN_SRC elisp
  (use-package goto-chg
    :bind*
    ("s-ñ" . goto-last-change)
    ;; ("C-<" . goto-last-change)
    ;; ("C->" . goto-last-change-reverse)
    )
#+END_SRC

#+RESULTS:
: goto-last-change

*** COMMENT Grab and drop
#+BEGIN_SRC elisp
(require 'grab-and-drag)
(grab-and-drag-mode 1)

(setq grab-and-drag-pointer-shape nil)
#+END_SRC

#+RESULTS:
: t

*** Helpful
#+BEGIN_SRC elisp
  (use-package helpful
    :after ivy
    :init
    (setq counsel-describe-function-function #'helpful-function
          counsel-describe-variable-function #'helpful-variable)
    :bind
    ("<f1> c" . helpful-command)
    ("<f1> k" . helpful-key)
    ("C-h c" . helpful-command)
    ("C-h k" . helpful-key))
#+END_SRC

#+RESULTS:
: helpful-key

*** TODO Hydra
**** Config
#+BEGIN_SRC elisp
(use-package hydra)
#+END_SRC

#+RESULTS:

**** Dired
#+BEGIN_SRC elisp
  (defhydra hydra-dired (:color pink :columns 3 :hint nil)
    "
  ^Mark^‗‗‗‗‗‗‗^Flag^‗‗‗‗‗‗‗‗^Emacs Op^‗‗‗‗‗‗^‗^‗‗‗‗‗‗‗‗‗‗‗‗‗^^File Op^^‗‗(_e_dit)
  _*_: marks   _#_: temp     _Q_uery replace _F_ind marked   _!_shell_&_ _S_ymlink
  _%_: regexp  _~_: backup   _A_: grep       _L_oad          ^^_C_opy    _H_ardlink
  _u_n/_m_ark    _d_: this     _B_yte compile  kill li_n_e     ^^_D_elete  ch_M_od
  _t_oggle     _x_: delete   _v_iew          _w_: file name  ^^_R_ename  ch_O_wn
  _U_nmark all _<_ _>_:dirline _o_ther window  redisp_l_ay     ^^_T_ouch   ch_G_rp
  "
    ("SPC" nil)
    ("RET" dired-find-alternate-file :exit t)
    ("q" quit-window :exit t)
    ("e" wdired-change-to-wdired-mode)
    ("!" dired-do-shell-command)
    ("m" dired-mark)
    ("u" dired-unmark)
    ("#" dired-flag-auto-save-files)
    ("$" dired-hide-subdir "hide subdir")
    ("%" hydra-dired-regexp/body :exit t)
    ("&" dired-do-async-shell-command)
    ("(" dired-hide-details-mode "hide details")
    ("*" hydra-dired-mark/body :exit t)
    ("+" dired-create-directory "create dir")
    ("." dired-clean-directory "clean dir")
    ("<" dired-prev-dirline)
    ("=" ora-ediff-files "diff 2 files")
    ;; ("=" dired-diff "diff")
    (">" dired-next-dirline)
    ("A" dired-do-find-regexp)
    ("B" dired-do-byte-compile)
    ("C" dired-do-copy)
    ("D" dired-do-delete)
    ("F" dired-do-find-marked-files :exit t)
    ("G" dired-do-chgrp)
    ("H" dired-do-hardlink)
    ("L" dired-do-load)
    ("M" dired-do-chmod)
    ("O" dired-do-chown)
    ("P" dired-do-print "print")
    ("Q" dired-do-find-regexp-and-replace)
    ("R" dired-do-rename)
    ("S" dired-do-symlink)
    ("T" dired-do-touch)
    ("U" dired-unmark-all-marks)
    ("Z" dired-do-compress "compress")
    ("ç" ora-dired-up-directory "up-directory")
    ;; ("^" dired-up-directory "up-directory")
    ("a" dired-find-alternate-file "open folder")
    ("c" dired-do-compress-to "compress-to")
    ("d" dired-flag-file-deletion)
    ("p" dired-maybe-insert-subdir "maybe-insert-subdir") ;; was "i"
    ("j" dired-goto-file "goto-file")
    ("n" dired-do-kill-lines) ;; was "k"
    ("l" dired-do-redisplay)
    ;; ("o" dired-find-file-other-window)
    ("s" dired-sort-toggle-or-edit "sort-toggle-or-edit")
    ("t" dired-toggle-marks)
    ("v" dired-view-file)
    ("w" dired-copy-filename-as-kill)
    ("x" dired-do-flagged-delete)
    ("y" dired-show-file-type "show-file-type")
    ("o" dired-omit-mode "toggle show hide files")
    ("~" dired-flag-backup-files))

  (defhydra hydra-dired-mark (:color teal :columns 3 :hint nil
                                     :after-exit
                                     (if (eq major-mode 'dired-mode)
                                         (hydra-dired/body)))
    "Mark"
    ("SPC" nil)
    ("!" dired-unmark-all-marks  "unmark all")
    ("%" dired-mark-files-regexp "regexp")
    ("(" dired-mark-sexp         "sexp")
    ("*" dired-mark-executables  "executables")
    ("." dired-mark-extension    "extension")
    ("/" dired-mark-directories  "directories")
    ("?" dired-unmark-all-files  "unmark markchar")
    ("@" dired-mark-symlinks     "symlinks")
    ("O" dired-mark-omitted      "omitted")
    ("c" dired-change-marks      "change")
    ("s" dired-mark-subdir-files "subdir-files"))

  (defhydra hydra-dired-regexp (:color teal :columns 3 :hint nil
                                       :after-exit
                                       (if (eq major-mode 'dired-mode)
                                           (hydra-dired/body)))
    "Regexp"
    ("SPC" nil)
    ("&" dired-flag-garbage-files "flag-garbage-files")
    ("C" dired-do-copy-regexp "copy")
    ("H" dired-do-hardlink-regexp "hardlink")
    ("R" dired-do-rename-regexp "rename")
    ("S" dired-do-symlink-regexp "symlink")
    ("Y" dired-do-relsymlink-regexp "relsymlink")
    ("d" dired-flag-files-regexp "flag-files")
    ("g" dired-mark-files-containing-regexp "mark-containing")
    ("l" dired-downcase "downcase")
    ("m" dired-mark-files-regexp "mark")
    ("r" dired-do-rename-regexp "rename")
    ("u" dired-upcase "upcase"))
#+END_SRC

#+RESULTS:
: hydra-dired-regexp/body
**** TODO Counsel
#+begin_src elisp
  (defhydra isg--hydra-counsel (:exit t)
    "
               Counsel                                   (occur: C-c C-o)
               ----------------------------------------------------
               Grep  :  grep-or-_s_wiper  _p_roject-grep   _d_irectory-grep
          Open file  :  _g_it repo        _f_ind file       fu_z_zy find file (fzf)
               Org   :  _o_rg-goto        org-goto-_a_ll   agenda-_h_eader
                        org-_t_ag         cha_n_ge-tags    org-tag-ag_e_nda
               Misc  :  _w_eb search     _b_ookmark        _l_ocate   _c_olors
               "
    ;; ("r" (lambda () (interactive) (counsel-rg (format "%s" (or (thing-at-point 'symbol) "")))))
    ;; ("d" deadgrep)

    ;; ("c" counsel-grep)
    ("a" counsel-org-goto-all)
    ("b" counsel-bookmark)
    ("c" counsel-colors-emacs)
    ("d" counsel-ack)
    ("e" counsel-org-tag-agenda)
    ("f" counsel-find-file)
    ("g" counsel-projectile)
    ("h" counsel-org-agenda-headlines)
    ("l" counsel-locate)
    ("n" counsel-org-change-tags)
    ("o" counsel-org-goto)
    ("p" projectile-grep)
    ("s" counsel-grep-or-swiper)
    ("t" counsel-org-tag)
    ("w" counsel-search)   ;; counsel-google it is obsolete
    ("z" brust-hydra-fzf/body)
    ;; ("u" counsel-describe-function)
    ;; ("v" counsel-describe-variable)
    ;; ("l" counsel-find-library)
    ;; ("s" counsel-info-lookup-symbol)
    ("RET" nil "done" :color blue))

  (bind-keys ("C-c f" . isg--hydra-counsel/body)
             ("C-c z" . brust-hydra-fzf/body))
#+end_src

#+RESULTS:
: isg--hydra-counsel/body
**** fzf hydra
#+begin_src elisp
  (defhydra brust-hydra-fzf (:exit t)
    "
               Command-line Fuzzy Finder         (occur: C-c C-o)
               ----------------------------------------------------
               _c_urrent directory      _h_ome      _e_mascs.d
               _s_elect  directory      _d_ropbox
               _g_it-grep  : grep current git
               "
    ;; ("r" (lambda () (interactive) (counsel-rg (format "%s" (or (thing-at-point 'symbol) "")))))
    ;; ("d" deadgrep)

    ;; ("c" counsel-grep)
    ("c" counsel-fzf)
    ("d" brust-counsel-fzf-dropbox)
    ("e" brust-counsel-fzf-emacsd)
    ("g" fzf-git-grep)
    ("h" brust-counsel-fzf-home)
    ("s" brust-counsel-fzf-dir)
    ("RET" nil "done" :color blue))

  (defun brust-counsel-fzf-dir ()
    "fzf find file selecting a directory"
    (interactive)
    (counsel-fzf
     nil
     (read-directory-name "Directory: ")
     nil))

  (defun brust-counsel-fzf-home ()
    "fzf find file in home"
    (interactive)
    (counsel-fzf
     nil
     "~"
     nil))

  (defun brust-counsel-fzf-emacsd ()
    "fzf find file in home"
    (interactive)
    (counsel-fzf
     nil
     "~/.emacs.d"
     nil))

  (defun brust-counsel-fzf-dropbox ()
    "fzf find file in home"
    (interactive)
    (counsel-fzf
     nil
     "~/Dropbox"
     nil))

#+end_src

#+RESULTS:
: brust-counsel-fzf-dropbox

**** er/expand
#+BEGIN_SRC elisp
  (defhydra brust-hydra-expand (:body-pre (call-interactively 'er/expand-region) :hint nil)
    "
   _n_: ins math   _m_: out math _e_: environment
   _o_: ins pairs  _p_: out pairs
   _j_/_-_ more/less   _q_: quit
   "
    ("n" er/mark-LaTeX-inside-math)
    ("m" er/mark-LaTeX-math)
    ("e" er/mark-LaTeX-inside-environment)
    ("o" er/mark-inside-pairs)
    ("p" er/mark-outside-pairs)
    ("j" er/expand-region)
    ("-" er/contract-region)
    ;; ("j" er/expand-region :color red)
    ;; ("-" er/contract-region :color red)
    ("q" nil :color blue))

#+END_SRC

#+RESULTS:
: brust-hydra-expand/body
***** COMMENT Second expand
#+BEGIN_SRC elisp
  (defhydra hydra-mark (:body-pre (progn
                                    (call-interactively 'set-mark-command)
                                    (call-interactively 'er/expand-region)
                                    (setq hydra-is-helpful t))
                                  :post (setq hydra-is-helpful nil)
                                  :exit t
                                  :color blue)
    "hydra for mark commands"
    ;; ("" er/expand-region)
    ("a"  brust-smart-move-beginning-of-line)
    ("e"  brust-smart-move-end-of-line)
    ("<"  brust-toggle-begin&end-of-buffer)
    ("u"  backward-word)
    ("i"  previous-line)
    ("o"  forward-word)
    ("h"  recenter-top-bottom)
    ;;("s-h" . )
    ("j"  backward-char)
    ("k"  next-line)
    ("l"  forward-char)
    ("b"  sp-backward-sexp)
    ("f"  sp-forward-sexp)
    ("SPC" er/expand-region)
    ("n" er/mark-LaTeX-inside-math)
    ("m" er/mark-LaTeX-math)
    ("e" er/mark-LaTeX-inside-environment)
    ("p" er/mark-inside-pairs)
    ("vp" er/mark-outside-pairs)
    ;; ("j" er/expand-region)
    ;; ("-" er/contract-region)
    ;; ("ip" er/mark-inside-pairs)
    ("q" er/mark-inside-quotes)
    ("vq" er/mark-outside-quotes)
    ("d" er/mark-defun)
    ("c" er/mark-comment)
    ("." er/mark-text-sentence)
    ("h" er/mark-text-paragraph)
    ;; ("u" er/mark-url)
    ;; ("e" er/mark-email)
    ("s" er/mark-symbol)
    ;; ("j" (funcall 'set-mark-command '(4)) :exit nil)
    ;; ("k" (call-interactively 'pop-global-mark) :exit nil)
    ("gc" avy-goto-char-timer "goto word 1")
    ;; ("W" avy-goto-word-2 "goto word 2")
    ("gl" avy-goto-line "goto line"))

     (define-key global-map (kbd "C-SPC") #'hydra-mark/body)
#+END_SRC

#+RESULTS:
: hydra-mark/body

**** General setting
#+BEGIN_SRC elisp
  (use-package hydra
    :config
    (setq lv-use-separator t)
    :chords
    ("jj" . brust-hydra-expand/body)
    ("yy" . hydra-yank-pop/brust-org-yank-or-yank)
    :bind
    ("s-w" . words-hydra/body))


  ;; (bind-keys*
  ;; ("C-y" . hydra-yank-pop/brust-org-yank-or-yank)
  ;;("M-y" . hydra-yank-pop/yank-pop)

  ;;  (eval-after-load "buff-menu"
  ;;    '(bind-keys :map ibuffer-mode-map
  ;;		("." . hydra-ibuffer-main/body)))
  ;;
  ;; (eval-after-load "org"
  ;; '(bind-keys :map org-mode-map
  ;;   ("<" . brust-org<)))

  ;; (bind-keys :map dired-mode-map
  ;; ("y" . hydra-dired/body))

  ;; :chords
  ;; ("oo" . hydra-outline/body)
  ;; ("jf" . hydra-motion/body)
#+END_SRC

#+RESULTS:
: words-hydra/body

**** Ibuffer
#+BEGIN_SRC elisp
(defhydra hydra-ibuffer-main (:color pink :hint nil)
  "
 ^Navigation^ | ^Mark^        | ^Actions^        | ^View^
-^----------^-+-^----^--------+-^-------^--------+-^----^-------
  _i_:    ʌ   | _m_: mark     | _D_: delete      | _g_: refresh
 _RET_: visit | _u_: unmark   | _S_: save        | _s_: sort
  _k_:    v   | _*_: specific | _a_: all actions | _/_: filter
-^----------^-+-^----^--------+-^-------^--------+-^----^-------
"
  ("k" ibuffer-forward-line)
  ("RET" ibuffer-visit-buffer :color blue)
  ("i" ibuffer-backward-line)

  ("m" ibuffer-mark-forward)
  ("u" ibuffer-unmark-forward)
  ("*" hydra-ibuffer-mark/body :color blue)

  ("D" ibuffer-do-delete)
  ("S" ibuffer-do-save)
  ("a" hydra-ibuffer-action/body :color blue)

  ("g" ibuffer-update)
  ("s" hydra-ibuffer-sort/body :color blue)
  ("/" hydra-ibuffer-filter/body :color blue)

  ("o" ibuffer-visit-buffer-other-window "other window" :color blue)
  ("q" ibuffer-quit "quit ibuffer" :color blue)
  ("." nil "toggle hydra" :color blue))

(defhydra hydra-ibuffer-mark (:color teal :columns 5
                              :after-exit (hydra-ibuffer-main/body))
  "Mark"
  ("*" ibuffer-unmark-all "unmark all")
  ("M" ibuffer-mark-by-mode "mode")
  ("m" ibuffer-mark-modified-buffers "modified")
  ("u" ibuffer-mark-unsaved-buffers "unsaved")
  ("s" ibuffer-mark-special-buffers "special")
  ("r" ibuffer-mark-read-only-buffers "read-only")
  ("/" ibuffer-mark-dired-buffers "dired")
  ("e" ibuffer-mark-dissociated-buffers "dissociated")
  ("h" ibuffer-mark-help-buffers "help")
  ("z" ibuffer-mark-compressed-file-buffers "compressed")
  ("b" hydra-ibuffer-main/body "back" :color blue))

(defhydra hydra-ibuffer-action (:color teal :columns 4
                                :after-exit
                                (if (eq major-mode 'ibuffer-mode)
                                    (hydra-ibuffer-main/body)))
  "Action"
  ("A" ibuffer-do-view "view")
  ("E" ibuffer-do-eval "eval")
  ("F" ibuffer-do-shell-command-file "shell-command-file")
  ("I" ibuffer-do-query-replace-regexp "query-replace-regexp")
  ("H" ibuffer-do-view-other-frame "view-other-frame")
  ("N" ibuffer-do-shell-command-pipe-replace "shell-cmd-pipe-replace")
  ("M" ibuffer-do-toggle-modified "toggle-modified")
  ("O" ibuffer-do-occur "occur")
  ("P" ibuffer-do-print "print")
  ("Q" ibuffer-do-query-replace "query-replace")
  ("R" ibuffer-do-rename-uniquely "rename-uniquely")
  ("T" ibuffer-do-toggle-read-only "toggle-read-only")
  ("U" ibuffer-do-replace-regexp "replace-regexp")
  ("V" ibuffer-do-revert "revert")
  ("W" ibuffer-do-view-and-eval "view-and-eval")
  ("X" ibuffer-do-shell-command-pipe "shell-command-pipe")
  ("b" nil "back"))

(defhydra hydra-ibuffer-sort (:color amaranth :columns 3)
  "Sort"
  ("i" ibuffer-invert-sorting "invert")
  ("a" ibuffer-do-sort-by-alphabetic "alphabetic")
  ("v" ibuffer-do-sort-by-recency "recently used")
  ("s" ibuffer-do-sort-by-size "size")
  ("f" ibuffer-do-sort-by-filename/process "filename")
  ("m" ibuffer-do-sort-by-major-mode "mode")
  ("b" hydra-ibuffer-main/body "back" :color blue))

(defhydra hydra-ibuffer-filter (:color amaranth :columns 4)
  "Filter"
  ("m" ibuffer-filter-by-used-mode "mode")
  ("M" ibuffer-filter-by-derived-mode "derived mode")
  ("n" ibuffer-filter-by-name "name")
  ("c" ibuffer-filter-by-content "content")
  ("e" ibuffer-filter-by-predicate "predicate")
  ("f" ibuffer-filter-by-filename "filename")
  (">" ibuffer-filter-by-size-gt "size")
  ("<" ibuffer-filter-by-size-lt "size")
  ("/" ibuffer-filter-disable "disable")
  ("b" hydra-ibuffer-main/body "back" :color blue))
#+END_SRC

**** mu4e
#+begin_src elisp
(defhydra hydra-mu4e-headers (:color blue :hint nil)
  "
 ^General^   | ^Search^           | _!_: read    | _#_: deferred  | ^Switches^
-^^----------+-^^-----------------| _?_: unread  | _%_: pattern   |-^^------------------
_n_: next    | _s_: search        | _r_: refile  | _&_: custom    | _O_: sorting
_p_: prev    | _S_: edit prev qry | _u_: unmk    | _+_: flag      | _P_: threading
_]_: n unred | _/_: narrow search | _U_: unmk *  | _-_: unflag    | _Q_: full-search
_[_: p unred | _b_: search bkmk   | _d_: trash   | _T_: thr       | _V_: skip dups
_y_: sw view | _B_: edit bkmk     | _D_: delete  | _t_: subthr    | _W_: include-related
_R_: reply   | _{_: previous qry  | _m_: move    |-^^-------------+-^^------------------
_C_: compose | _}_: next query    | _a_: action  | _|_: thru shl  | _`_: update, reindex
_F_: forward | _C-+_: show more   | _A_: mk4actn | _H_: help      | _;_: context-switch
_o_: org-cap | _C--_: show less   | _*_: *thing  | _q_: quit hdrs | _j_: jump2maildir "

  ;; general
  ("n" mu4e-headers-next)
  ("p" mu4e-headers-previous)
  ("[" mu4e-select-next-unread)
  ("]" mu4e-select-previous-unread)
  ("y" mu4e-select-other-view)
  ("R" mu4e-compose-reply)
  ("C" mu4e-compose-new)
  ("F" mu4e-compose-forward)
  ("o" my/org-capture-mu4e)                  ; differs from built-in

  ;; search
  ("s" mu4e-headers-search)
  ("S" mu4e-headers-search-edit)
  ("/" mu4e-headers-search-narrow)
  ("b" mu4e-headers-search-bookmark)
  ("B" mu4e-headers-search-bookmark-edit)
  ("{" mu4e-headers-query-prev)              ; differs from built-in
  ("}" mu4e-headers-query-next)              ; differs from built-in
  ("C-+" mu4e-headers-split-view-grow)
  ("C--" mu4e-headers-split-view-shrink)

  ;; mark stuff
  ("!" mu4e-headers-mark-for-read)
  ("?" mu4e-headers-mark-for-unread)
  ("r" mu4e-headers-mark-for-refile)
  ("u" mu4e-headers-mark-for-unmark)
  ("U" mu4e-mark-unmark-all)
  ("d" mu4e-headers-mark-for-trash)
  ("D" mu4e-headers-mark-for-delete)
  ("m" mu4e-headers-mark-for-move)
  ("a" mu4e-headers-action)                  ; not really a mark per-se
  ("A" mu4e-headers-mark-for-action)         ; differs from built-in
  ("*" mu4e-headers-mark-for-something)

  ("#" mu4e-mark-resolve-deferred-marks)
  ("%" mu4e-headers-mark-pattern)
  ("&" mu4e-headers-mark-custom)
  ("+" mu4e-headers-mark-for-flag)
  ("-" mu4e-headers-mark-for-unflag)
  ("t" mu4e-headers-mark-subthread)
  ("T" mu4e-headers-mark-thread)

  ;; miscellany
  ("q" mu4e~headers-quit-buffer)
  ("H" mu4e-display-manual)
  ("|" mu4e-view-pipe)                       ; does not seem built-in any longer

  ;; switches
  ("O" mu4e-headers-change-sorting)
  ("P" mu4e-headers-toggle-threading)
  ("Q" mu4e-headers-toggle-full-search)
  ("V" mu4e-headers-toggle-skip-duplicates)
  ("W" mu4e-headers-toggle-include-related)

  ;; more miscellany
  ("`" mu4e-update-mail-and-index)           ; differs from built-in
  (";" mu4e-context-switch)
  ("j" mu4e~headers-jump-to-maildir)

  ("." nil))
#+end_src

#+RESULTS:
: hydra-mu4e-headers/body

**** Outline
***** Functions
****** COMMENT tab for org-mode and latex
#+BEGIN_SRC elisp
  (defun hydra-outline-tab-key nil
    (interactive)
    (or (and (string= major-mode "org-mode")
             (org-cycle))
        (and (save-excursion (describe-mode)
                             (search-forward "Cdlatex" nil t))
             (cl-member "cdlatex-mode" minor-mode-list)
             (cdlatex-tab))))
#+END_SRC

#+RESULTS:
: hydra-outline-tab-key

****** Auxiliar
#+BEGIN_SRC elisp
(defun outline-body-p nil
  (save-excursion
    (outline-back-to-heading)
    (outline-end-of-heading)
    (and (not (eobp))
         (progn (forward-char 1)
                (not (outline-on-heading-p))))))

(defun outline-body-visible-p nil
  (save-excursion
    (outline-back-to-heading)
    (outline-end-of-heading)
    (not (outline-invisible-p))))


(defun outline-subheadings-p nil
  (save-excursion
    (outline-back-to-heading)
    (let ((level (funcall outline-level)))
      (outline-next-heading)
      (and (not (eobp))
           (< level (funcall outline-level))))))

(defun outline-subheadings-visible-p nil
  (interactive)
  (save-excursion
    (outline-next-heading)
    (not (outline-invisible-p))))

#+END_SRC

****** Hide more
#+BEGIN_SRC elisp

(defun outline-hide-more nil
  (interactive)
  (when (outline-on-heading-p)
    (cond ((and (outline-body-p)
                (outline-body-visible-p))
           (outline-hide-entry)
           (outline-hide-leaves))
          (t
           (outline-hide-subtree)))))


#+END_SRC

****** Show more
#+BEGIN_SRC elisp
(defun outline-show-more nil
  (interactive)
  (when (outline-on-heading-p)
    (cond ((and (outline-subheadings-p)
                (not (outline-subheadings-visible-p)))
           (outline-show-children))
          ((and (not (outline-subheadings-p))
                (not (outline-body-visible-p)))
           (outline-show-subtree))
          ((and (outline-body-p)
                (not (outline-body-visible-p)))
           (outline-show-entry))
          (t
           (outline-show-subtree)))))

#+END_SRC
***** TODO COMMENT Hydra
#+BEGIN_SRC elisp
  (defhydra hydra-outline (:color red :hint nil)
    "
  ^        ^previous ^backward           _i_  _o_
  ^Up hide     ^next  ^forward ^show ^_h_  _j_  _k_  _l_ _ñ_
   _<tab>_ tab
  "
    ;; Hide
    ("j" outline-hide-more)
    ("ñ" outline-show-more)
    ("<tab>" hydra-outline-tab-key)
   ;;("q" hide-sublevels)    ; Hide everything but the top-level headings
   ;;("w" hide-body)         ; Hide everything but headings (all body lines)
   ;;("o" hide-other)        ; Hide other branches
   ;;("t" hide-entry)        ; Hide this entry's body
   ;;("r" hide-leaves)       ; Hide body lines in this entry and sub-entries
   ;;("e" hide-subtree)      ; Hide everything in this entry and sub-entries
   ;;;; Show
   ;;("a" show-all)          ; Show (expand) everything
   ;;("g" show-entry)        ; Show this heading's body
   ;;("s" show-children)     ; Show this heading's immediate child sub-headings
   ;;("f" show-branches)     ; Show all sub-headings under this heading
   ;;("d" show-subtree)      ; Show (expand) everything in this heading & below
    ;; Move
    ("h" outline-up-heading)                ; Up
    ("k" outline-next-visible-heading)      ; Next
    ("i" outline-previous-visible-heading)  ; Previous
    ("l" outline-forward-same-level)        ; Forward - same level
    ("o" outline-backward-same-level)       ; Backward - same level
    ("q" nil "leave")
    ("z" nil "leave"))

  ;; (global-set-key (kbd "C-o") 'hydra-outline/body) ; by example
#+END_SRC

#+RESULTS:
: hydra-outline/body

**** Org block template
     https://github.com/abo-abo/hydra/wiki/Org-mode-block-templates
***** Hydra
#+BEGIN_SRC elisp
  (defhydra hydra-org-block-template (:color blue :hint nil)
    "
     _c_enter  _q_uote     _e_macs-lisp    _L_aTeX:
     _l_atex   _E_xample   _j_ulia         _i_ndex:
     _a_scii   _v_erse     _P_erl tangled  _I_NCLUDE:
     _s_rc     _n_ote      _p_erl          _H_TML:
     _h_tml    _b_ash      plant_u_ml      _A_SCII:
    "
    ("s" (hot-expand "src"))
    ("E" (hot-expand "example"))
    ("q" (hot-expand "quote"))
    ("v" (hot-expand "<v"))
    ("n" (hot-expand "note"))
    ("c" (hot-expand "center"))
    ("l" (hot-expand "export latex"))
    ("h" (hot-expand "export html"))
    ("a" (hot-expand "export ascii"))
    ("L" (hot-expand "LaTeX"))
    ("i" (hot-expand "index"))
    ("e" (hot-expand "src" "elisp"))
    ("j" (hot-expand "src" "julia :session *julia*"))
    ("b" (hot-expand "src" "bash"))
    ("p" (hot-expand "src" "perl"))
    ("u" (hot-expand "src" "plantuml :file CHANGE.png"))
    ("P" (hot-expand "src" "perl" ":results output :exports both :shebang \"#!/usr/bin/env perl\""))
    ("I" (hot-expand "INCLUDE"))
    ("H" (hot-expand "HTML"))
    ("A" (hot-expand "ASCII"))
    ("<" self-insert-command "ins")
    ("o" nil "quit"))
#+END_SRC

#+RESULTS:
: hydra-org-block-template/body

***** Hot expand defun
#+BEGIN_SRC elisp
  (defun hot-expand (str &optional mod header)
    "Expand org block template.

    STR is a structure template string recognised by org like <s. MOD is a
    string with additional parameters to add the begin line of the
    structure element. HEADER string includes more parameters that are
    prepended to the element after the #+HEADERS: tag."
    (let ((-str (if mod (concat str " " mod) str)))
      (if (region-active-p)
          (let ((-str-region (buffer-substring (region-beginning) (region-end))))
            (when header
              (delete-region (region-beginning) (region-end))
              (deactivate-mark)
              (insert "#+HEADERS: " header "\n")
              (push-mark)
              (activate-mark t)
              (insert -str-region))
            (org-insert-structure-template -str))
        (when header (insert "#+HEADERS: " header "\n"))
        (org-insert-structure-template -str)
        (insert "\n")
        (backward-char 1))))

  ;; (setq org-structure-template-alist (eval (car (get 'org-structure-template-alist 'standard-value))))
  ;; (require 'org-tempo) ; Required from org 9 onwards for old template expansion
  ;; Reset the org-template expnsion system, this is need after upgrading to org 9 for some reason

  (defun brust-org< nil
    "Self insert command or expand hydra of org block templates
  at the beginning of a line
  or with region active."
    (interactive)
    (if (or (region-active-p) (looking-back "^"))
        (hydra-org-block-template/body)
      (self-insert-command 1)))
#+END_SRC

#+RESULTS:
: brust-org<

**** PdfTools
#+begin_src elisp
(defhydra hydra-pdftools (:color blue :hint nil)
        "
   ╭────────────┐
   │ PDF Tools │^ ^    ^ ^  ^ ^  Annotations  Search/Link   Do
   ╭────────────────────────────────────────────────────────────┐
    History:  ↑ _B_ ↓ _N_ ^ ^    [_al_] list    [_s_] search    [_u_] revert buffer
    Go to page: [_e_] ^ ^ ^ ^    [_am_] markup  [_o_] outline   [_i_] info
    Scale reset: [_0_] ^ ^ ^ ^   [_at_] text    [_F_] link      [_d_] dark mode
    Fit: [_P_], _H_ight, _W_idth [_ad_] delete  [_f_] search link

   --------------------------------------------------------------------------------
        "
        ;; ("\\" hydra-master/body "back")
        ;; ("<ESC>" nil "quit")
        ("al" pdf-annot-list-annotations)
        ("ad" pdf-annot-delete)
        ;; ("aa" pdf-annot-attachment-dired)
        ("am" pdf-annot-add-markup-annotation)
        ("at" pdf-annot-add-text-annotation)
        ;; ("y"  pdf-view-kill-ring-save)
        ("0" pdf-view-scale-reset)
        ("H" pdf-view-fit-height-to-window)
        ("W" pdf-view-fit-width-to-window)
        ("P" pdf-view-fit-page-to-window)
        ("d" pdf-view-dark-minor-mode)
        ;; ("b" pdf-view-set-slice-from-bounding-box)
        ;; ("r" pdf-view-reset-slice)
        ("e" pdf-view-goto-page)
        ("o" pdf-outline)
        ("s" pdf-occur)
        ("i" pdf-misc-display-metadata)
        ("u" pdf-view-revert-buffer)
        ("F" pdf-links-action-perfom)
        ("f" pdf-links-isearch-link)
        ("B" pdf-history-backward :color red)
        ("N" pdf-history-forward :color red)
        ("l" image-forward-hscroll :color red)
        ("h" image-backward-hscroll :color red))
#+end_src

#+RESULTS:
: hydra-pdftools/body

**** Projectile
#+BEGIN_SRC elisp
(defhydra hydra-projectile (:color teal
                            :hint nil)
  "
     PROJECTILE: %(projectile-project-root)

     Find File            Search/Tags          Buffers                Cache
------------------------------------------------------------------------------------------
_s-f_: file            _a_: ag                _i_: Ibuffer           _c_: cache clear
 _ff_: file dwim       _g_: update gtags      _b_: switch to buffer  _x_: remove known project
 _fd_: file curr dir   _o_: multi-occur     _s-k_: Kill all buffers  _X_: cleanup non-existing
  _r_: recent file                                               ^^^^_z_: cache current
  _d_: dir

"
  ("a"   projectile-ag)
  ("b"   projectile-switch-to-buffer)
  ("c"   projectile-invalidate-cache)
  ("d"   projectile-find-dir)
  ("s-f" projectile-find-file)
  ("ff"  projectile-find-file-dwim)
  ("fd"  projectile-find-file-in-directory)
  ("g"   ggtags-update-tags)
  ("s-g" ggtags-update-tags)
  ("i"   projectile-ibuffer)
  ("K"   projectile-kill-buffers)
  ("s-k" projectile-kill-buffers)
  ("m"   projectile-multi-occur)
  ("o"   projectile-multi-occur)
  ("s-p" projectile-switch-project "switch project")
  ("p"   projectile-switch-project)
  ("s"   projectile-switch-project)
  ("r"   projectile-recentf)
  ("x"   projectile-remove-known-project)
  ("X"   projectile-cleanup-known-projects)
  ("z"   projectile-cache-current-file)
  ("`"   hydra-projectile-other-window/body "other window")
  ("q"   nil "cancel" :color blue))
#+END_SRC

**** Tweeter
#+begin_src elisp
(defhydra hydra-twittering (:color blue :hint nil)
        "
                                                                    ╭────────────┐
     Tweets                User                        Timeline     │ Twittering │
  ╭─────────────────────────────────────────────────────────────────┴────────────╯
    _k_  [_t_] post tweet      _p_  [_f_] follow                  ^_g_^      [_u_] update
    ^↑^  [_X_] delete tweet    ^↑^  [_F_] unfollow              ^_S-SPC_^    [_._] new
    ^ ^  [_r_] retweet         ^ ^  [_d_] direct message          ^^↑^^      [^@^] current user
    ^↓^  [_R_] retweet & edit  ^↓^  [_i_] profile (browser)   _h_ ←   → _l_  [_a_] toggle
    _j_  [_b_] favorite        _n_   ^ ^                          ^^↓^^
    ^ ^  [_B_] unfavorite      ^ ^   ^ ^                         ^_SPC_^
    ^ ^  [_RET_] reply         ^ ^   ^ ^                          ^_G_^
    ^ ^  [_T_] show Thread
    ^ ^  [_y_] yank url          Items                     Do
    ^ ^  [_Y_] yank tweet     ╭───────────────────────────────────────────────────────
    ^ ^  [_e_] edit mode        _<backtab>_ ← _o_pen → _<tab>_    [_q_] exit
    ^ ^   ^ ^                   ^         ^   ^ ^      ^     ^    [_/_] search
  --------------------------------------------------------------------------------
       "
       ("\\" hydra-master/body "back")
       ("<ESC>" nil "quit")
       ("q"          twittering-kill-buffer)
       ("e"          twittering-edit-mode)
       ("j"          twittering-goto-next-status :color red)
       ("k"          twittering-goto-previous-status :color red)
       ("h"          twittering-switch-to-next-timeline :color red)
       ("l"          twittering-switch-to-previous-timeline :color red)
       ("g"          beginning-of-buffer)
       ("G"          end-of-buffer)
       ("t"          twittering-update-status-interactive)
       ("X"          twittering-delete-status)
       ("RET"        twittering-reply-to-user)
       ("r"          twittering-native-retweet)
       ("R"          twittering-organic-retweet)
       ("d"          twittering-direct-message)
       ("u"          twittering-current-timeline)
       ("b"          twittering-favorite)
       ("B"          twittering-unfavorite)
       ("f"          twittering-follow)
       ("F"          twittering-unfollow)
       ("i"          twittering-view-user-page)
       ("/"          twittering-search)
       ("."          twittering-visit-timeline)
       ("@"          twittering-other-user-timeline)
       ("T"          twittering-toggle-or-retrieve-replied-statuses)
       ("o"          twittering-click)
       ("<tab>"        twittering-goto-next-thing :color red)
       ("<backtab>"  twittering-goto-previous-thing :color red)
       ("n"          twittering-goto-next-status-of-user :color red)
       ("p"          twittering-goto-previous-status-of-user :color red)
       ("SPC"        twittering-scroll-up :color red)
       ("S-SPC"      twittering-scroll-down :color red)
       ("y"          twittering-push-uri-onto-kill-ring)
       ("Y"          twittering-push-tweet-onto-kill-ring)
       ("a"          twittering-toggle-activate-buffer))
#+end_src

#+RESULTS:
: hydra-twittering/body

**** Yank hydra
#+BEGIN_SRC elisp
  (defhydra hydra-yank-pop ()
    "yank"
    ("C-y" brust-org-yank-or-yank nil)
    ("M-y" yank-pop nil)
    ("y" (yank-pop 1) "prev")
    ("u" (yank-pop -1) "next")
    ("t" helm-show-kill-ring "list" :color blue))

  (put 'hydra-yank-pop/brust-org-yank-or-yank 'delete-selection t)
#+END_SRC

***** org-yank or yank
#+BEGIN_SRC elisp
  (defun brust-org-yank-or-yank nil
    (interactive)
    (if (string= major-mode "org-mode") (org-yank) (yank)))
#+END_SRC

*** Ibuffer
#+BEGIN_SRC elisp
  (use-package ibuffer
    :commands (ibuffer)
    :init
    (defalias 'list-buffers 'ibuffer) ; make ibuffer default
    :config
    (use-package ibuffer-vc)
    (setq ibuffer-default-sorting-mode 'major-mode
          ibuffer-expert t
          ibuffer-display-summary t
          ibuffer-show-empty-filter-groups nil
          ibuffer-vc-skip-if-remote t
          ibuffer-filter-group-name-face 'font-lock-doc-face

          ibuffer-saved-filter-groups
          '(("dired" (or (mode . dired-mode) (mode . sr-mode)))
            ("erc" (mode . erc-mode))
            ("planner" (or (name . "^\\*Calendar\\*$") (name . "^diary$") (mode . muse-mode)))
            ("emacs" (or (name . "^\\*scratch\\*$") (name . "^\\*Messages\\*$")))
            ("Help" (or (name . "^\\*Help\\*$") (mode . help-mode)))))


    (defun brust-ibuffer-apply-filter-groups nil
      "Combine my saved ibuffer filter groups with those generated
       by `ibuffer-vc-generate-filter-groups-by-vc-root' (I don't know its origine)"
      (interactive)
      (setq ibuffer-filter-groups
            (append
             ibuffer-saved-filter-groups
             (ibuffer-vc-generate-filter-groups-by-vc-root)
             ibuffer-filter-groups))
      (message "ibuffer-vc: groups set")
      (let ((ibuf (get-buffer "*Ibuffer*")))
        (when ibuf
          (with-current-buffer ibuf
            (pop-to-buffer ibuf)
            (ibuffer-update nil t)))))

    (add-hook 'ibuffer-hook #'brust-ibuffer-apply-filter-groups)
    (add-hook 'ibuffer-hook #'hydra-ibuffer-main/body)

    (define-ibuffer-column lines-h
      (:name "nºLines" :inline t)
      ;;(set-buffer (buffer))
      (let ((n (line-number-at-pos (point-max))))
        (cond
         ((> n 1000000) (format "%7.1fM" (/ n 1000000.0)))
         ((> n 1000) (format "%7.1fk" (/ n 1000.0)))
         ;;((> n 100) (format "%7.1fh" (/ n 100.0)))
         (t (format "%8d" n)))))

    (setq ibuffer-formats
          ;; Modify the default ibuffer-formats (toggle with `)
          '((mark modified read-only vc-status-mini " "
                  (name 30 30 :left :elide)
                  " "
                  (lines-h 9 -1 :right)
                  " "
                  (mode 16 16 :left :elide)
                  " "
                  (vc-status 16 16 :left)
                  " "
                  filename-and-process)
            (mark " " (name 16 -1) " " filename)))

    ;; Switching to ibuffer puts the cursor on the most recent buffer
    (defadvice ibuffer (around ibuffer-point-to-most-recent activate) ()
               "Open ibuffer with cursor pointed to most recent buffer name"
               (let ((recent-buffer-name (buffer-name)))
                 ad-do-it
                 (ibuffer-jump-to-buffer recent-buffer-name))))

#+END_SRC

#+RESULTS:
: t

*** COMMENT Interleave
#+BEGIN_SRC elisp
  (use-package interleave
    :config
    (setq interleave-org-notes-dir-list (quote ("~/Dropbox/bibliography/notes.org"))
          ;; interleave-sort-order (quote desc)
          )
    :bind
    (:map interleave-pdf-mode-map
          ("i" . brust-pdf-view-previous-line-or-previous-page-5)
          ("a" . interleave-add-note)))

#+END_SRC

#+RESULTS:
: interleave-add-note

*** Julia mode
#+BEGIN_SRC elisp
  (when (file-exists-p "~/.emacs.d/lisp/julia-emacs/julia-mode.el")
    (require 'julia-mode))
  ;;    (when (file-exists-p "~/scr/julia/julia")
  ;;      ;; (setq julia-program "~/scr/julia/julia")
  ;;      (setq julia-program "~/scr/julia-1.0.3/bin/julia")
  ;;      )
  ;; (when (file-exists-p "~/.emacs.d/lisp/julia-repl/julia-repl.el")
  ;;   (require 'julia-repl)
  ;;   (add-hook 'julia-mode-hook 'julia-repl-mode) ;; always use minor mode
  ;;   (setq julia-repl-executable-records
  ;;         '((compiled "/home/lazycat/scr/julia-1.0.3/bin/julia")))                 ;; compiled from the repository
  ;;   (add-hook 'julia-repl-hook #'julia-repl-use-emacsclient))
#+END_SRC

#+RESULTS:
: ~/scr/julia-1.0.3/bin/julia
*** Key-frequency
#+BEGIN_SRC elisp
  (when (file-exists-p "~/.emacs.d/lisp/keyfreq/keyfreq.el")
    (require 'keyfreq)
    (keyfreq-mode 1)
    (keyfreq-autosave-mode 1))
#+END_SRC

#+RESULTS:

*** Ledgers
    Mainly from [[https://www.reddit.com/r/emacs/comments/8x4xtt/tip_how_i_use_ledger_to_track_my_money/][Reddit discution]]
**** Main config
#+BEGIN_SRC elisp
  (use-package ledger-mode
    :mode ("\\.dat\\'"
           "\\.ledger\\'")
    :custom
    (ledger-clear-whole-transactions t)
    (add-hook 'ledger-mode-hook #'ledger-flymake-enable)
    (add-hook 'ledger-mode-hook #'company-mode)
    (ledger-post-auto-adjust-amounts t)
    :bind
    (:map ledger-mode-map
          ("C-c C-a" . brust-ledger-add-transaction)))

  (with-eval-after-load 'ledger-mode
    (define-key ledger-mode-map [remap save-buffer] #'std::ledger::save))
#+END_SRC

#+RESULTS:
: std::ledger::save

**** MyFuns
#+BEGIN_SRC elisp
  (defun brust-ledger-add-transaction (&optional -date)
    "Add new transaction using `org-read-date'"
    (interactive)
    (ledger-add-transaction
     (or -date (org-read-date))
     nil)
    (insert "?\n    Assets:DebitCard")
    (cdlatex-position-cursor))

  (defun std::ledger::save nil
    "First `ledger-mode-clean-buffer', then `save-buffer'."
    (interactive)
    (save-excursion
      (when (buffer-modified-p)
        (with-demoted-errors (ledger-mode-clean-buffer))
        (save-buffer))))

  (defun brust-ledger-copy-transaction-from-extract nil
    "`-string' is a line of my bank extract in cvs format"
    (interactive)
    (let ((-entry
           (split-string
            (buffer-substring-no-properties (point-at-bol) (point-at-eol))
            "\,")))
      (switch-to-buffer "ledger-2018.dat")
      (brust-ledger-add-transaction
       (brust-from-eur-ame-date (nth 0 -entry)))
      (insert (capitalize (nth 1 -entry))
              "\n    ?  €"
              (nth 3 -entry))
      (cdlatex-position-cursor)))


  (defun brust-from-eur-ame-date (-date)
    (let ((-new-date (split-string -date "/")))
      (concat (nth 2 -new-date)
              "-"
              (nth 1 -new-date)
              "-"
              (nth 0 -new-date))))
#+END_SRC

#+RESULTS:
: std::ledger::save

*** TODO Magit
    For a git and github integration with emacs!
#+BEGIN_SRC elisp
  (use-package magit
    :bind ("<f10>" . magit-status)
    :init
    (setq ;; magit-completing-read-function #'helm--completing-read-default
     magit-turn-on-auto-revert-mode nil
     magit-set-upstream-on-push 'dontask
     magit-completing-read-function 'ivy-completing-read
     magit-display-buffer-function 'magit-display-buffer-fullframe-status-v1
     magit-save-repository-buffers 'dontask
     magit-diff-paint-whitespace t
     magit-diff-refine-ignore-whitespace nil
     magit-diff-refine-hunk t)

    :config
    (add-hook 'magit-log-edit-mode-hook #'turn-on-flyspell)
    (add-hook 'git-commit-mode-hook #'turn-on-flyspell))
  ;; (use-package magit-gh-pulls
  ;;   :after magit
  ;;   :init (add-hook 'magit-mode-hook 'turn-on-magit-gh-pulls)
  ;;   :config
  ;;   ;; work around https://github.com/sigma/magit-gh-pulls/issues/83
  ;;   (setq magit-gh-pulls-pull-detail-limit 50))
#+END_SRC

#+RESULTS:
: magit-status

*** Mic parent
    To show matching paren on minibuffer when it is offscreen
#+BEGIN_SRC elisp
  (use-package mic-paren
    :init
    (setq paren-sexp-mode nil
          paren-highlight-offscreen t
          paren-delay 0.5
          paren-match-face 'show-paren-match
          paren-mismatch-face 'show-paren-mismatch
          paren-no-match-face 'show-paren-mismatch)
    (show-paren-mode 0)
    (paren-activate) ; activating
    ;; To could see the matching parent.
    (remove-hook 'post-command-hook 'eldoc-schedule-timer))
#+END_SRC

*** TODO Mu4e
    - Manual [[https://www.djcbsoftware.nl/code/mu/mu4e/index.html#Top][Mu4e's online manual]]
    - TODOs [0/6]
      - [ ] Install [[https://github.com/iqbalansari/mu4e-alert][mu4e alerts]]
      - [ ] Improve keybinding
      - [ ] Show links
      - [ ] Show images
      - [ ] Check autopudate (related to point one).
      - [ ] Improve contact completion with ivy :) [[http://pragmaticemacs.com/emacs/even-better-email-contact-completion-in-mu4e/]]
    - Helpful places [5/9]
      - [X] [[https://webgefrickel.de/blog/a-modern-mutt-setup][A modern mutt setup with neomutt, mbsync, msmtp and mu]] (blog - interesting not just emacs)
      - [ ] [[http://cachestocaches.com/2017/3/complete-guide-email-emacs-using-mu-and-][A Complete Guide to Email in Emacs using Mu and Mu4e]] (blog interesting by itself - really fancy emacs stuff)
      - [ ] [[https://www.djcbsoftware.nl/code/mu/mu4e/Example-configurations.html#Example-configurations][Example config (from mu4e the manual)]]
      - [ ] [[http://xenodium.com/#trying-out-mu4e-and-offlineimap][Albaro]] & [[http://xenodium.com/#trying-out-mu4e-with-mbsync][Albaro2]] (here there are many nice links) (blog - interesting not just emacs).
      - [X] [[https://stackoverflow.com/questions/50199837/mu4e-with-msmtp-does-not-store-mail-sent-directory-after-sending-mails][How to config mu4e to send mail using msmtp]]
      - [X] [[https://blog.programster.org/ubuntu-install-gpg-2][Install gpg2 (much better)]] to encript your mail password (echo password | gpg2 -c) then delete the corresponding line on bash history ;)
      - [ ] [[http://pragmaticemacs.com/mu4e-tutorials/][mu4e tutorials (form pragmatic emacs)]]
      - [X] [[https://wiki.archlinux.org/index.php/msmtp][Archlnux msmpt config page]]
      - [X] [[https://wiki.archlinux.org/index.php/Isync#Troubleshooting][Archlinux mbsync config page]]
      -
**** COMMENT Install
 Just in case to generate a certificate:
 # openssl s_client -connect mail.mat.uab.cat:993 -showcerts 2>&1 < /dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' | sed -ne '1,/-END CERTIFICATE-/p' > ~/mail.uab.cat.ctr

 #+BEGIN_SRC bash
   # Install things
   sudo apt install msmtp-gnome msmtp-mta isync gnupg2
   cd src
   git clone https://github.com/djcb/mu.git
   ./autogen.sh
   make

   # Paswords
   ## UAB
   cd
   echo PASSWORD > .mathuab
   gpg2 -c .mathuab
   rm .mathuab
   ## Gmail
   echo PASSWORD > .gmailpass
   gpg2 -c .gmailpass
   rm .gmailpass
   # Delete corresponding lines of .bash_history

   mkdir Maildir
   # Copy from Dropbox/config/Maildir
 #+END_SRC

 #+RESULTS:
**** Add Path
 #+BEGIN_SRC elisp
   (add-to-list 'load-path (expand-file-name "~/scr/mu/mu4e"))
   (require 'mu4e)
 #+END_SRC

 #+RESULTS:
 : mu4e
**** Basic config
  #+BEGIN_SRC elisp
    (use-package mu4e
      :ensure nil
      :config
      ;; use imagemagick, if available
      (when (fboundp 'imagemagick-register-types)
        (imagemagick-register-types))

      (setq mu4e-get-mail-command "mbsync -Va"
            ;; This allows me to use 'helm' to select mailboxes
            ;; mu4e-completing-read-function 'completing-read
            mu4e-completing-read-function 'ivy-completing-read
            ;; Enable notifications
            mu4e-enable-notifications t
            mail-user-agent 'mu4e-user-agent
            ;; Use "P" to toggle threading
            mu4e-headers-show-threads nil
            ;; If you want to exclude your own e-mail address when “replying to all”
            mu4e-compose-dont-reply-to-self t
            mu4e-view-show-addresses t
            ;; use 'fancy' non-ascii characters in various places in mu4e
            mu4e-use-fancy-chars t
            ;; attempt to show images when viewing messages
            mu4e-view-show-images t
            ;; save attachment to my Downloads (this can also be a function)
            mu4e-attachment-dir (expand-file-name "~/Downloads/")
            ;; when search include related msg to the one matching the query.
            mu4e-headers-include-related nil
            ;; enable inline images
            mu4e-maildir (expand-file-name "~/Maildir")
            mu4e-mu-binary (expand-file-name "~/scr/mu/mu/mu")
            ;; mu4e-mu-home
            mu4e-html2text-command "w3m -dump -T text/html -cols 72 -o display_link_number=true -o auto_image=false -o display_image=false -o ignore_null_img_alt=true"
            ;; mu4e-html2text-command "w3m -T text/html"
            ;; alternatively "textutil -stdin -format html -convert txt -stdout"
            mu4e-show-images t
            ;; Set format=flowed
            ;; mu4e sets up visual-line-mode and also fill (M-q) to do the right thing
            ;; each paragraph is a single long line; at sending, emacs will add the
            ;; special line continuation characters.
            mu4e-compose-format-flowed t
            ;; mu4e-maildir-shortcuts
            ;; '(;; ("/archive"     . ?a)
            ;;   ("/Inbox"       . ?i)
            ;;   ;; ("/work"        . ?w)
            ;;   ("/Sent"        . ?s))
            mu4e-user-mail-address-list `(,user-mail-address
                                          "brust@mat.uab.cat"
                                          )
            ;; mu4e-compose-signature "Foo X. Bar\nhttp://www.example.com\n"
            mu4e-compose-context-policy 'always-ask
            ;; Why would I want to leave my message open after I've sent it?
            message-kill-buffer-on-exit t
            ;; Don't ask for a 'context' upon opening mu4e
            mu4e-context-policy 'pick-first
            ;; Don't ask to quit... why is this the default?
            mu4e-confirm-quit nil
            mu4e-change-filenames-when-moving t
            ;; customize the reply-quote-string
            message-citation-line-format "On %a %d %b %Y at %R, %f wrote:\n"
            ;; choose to use the formatted string
            message-citation-line-function 'message-insert-formatted-citation-line
            message-send-mail-function 'message-send-mail-with-sendmail
            message-sendmail-extra-arguments '("--read-envelope-from")
            message-sendmail-f-is-evil 't
            sendmail-program "msmtp"
            mu4e-update-interval (* 5 60)    ;; update every 5 minutes
            mu4e-index-update-in-background t
            ;; to speed-up indexing
            mu4e-index-cleanup nil      ;; don't do a full cleanup check
            mu4e-index-lazy-check t     ;; don't consider up-to-dated dirs
            ;; Split windows vertically
            mu4e-split-view 'vertical
            )
      :bind
      ("<f9>" . mu4e)
      (:map mu4e-headers-mode-map
            ("k" . mu4e-headers-next)
            ("i" . mu4e-headers-prev)
            ("." . hydra-mu4e-headers/body) ; This hydra is for headers mode

            ("{" . mu4e-headers-query-prev)             ; differs from built-in
            ("}" . mu4e-headers-query-next)             ; differs from built-in
            ("o" . my/org-capture-mu4e)                 ; differs from built-in

            ("A" . mu4e-headers-mark-for-action)        ; differs from built-in

            ;; ("`" . mu4e-update-mail-and-index)          ; differs from built-in
            ("|" . mu4e-view-pipe)               	     ; does not seem to be built in any longer
            ;; ("." . hydra-mu4e-headers/body)
            ))
  #+END_SRC

  #+RESULTS:
  : mu4e-view-pipe

**** Handy hooks
 #+begin_src elisp
   (defun brust-mu4e-compose-mode-hook nil
     (flyspell-mode 1)
     ;; (auto-save-mode -1)
     (set-fill-column 72)
     ;; (brust-mu4e-add-headers)
     (message-add-header (concat "Date: " (message-make-date)))
     (message-add-header (concat "Message-ID: " (message-make-message-id)))
     (message-insert-headers)
     ;; (message-hide-headers)
     ;; This does not work, since while creating buffer mu4e-compose-type is set to nil.
     ;; (if (eq mu4e-compose-type 'new)
     ;;     (message-goto-to)
     ;;   (message-goto-body))
     )

   ;; (defun mu4e-compose-new nil
   ;;   "Start writing a new message."
   ;;   (interactive)
   ;;   (mu4e-compose 'new)
   ;;   (message-goto-to))
   ;;
   ;; (defun mu4e-compose-edit nil
   ;;   "Edit the draft message at point in the headers buffer.
   ;; This is only possible if the message at point is, in fact, a
   ;; draft message."
   ;;   (interactive)
   ;;   (mu4e-compose 'edit)
   ;;   (message-sort-headers)
   ;;   (message-goto-body))

   (defadvice mu4e-compose (after move-to-right-place activate)
     (if (eq compose-type 'new)
         (message-goto-to)
       ;; (message-sort-headers)
       (message-goto-body)))

   ;; (add-hook 'mu4e-view-mode-hook #'mu4e-view-fill-long-lines)
   (add-hook 'mu4e-view-mode-hook #'visual-line-mode)
   (add-hook 'mu4e-compose-mode-hook #'brust-mu4e-compose-mode-hook)

   ;; From Ben Maughan: Get some Org functionality in compose buffer
   ;; (add-hook 'message-mode-hook 'turn-on-orgtbl)
   ;; (add-hook 'message-mode-hook 'turn-on-orgstruct++)
 #+end_src

 #+RESULTS:
 | brust-mu4e-compose-mode-hook |
**** Dealing with drafts
 #+begin_src elisp
 (defun brust-mu4e-add-draft-headers nil
   "Add headers on composing an email"
   (message-add-header "Flags: draft")
   ;; (message-add-header (concat "X-Mailer: mu4e " mu4e-mu-version "; emacs " emacs-version "\n"))
   (message-add-header (concat "Maildir: " mu4e-drafts-folder)))

 (defun brust-mu4e-delete-draft-headers nil
   "Remove headers on composing an email"
   (message-cleanup-headers)
   (message-remove-header "Flags")
   (message-remove-header "Maildir"))


   (defadvice message-dont-send (before add-draft-headers activate)
     (brust-mu4e-add-draft-headers))

   (add-hook 'message-send-hook #'brust-mu4e-delete-draft-headers)
 #+end_src

 #+RESULTS:
 | brust-mu4e-delete-draft-headers |
**** Actions
***** View (inside an email)
 #+begin_src elisp
   (defun brust-mu4e-search-for-sender (msg)
     "Search for messages sent by the sender of the message at point."
     (mu4e-headers-search
      (concat "from:" (cdar (mu4e-message-field msg :from)))))

   (setq mu4e-view-actions
         (append mu4e-view-actions
                 (list
                  ;; define 'x' as the shortcut
                  (cons "xsearch for sender" 'brust-mu4e-search-for-sender)
                  ;; Difine 'V' as the shortcut
                  (cons "ViewInBrowser" 'mu4e-action-view-in-browser)
                  ;; Store an org link to insert later
                  (cons "lStore Link" 'org-store-link))))
 #+end_src

 #+RESULTS:
 : ((capture message . mu4e-action-capture-message) (view as pdf . mu4e-action-view-as-pdf) (show this thread . mu4e-action-show-thread) (xsearch for sender . brust-mu4e-search-for-sender) (ViewInBrowser . mu4e-action-view-in-browser) (Rebuild . brust-mu4e-rebuild-index) (lStore Link . org-store-link) (xsearch for sender . brust-mu4e-search-for-sender) (ViewInBrowser . mu4e-action-view-in-browser) (lStore Link . org-store-link))
**** Hack to edit main menu
#+begin_src elisp
  (defun brust-mu4e-rebuild-index nil
    (interactive)
    (mu4e~proc-kill)
    (sit-for 0) ;; to efectively kill the proces
    (let ((display-buffer-alist (cons t 'display-buffer-no-window))) ;; to not display the buffer
      (async-shell-command "~/scr/mu/mu/mu index --rebuild" nil)))

  (defun brust-mu4e-full-index nil
    (interactive)
    (let ((mu4e-index-cleanup t)      ;; don't do a full cleanup check
          (mu4e-index-lazy-check nil)) ;; don't consider up-to-dated dirs
      (mu4e-update-mail-and-index nil)))

  ;; (setq mu4e-headers-actions
  ;;       (append mu4e-headers-actions
  ;;               (list
  ;;                ;; Rebuild the whole date base
  ;;                (cons "Rebuild" 'brust-mu4e-rebuild-index))))

  (define-key mu4e-main-mode-map (kbd "R") #'brust-mu4e-rebuild-index)
  (define-key mu4e-main-mode-map (kbd "F") #'brust-mu4e-full-index)
  (define-key mu4e-main-mode-map (kbd "m") #'brust-inbox-update-mode-line-string)

  (defadvice mu4e~main-view (after add-my-keys activate)
    (read-only-mode -1)
    (goto-char (point-max))
    (insert
     "\n\n"
     (propertize "  Mines [Hard adviced]\n\n" 'face 'mu4e-title-face)
     (mu4e~main-action-str "\t* [R]ebuild index\n" 'brust-mu4e-rebuild-index)
     (mu4e~main-action-str "\t* [F]ull index\n" 'brust-mu4e-full-index)
     (mu4e~main-action-str "\t* [m]ode line stirng\n" 'brust-inbox-update-mode-line-string))
    (read-only-mode 1)
    (goto-char (point-min)))
#+end_src

#+RESULTS:
: mu4e~main-view
**** Marks
#+begin_src elisp
    ;; As an example, suppose we would like to add a mark for tagging
    ;; messages (GMail-style), then we can run the following code (after loading mu4e):


    ;; As another example, suppose we would like to “archive and mark read”
    ;; a message (GMail-style), then we can run the following code (after loading mu4e):

    ;; (add-to-list 'mu4e-marks
    ;;              '(archive
    ;;                :char       "A"
    ;;                :prompt     "Archive"
    ;;                :show-target (lambda (target) "archive")
    ;;                :action      (lambda (docid msg target)
    ;;                               ;; must come before proc-move since retag runs
    ;;                               ;; 'sed' on the file
    ;;                               (mu4e-action-retag-message msg "-\\Inbox")
    ;;                               (mu4e~proc-move docid nil "+S-u-N"))))

    ;; (defvar brust-mu4e-tags-list '() "List of tags to consistently tag my emails. List created from the file `brust-mu4e-tags-list-file`")

    (defun brust-list-file-by-lines (-file)
      (with-temp-buffer
        (insert-file-contents -file)
        (split-string (buffer-string) "\n")))

    (add-to-list 'mu4e-marks
                 '(tag
                   :char       "g"
                   :prompt     "gtag"
                   :ask-target (lambda () (ivy-read "What tag do you want to add? " (brust-list-file-by-lines "~/.emacs.d/brust-mu4e-tags-list-file.txt")
                                                    :action (lambda (-str) (unless (member -str (brust-list-file-by-lines "~/.emacs.d/brust-mu4e-tags-list-file.txt"))
                                                                             (with-temp-buffer
                                                                               (insert-file-contents "~/.emacs.d/brust-mu4e-tags-list-file.txt")
                                                                               (insert -str "\n")
                                                                               (write-file "~/.emacs.d/brust-mu4e-tags-list-file.txt"))))))
                   :show-target (lambda (target) (concat "Tag added " target))
                   :action (lambda (docid msg target)
                             (mu4e-action-retag-message msg (concat "+" target)))))

    (defvar brust-mu4e-main-dirs-UAB
      (list (cons "today" "/mathuab/Today")
            (cons "week" "/mathuab/This week")
            (cons "month" "/mathuab/This month")
            (cons "for your information" "/mathuab/FYI")))

  (defun brust-flip-cons-list (-list)
    (cl-loop for -el in -list
             collect (cons (cdr -el) (car -el))))

  (add-to-list 'mu4e-marks
               '(moveUAB
                 :char       "A"
                 :prompt     "MoveUAB"
                 :ask-target (lambda () (mu4e-read-option "Move message to folder: " brust-mu4e-main-dirs))
                 :show-target (lambda (target) (concat "move to " (cdr (assoc target (brust-flip-cons-list brust-mu4e-main-dirs-UAB)))))
                 :action (lambda (docid msg target)
                           (mu4e-mark-set 'move target)
                           (when mu4e-headers-advance-after-mark (mu4e-headers-next)))))

  (add-to-list 'mu4e-marks
               '(mydelete
                 :char       "d"
                 :prompt     "mydelete"
                 :ask-target (lambda () (mu4e-read-option "Move message to folder: " brust-mu4e-main-dirs))
                 :show-target (lambda (target) (concat "move to " (cdr (assoc target (brust-flip-cons-list brust-mu4e-main-dirs-UAB)))))
                 :action (lambda (docid msg target)
                           (mu4e-mark-set 'move target)
                           (when mu4e-headers-advance-after-mark (mu4e-headers-next)))))

  (mu4e~headers-defun-mark-for tag)
  (mu4e~headers-defun-mark-for moveUAB)
  (define-key mu4e-headers-mode-map (kbd "g") 'mu4e-headers-mark-for-tag)
  (define-key mu4e-headers-mode-map (kbd "A") 'mu4e-headers-mark-for-moveUAB)

  (define-key mu4e-view-mode-map (kbd "g") 'mu4e-headers-mark-for-tag)
  (define-key mu4e-view-mode-map (kbd "A") 'mu4e-headers-mark-for-moveUAB)
#+end_src

#+RESULTS:
: mu4e-headers-mark-for-moveUAB

**** Contexts

(lambda (msg)
(when msg
(mu4e-message-contact-field-matches
msg '(:from :to :cc :bcc) "uab")))
 #+BEGIN_SRC elisp
   (setq mu4e-contexts
         (list
          (make-mu4e-context
           :name "ku"
           :enter-func (lambda () (mu4e-message "Entering context mathKU"))
           :leave-func (lambda () (mu4e-message "Leaving context mathKU"))
           :match-func (lambda (msg)
                         (when msg
                           (or (string-match-p "^/mathku" (mu4e-message-field msg :maildir))
                               (mu4e-message-contact-field-matches
                                msg '(:from :to :cc :bcc) "ku[.]dk"))))
           :vars '((user-mail-address . "brust@math.ku.dk")
                   (user-full-name . "Laura Brustenga i Moncusí")
                   (mu4e-sent-folder . "/mathku/Sent")
                   (mu4e-drafts-folder . "/mathku/Drafts")
                   (mu4e-trash-folder . "/mathku/Trash")
                   (mu4e-compose-signature . (concat
                                              "Laura Brustenga i Moncusí,\n"
                                              "Københavns Universitet,\n"
                                              "Institut for Matematiske Fag,\n"
                                              "MBIO."))
                   (mu4e-compose-format-flowed . nil)
                   (mu4e-maildir-shortcuts . (("/mathku/Deleted Items" . ?d)
                                              ("/mathku/FYI"           . ?f)
                                              ("/mathku/INBOX"         . ?i)
                                              ("/mathku/Month"         . ?m)
                                              ("/mathku/Sent Items"    . ?s)
                                              ("/mathku/Today"         . ?t)
                                              ("/mathku/Week"          . ?w)))))
          (make-mu4e-context
           :name "uab"
           :enter-func (lambda () (mu4e-message "Entering context brust@mat.uab.cat"))
           :leave-func (lambda () (mu4e-message "Leaving context brust@mat.uab.cat"))
           :match-func (lambda (msg)
                         (when msg
                           (or (string-match-p "^/mathuab" (mu4e-message-field msg :maildir))
                               (mu4e-message-contact-field-matches
                                msg '(:from :to :cc :bcc) "uab"))))
           :vars '((user-mail-address . "brust@mat.uab.cat")
                   (user-full-name . "Laura Brustenga i Moncusí")
                   (mu4e-sent-folder . "/mathuab/Sent")
                   (mu4e-drafts-folder . "/mathuab/Drafts")
                   (mu4e-trash-folder . "/mathuab/Trash")
                   (mu4e-compose-signature . nil)
                   (mu4e-compose-format-flowed . nil)
                   (mu4e-maildir-shortcuts . (("/mathuab/FYI"        . ?f)
                                              ("/mathuab/INBOX"      . ?i)
                                              ("/mathuab/Sent"       . ?s)
                                              ("/mathuab/This Month" . ?m)
                                              ("/mathuab/This week"  . ?w)
                                              ("/mathuab/Today"      . ?t)
                                              ("/mathuab/Trash"      . ?d)))))
          (make-mu4e-context
           :name "gmail"
           :enter-func (lambda () (mu4e-message "Entering context laurea987@gmail.com"))
           :leave-func (lambda () (mu4e-message "Leaving context laurea987@gmail.com"))
           :match-func (lambda (msg)
                         (when msg
                           (or (string-match-p "^/gmail" (mu4e-message-field msg :maildir))
                               (mu4e-message-contact-field-matches
                                msg '(:from :to :cc :bcc) "gmail"))))
           :vars '((user-mail-address . "laurea987@gmail.com")
                   (user-full-name . "Laura Brustenga")
                   (mu4e-sent-folder . "/gmail/Sent")
                   (mu4e-drafts-folder . "/gmail/Drafts")
                   (mu4e-trash-folder . "/gmail/Trash")
                   (mu4e-compose-signature . nil)
                   (mu4e-compose-format-flowed . nil)))))
 #+END_SRC

 #+RESULTS:
 | #s(mu4e-context ku (lambda nil (mu4e-message Entering context mathKU)) (lambda nil (mu4e-message Leaving context mathKU)) (lambda (msg) (when msg (or (string-match-p ^/mathku (mu4e-message-field msg :maildir)) (mu4e-message-contact-field-matches msg (quote (:from :to :cc :bcc)) ku[.]dk)))) ((user-mail-address . brust@math.ku.dk) (user-full-name . Laura Brustenga i Moncusí) (mu4e-sent-folder . /mathku/Sent) (mu4e-drafts-folder . /mathku/Drafts) (mu4e-trash-folder . /mathku/Trash) (mu4e-compose-signature concat Laura Brustenga i Moncusí, |

**** Bookmarks
 #+BEGIN_SRC elisp
   ;; Update mail using 'U' in main view:
   ;; Include a bookmark to open all of my inboxes
   (setq mu4e-bookmarks
         `(
           ;; ,(make-mu4e-bookmark
           ;;   :name "All Inboxes"
           ;;   :query "maildir:/mathuab/INBOX OR maildir:/Gmail/Inbox AND flag:unread AND NOT flag:trashed"
           ;;   :key ?i)
           ,(make-mu4e-bookmark
             :name "Math Inbox"
             :query "maildir:/mathuab/INBOX OR maildir:/mathku/INBOX AND NOT flag:trashed"
             :key ?i)
           ,(make-mu4e-bookmark
             :name "Math Today"
             :query "maildir:/mathuab/Today OR maildir:/mathku/Today AND NOT flag:trashed"
             :key ?t)
           ;; ,(make-mu4e-bookmark
           ;;   :name "Mathuab Week"
           ;;   :query "maildir:/mathuab/This week AND NOT flag:trashed"
           ;;   :key ?w)
           ;; ,(make-mu4e-bookmark
           ;;   :name "Mathuab Month"
           ;;   :query "maildir:/mathuab/This Month AND NOT flag:trashed"
           ;;   :key ?m)
           ;; ,(make-mu4e-bookmark
           ;;   :name "Mathuab FYI"
           ;;   :query "maildir:/mathuab/FYI AND NOT maildir:/mathuab/trash"
           ;;   :key ?m)
           ;; ("mime:image/*" "Messages with images" 112)
           ,(make-mu4e-bookmark
             :name "Drafts"
             :query "maildir:/mathuab/Drafts OR maildir:/mathku/Drafts OR flag:draft"
             :key ?d)))
 #+END_SRC

 #+RESULTS:
 | #s(mu4e-bookmark Math Inbox maildir:/mathuab/INBOX OR maildir:/mathku/INBOX AND NOT flag:trashed 105) | #s(mu4e-bookmark Math Today maildir:/mathuab/Today OR maildir:/mathku/Today AND NOT flag:trashed 116) | #s(mu4e-bookmark Drafts maildir:/mathuab/Drafts OR maildir:/mathku/Drafts OR flag:draft 100) |

**** Contacts
 #+begin_src elisp

 #+end_src

**** COMMENT Mail directory shortcuts
 #+begin_src elisp
   (setq mu4e-maildir-shortcuts
         '(("/Gmail/INBOX"   . ?g)
           ("/mathuab/INBOX" . ?m)))
 #+end_src

 #+RESULTS:
 : ((/Gmail/INBOX . 103) (/mathuab/INBOX . 109))

**** Org mu4e
 #+begin_src elisp
   ;;store org-mode links to messages
   (require 'org-mu4e)
   ;;store link to message if in header view, not to header query
   (setq org-mu4e-link-query-in-headers-mode nil)

   (push '("e" "Todo email" entry (file+headline "~/Dropbox/Org/my.org" "Work")
           "* TODO %?\nSCHEDULED: %(org-insert-time-stamp (org-read-date nil t \"+0d\"))\n%a\n")
         org-capture-templates)
 #+end_src

 #+RESULTS:
 | e | Todo email | entry | (file+headline ~/Dropbox/Org/my.org Work) | * TODO %? |

**** yasnippet for composing emails
  From http://pragmaticemacs.com/category/mu4e/

 #+begin_src elisp
 ;; function to return first name of email recipients
 ;; used by yasnippet
 ;; inspired by
 ;;http://blog.binchen.org/posts/how-to-use-yasnippets-to-produce-email-templates-in-emacs.html
 (defun bjm/mu4e-get-names-for-yasnippet ()
   "Return comma separated string of names for an email"
   (interactive)
   (let ((email-name "") str email-string email-list email-name2 tmpname)
     (save-excursion
       (goto-char (point-min))
       ;; first line in email could be some hidden line containing NO to field
       (setq str (buffer-substring-no-properties (point-min) (point-max))))
     ;; take name from TO field - match series of names
     (when (string-match "^To: \"?\\(.+\\)" str)
       (setq email-string (match-string 1 str)))
     ;;split to list by comma
     (setq email-list (split-string email-string " *, *"))
     ;;loop over emails
     (dolist (tmpstr email-list)
       ;;get first word of email string
       (setq tmpname (car (split-string tmpstr " ")))
       ;;remove whitespace or ""
       (setq tmpname (replace-regexp-in-string "[ \"]" "" tmpname))
       ;;join to string
       (setq email-name
             (concat email-name ", " tmpname)))
     ;;remove initial comma
     (setq email-name (replace-regexp-in-string "^, " "" email-name))

     ;;see if we want to use the name in the FROM field
     ;;get name in FROM field if available, but only if there is only
     ;;one name in TO field
     (if (< (length email-list) 2)
         (when (string-match "^On.+, \\([^ ,\n]+\\).+wrote:$" str)
           (progn
             (setq email-name2 (match-string 1 str))
             ;;prefer name in FROM field if TO field has "@"
             (when (string-match "@" email-name)
               (setq email-name email-name2))
             )))
     email-name))
 #+end_src

 #+RESULTS:
 : bjm/mu4e-get-names-for-yasnippet

**** Alert
***** Config
      It works for notifications...
#+BEGIN_SRC elisp
  (use-package mu4e-alert
    :ensure t
    :after mu4e)

  ;; (require 'mu4e-alert)
  (setq mu4e-alert-interesting-mail-query "flag:unread AND NOT flag:trashed AND maildir:/mathuab/INBOX"
        mu4e-headers-skip-duplicates t)

  ;; Desktop notifications
  (mu4e-alert-set-default-style 'libnotify)
  ;; (mu4e-alert-set-default-style 'notifier))

  ;; (setq mu4e-enable-mode-line t)
  ;; (mu4e-alert-enable-notifications)
  ;; (mu4e-alert-enable-mode-line-display)
  ;; (mu4e-alert-update-mail-count-modeline)

  ;; (setq mu4e-alert-notify-repeated-mails t)
  ;; (mu4e-alert-notify-unread-mail-async)


  (add-hook 'after-init-hook #'mu4e-alert-enable-notifications)
  ;; (add-hook 'after-init-hook #'mu4e-alert-enable-mode-line-display)
  ;; (add-hook 'mu4e-index-updated-hook #'mu4e~headers-do-auto-update)
  ;; (add-hook 'mu4e-index-updated-hook #'mu4e-alert-update-mail-count-modeline)

  ;;   (defun gjstein-refresh-mu4e-alert-mode-line ()
  ;;     (interactive)
  ;;     (mu4e~proc-kill)
  ;;     (mu4e-alert-enable-mode-line-display)
  ;;     (mu4e-alert-enable-notifications)
  ;;     )
  ;;   (run-with-timer 0 60 #'gjstein-refresh-mu4e-alert-mode-line)

 #+END_SRC

 #+RESULTS:
 | mu4e~headers-maybe-auto-update | mu4e~headers-do-auto-update | mu4e-alert-update-mail-count-modeline | mu4e-alert-notify-unread-mail-async | #[0 \300\301!\207 [run-hooks mu4e-message-changed-hook] 2] |
***** COMMENT Formatter
#+begin_src elisp
  (require 'ezimage)

  (defun brust-mu4e-alert-mode-line-formatter (mail-count)
    "Default formatter used to get the string to be displayed in the mode-line.
  MAIL-COUNT is the count of mails for which the string is to displayed"
    (when (not (zerop mail-count))
      (concat " "
              (propertize
               "+"
               'display (when (display-graphic-p)
                          ezimage-mail)
               'face display-time-mail-face
               'help-echo (concat (if (= mail-count 1)
                                      "You have an unread email"
                                    (format "You have %s unread emails" mail-count))
                                  "\nClick here to view "
                                  (if (= mail-count 1) "it" "them"))
               'mouse-face 'mode-line-highlight
               'keymap '(mode-line keymap
                                   (mouse-1 . mu4e-alert-view-unread-mails)
                                   (mouse-2 . mu4e-alert-view-unread-mails)
                                   (mouse-3 . mu4e-alert-view-unread-mails)))
              (if (zerop mail-count)
                  " "
                (format " [%d] " mail-count)))))

  (setq mu4e-alert-modeline-formatter 'mu4e-alert-default-mode-line-formatter)
#+end_src

#+RESULTS:
: brust-mu4e-alert-default-mode-line-formatter

**** New Inbox
     That's something that I understand, and I can use. (I've never understood mu4e-alert and I've been not able to use it...)
***** Code
      From https://gist.github.com/gl-sergei/1986989ad3c2024f8150
  #+begin_src elisp
    ;;; inbox.el --- display inbox status information  -*- coding: utf-8 -*-

    ;; Copyright (C) 2014 Sergei Glushchenko.

    ;; Author: Sergei Glushchenko <gl.sergei@gmail.com>

    ;; This program is free software: you can redistribute it and/or modify
    ;; it under the terms of the GNU General Public License as published by
    ;; the Free Software Foundation, either version 3 of the License, or
    ;; (at your option) any later version.

    ;; This program is distributed in the hope that it will be useful,
    ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
    ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    ;; GNU General Public License for more details.

    ;; You should have received a copy of the GNU General Public License
    ;; along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.

    (require 'ezimage)

    (defgroup inbox nil
      "Display inbox status information."
      :prefix "inbox-"
      :group 'hardware)

    (defcustom inbox-update-interval 60
      "Inbox update interval"
      :type 'integer
      :group 'inbox)

    (defvar inbox-update-timer nil
      "Interval timer object.")

    (defcustom inbox-count-command "echo -n $( mu find date:1w..now maildir:/INBOX flag:unread 2>/dev/null | wc -l )"
      "Command to retrieve count of emails in Inbox"
      :type 'string
      :group 'inbox)

    (defvar inbox-mode-line-string nil
      "String to display in the mode line.")
    (put 'inbox-mode-line-string 'risky-local-variable t)

    (define-minor-mode display-inbox-mode
      "Toggle inbox status display in mode line (Display Inbox mode).
    With a prefix argument ARG, enable Display Inbox mode if ARG is
    positive, and disable it otherwise.  If called from Lisp, enable
    the mode if ARG is omitted or nil."
      :global t :group 'inbox
      (setq inbox-mode-line-string "")
      (or global-mode-string (setq global-mode-string '("")))
      (and inbox-update-timer (cancel-timer inbox-update-timer))

      (if (not display-inbox-mode)
          (setq global-mode-string
                (delq 'inbox-mode-line-string global-mode-string))
        (add-to-list 'global-mode-string 'inbox-mode-line-string t)
        (setq inbox-update-timer (run-at-time nil inbox-update-interval
                                              'inbox-update-handler))
        (inbox-update)))


    ;; (defun inbox-update ()
    ;;   (interactive)
    ;;   (setq inbox-mode-line-string
    ;;         (let ((unread (shell-command-to-string inbox-count-command)))
    ;;           (propertize
    ;;            (if (string= "0" unread) "" "+")
    ;;            'display ezimage-mail
    ;;            'help-echo (format "%s unread messages" unread))))
    ;;   (force-mode-line-update))

    (defun brust-inbox-update-index-mu4e nil
      "Fast update and index mu4e 'mathuab'"
      (let ((mu4e-hide-index-messages t)
            (mu4e-index-update-error-warning nil)
            (mu4e-compose-complete-addresses nil) ;; just check for mails
            (mu4e-index-cleanup nil)
            (mu4e-index-lazy-check t)
            (mu4e-get-mail-command "mbsync mathuab")) ;; just update math mails
        (mu4e-update-mail-and-index t)))

    (defun brust-inbox-update-mode-line-string nil
      (interactive)
      (setq inbox-mode-line-string
            (let ((unread (string-to-number (shell-command-to-string inbox-count-command))))
              (if (zerop unread) " "
                (concat " "
                        (propertize
                         "+"
                         'display ezimage-mail
                         'face 'brust-vc-edited)
                        (propertize
                         (format " [%d]" unread)
                         'face 'brust-vc-edited
                         'help-echo (concat (if (= unread 1)
                                                "You have an unread email"
                                              (format "You have %s unread emails" unread))
                                            "\nClick here to view "
                                            (if (= unread 1) "it" "them"))
                         'mouse-face 'mode-line-highlight
                         'keymap '(mode-line keymap
                                             (mouse-1 . mu4e-alert-view-unread-mails)
                                             (mouse-2 . mu4e-alert-view-unread-mails)
                                             (mouse-3 . mu4e-alert-view-unread-mails)))
                        " "))))
      (force-mode-line-update))

    (defun inbox-update nil
      (interactive)
      (brust-inbox-update-index-mu4e)
      (brust-inbox-update-mode-line-string))

    (defun inbox-update-handler ()
      (inbox-update)
      (sit-for 0))
  #+end_src

  #+RESULTS:
  : inbox-update-handler

***** Config
#+begin_src elisp
  (setq inbox-count-command "echo -n $( ~/scr/mu/mu/mu find flag:unread AND maildir:/mathuab/INBOX 2>/dev/null | wc -l )"
        inbox-update-interval (* 30 60) ;; Every half an hour it is enough.
        inbox-update-timer (run-at-time nil inbox-update-interval
                                        'inbox-update-handler))
  (inbox-update)
#+end_src

#+RESULTS:

**** My functions
***** Org caputre mail
 #+begin_src elisp
 (defun my/org-capture-mu4e ()
   (interactive)
   "Capture a TODO item via email."
   (org-capture nil "o"))
 #+end_src

 #+RESULTS:
 : my/org-capture-mu4e

*** Nyan
    Show the rainbow progres line.
#+BEGIN_SRC elisp
  (use-package nyan-mode
    :init (nyan-mode 1)
    :config
    (setq nyan-minimum-window-width 0
          ;;nyan-cat-face-number 3
          nyan-wavy-trail nil
          nyan-animate-nyancat t
          nyan-animation-frame-interval 0.2
          nyan-bar-length 36)
    ;; (nyan-start-animation)

    (use-package zone-nyan
      :config
      (setq zone-programs [zone-nyan]
            zone-nyan-hide-progress t)
      (use-package zone
        :config
        (zone-when-idle (* 5 60)))))
#+END_SRC

*** Org-ref
**** General config
 #+BEGIN_SRC elisp
   (use-package org-ref
     :after org
     :init
     (setq org-ref-default-bibliography '("~/Dropbox/bibliography/my.bib"
                                          "~/Dropbox/bibliography/pragmatic.bib")
           org-ref-bibliography-notes "~/Dropbox/bibliography/notes.org"
           ;; org-ref-completion-library 'org-ref-ivy-cite
           org-ref-pdf-directory "~/Dropbox/bibliography/pdf/")

     (setq bibtex-autokey-year-length 4
           bibtex-autokey-name-year-separator "-"
           bibtex-autokey-year-title-separator "-"
           bibtex-autokey-titleword-separator "-"
           bibtex-autokey-titlewords 2
           bibtex-autokey-titlewords-stretch 1
           bibtex-autokey-titleword-length 5)

     ;;     (defadvice org-ref-next-latex-cite (around add-font-lock-support-mode activate)
     ;;       (let ((font-lock-support-mode #'jit-lock-mode))
     ;;         ad-do-it))

     ;;   (add-hook 'LaTeX-mode-hook (lambda nil
     ;;                                (require 'org-ref)
     ;;                                (require 'org-ref-latex)))

     (setq org-ref-note-title-format
           "** TODO %y - %t\n :PROPERTIES:\n  :Custom_ID: %k\n  :AUTHOR: %a\n  :INTERLEAVE_PDF: pdf/%k.pdf \n  :JOURNAL: %j\n  :YEAR: %y\n  :VOLUME: %v\n  :PAGES: %p\n  :DOI: %D\n  :URL: %U\n :END:\n")

     :config
     ;; (require 'org-ref-ivy)
     ;; (require 'org-ref-latex) ;; convert cite ref into clicable links
     (require 'org-ref-bibtex)
     (setq bibtex-completion-format-citation-functions
           '((org-mode      . bibtex-completion-format-citation-org-link-to-PDF)
             (latex-mode    . brust-bibtex-completion-format-citation-cite)
             (markdown-mode . bibtex-completion-format-citation-pandoc-citeproc)
             (default       . bibtex-completion-format-citation-default)))

     (require 'org-ref-pdf)
     (require 'org-ref-arxiv)
     ;; (key-chord-define-global "kk" 'org-ref-cite-hydra/body)
     ;; (global-set-key (kbd "s-n") 'org-ref-bibtex-hydra/body)
     ;; (use-package org-autolist
     ;;   :after org-ref
     ;;   :config
     ;;   (org-autolist-mode +1))
     ;;
     ;; ;;      (use-package doi-utils
     ;; ;;        :after org)
     ;;
     ;; (use-package org-ref-bibtex;;
     ;;   :after org
     ;;   :init
     ;;   (setq org-ref-bibtex-hydra-key-binding "\C-cj"))
     )
 #+END_SRC

 #+RESULTS:
 : t

**** Functions
 #+BEGIN_SRC elisp
   (defun brust-arxiv-get-number-from-web (arxiv-web)
     (with-temp-buffer
       (insert arxiv-web)
       (goto-char (point-min))
       (if (search-forward "https://" nil t)
           (cond ((search-forward "/abs/" nil t)
                  (buffer-substring-no-properties (point) (point-max)))
                 ((search-forward "/pdf/" nil t)
                  (buffer-substring-no-properties (point)
                                                  (progn (search-forward ".pdf" nil t)
                                                         (match-beginning 0))))
                 (t (message "Unkown web format")))
         arxiv-web)))

   (defun brust-org-ref-bibtex-open-notes (-header)
     "It assume that you are at the beginning of a bibtex entry in a .bib file"
     (interactive
      (list (ivy-read
             "Header: "
             (brust-org-mode-get-top-header-list org-ref-bibliography-notes)
             :require-match t
             :sort t
             :preselect "Index")))
     (let ((-abstract
            (cdr (assoc "abstract" (bibtex-parse-entry t))))
           (-entry))
       (save-excursion
         (org-ref-open-bibtex-notes)
         (org-narrow-to-subtree)
         (goto-char (point-min))
         (when (search-forward "cite:" nil t)
           (delete-region (point-at-bol) (1+ (point-at-eol)))
           (goto-char (point-max)))
         (when -abstract
           (insert "*** Abstract\n" -abstract))
         (indent-region (point-min) (point-max))
         (unless (string-match-p "Index" -header)
           (setq entry (buffer-substring-no-properties (point-min) (point-max)))
           (delete-region (point-min) (point-max))
           (widen)
           (goto-char (point-min))
           (search-forward -header nil t)
           (insert "\n\n" -entry))
         (widen))))

   (defun brust-arxiv-get-pdf-add-notes-entry (-arxiv-web -header)
     "Add an entry for ARXIV-WEB to 'notes.org'.
   Remove troublesome chars from the bibtex key, retrieve a pdf
   for ARXIV-NUMBER and save it to PDFDIR with the same name of the
   key."
     (interactive
      (list (read-string "arxiv web: ")
            (ivy-read
             "Header: "
             (brust-org-mode-get-top-header-list org-ref-bibliography-notes)
             :require-match t
             :sort t
             :preselect "Index")))
     (let ((-tempbib "/tmp/temp-biblio.bib"))
       (find-file -tempbib)
       (save-buffer)
       (ignore-errors (arxiv-get-pdf-add-bibtex-entry
                       (brust-arxiv-get-number-from-web -arxiv-web)
                       -tempbib
                       (expand-file-name "~/Dropbox/bibliography/pdf/")))
       (save-buffer)
       (bibtex-beginning-of-entry)
       (brust-org-ref-bibtex-open-notes -header)
       ;; (erase-buffer)
       (save-buffer)
       ;;(kill-buffer)
       ))


   (defun brust-org-mode-get-top-header-list (file)
     (let ((-list '()))
       (save-window-excursion
         (find-file file)
         (goto-char (point-min))
         (while (re-search-forward "^\\* .*$" nil t)
           (push (match-string-no-properties 0) -list)))
       -list))

   (defun brust-add-notes-entry-from-pdf (-entry-type -title -author -year -pages -header)
     (interactive
      (list (ivy-read
             "Entry Type: "
             (cl-loop for -entry-type in bibtex-BibTeX-entry-alist
                      collect (downcase (car -entry-type)))
             :require-match t
             :sort t
             :preselect "article")
            (read-string "Title: ")
            (read-string "Author: ")
            (read-string "Year: ")
            (read-string "Pages: ")
            (ivy-read
             "Header: "
             (brust-org-mode-get-top-header-list org-ref-bibliography-notes))
            :require-match t
            :sort t
            :preselect "Index"))
     (let ((-file (buffer-file-name))
           (-key (file-name-base (buffer-file-name))))
       (find-file org-ref-bibliography-notes)
       (goto-char (point-min))
       (search-forward -header nil t)
       (insert (format
                "\n\n** TODO %s - %s\n :PROPERTIES:\n  :Custom_ID: %s\n  :AUTHOR: %s\n  :INTERLEAVE_PDF: %s \n :YEAR: %s\n :TYPE: %s\n :PAGES: %s\n :END:\n"
                -year -title -key -author -file -year -entry-type -pages)))
     ;; (insert "*** Comments\n\n*** Interleave\n")
     (indent-region (point-min) (point-max)))

 #+END_SRC

 #+RESULTS:
 : brust-add-notes-entry-from-pdf

**** Helm config

 #+BEGIN_SRC elisp
   (bind-keys :map helm-map
              ("s-k" . helm-next-line)
              ("s-i" . helm-previous-line))
 #+END_SRC

 #+RESULTS:
 : helm-previous-line

*** Pdf tools
**** Main
#+BEGIN_SRC elisp
  (use-package pdf-tools
    :init
    (pdf-tools-install)
    ;; (pdf-occur-global-minor-mode 0)
    ;; (add-hook 'dired-load-hook #'pdf-occur-dired-minor-mode)
    ;; (add-hook 'ibuffer-load-hook #'pdf-occur-ibuffer-minor-mode)
    ;; open pdfs scaled to fit page
    (setq-default pdf-view-display-size 'fit-page)
    ;; automatically annotate highlights
    (setq pdf-annot-activate-created-annotations t
          pdf-view-resize-factor 1.1)
    :config
    (defun brust-pdf-tools-hook ()
      (bind-keys :map pdf-view-mode-map ("i" . brust-pdf-view-previous-line-or-previous-page-5)))

    :chords
    (:map pdf-view-mode-map
          ("jj" . brust-image-backward-hsroll-5))

    :bind
    (:map pdf-view-mode-map
          ("<"           . pdf-view-first-page)
          (">"           . pdf-view-last-page)
          ("C-k"         . pdf-view-next-page-command)
          ("C-i"         . pdf-view-previous-page-command)
          ("s-SPC"       . pdf-view-scroll-down-or-previous-page)
          ("s-k"         . pdf-view-next-line-or-next-page)
          ("s-i"         . pdf-view-previous-line-or-previous-page)
          ("s-j"         . image-backward-hscroll)
          ("s-l"         . image-forward-hscroll)
          ("k"           . brust-pdf-view-next-line-or-next-page-5)
          ("i"           . brust-pdf-view-previous-line-or-previous-page-5)
          ("j"           . brust-image-backward-hsroll-5)
          ("l"           . brust-image-forward-hsroll-5)
          ("C-n"         . brust-ace-window)
          ("n"           . brust-ace-window)
          ("<mouse-5>"   . brust-pdf-view-next-line-or-next-page-5)
          ("<mouse-4>"   . brust-pdf-view-previous-line-or-previous-page-5)
          ("C-<mouse-5>" . pdf-view-next-page-command)
          ("C-<mouse-4>" . pdf-view-previous-page-command)
          ("s-<mouse-5>" . pdf-view-next-line-or-next-page)
          ("s-<mouse-4>" . pdf-view-previous-line-or-previous-page)
          ("."           . hydra-pdftools/body)))

  (eval-after-load 'interleave
    (add-hook 'pdf-view-mode-hook #'brust-pdf-tools-hook t))

  (defun brust-image-backward-hsroll-5 (args)
    (interactive "p")
    (brust-by-five #'image-backward-hscroll args))
  (defun brust-image-forward-hsroll-5 (args)
    (interactive "p")
    (brust-by-five #'image-forward-hscroll args))
  (defun brust-pdf-view-next-line-or-next-page-5 (args)
    (interactive "p")
    (brust-by-five #'pdf-view-next-line-or-next-page args))
  (defun brust-pdf-view-previous-line-or-previous-page-5 (args)
    (interactive "p")
    (brust-by-five #'pdf-view-previous-line-or-previous-page args))
#+END_SRC

#+RESULTS:
: brust-pdf-view-previous-line-or-previous-page-5
**** org-pdftools
     Org links for pdfs
#+begin_src elisp
  (use-package org-pdfview
    :config ;;(setq org-pdftools-root-dir "~/Dropbox/bibliography/pdf")
    )
#+end_src

#+RESULTS:

**** COMMENT save place
 workaround for pdf-tools not reopening to last-viewed page of the pdf:
  ;; https://github.com/politza/pdf-tools/issues/18

#+BEGIN_SRC elisp
  (defun brds/pdf-set-last-viewed-bookmark ()
    (interactive)
    (when (eq major-mode 'pdf-view-mode)
      (bookmark-set (brds/pdf-generate-bookmark-name))))

  (defun brds/pdf-jump-last-viewed-bookmark ()
    (when
        (brds/pdf-has-last-viewed-bookmark)
      (bookmark-jump (brds/pdf-generate-bookmark-name))))

  (defun brds/pdf-has-last-viewed-bookmark ()
    (member (brds/pdf-generate-bookmark-name) (bookmark-all-names)))

  (defun brds/pdf-generate-bookmark-name ()
    (concat "PDF-LAST-VIEWED: " (buffer-file-name)))

  (defun brds/pdf-set-all-last-viewed-bookmarks ()
    (dolist (buf (buffer-list))
      (with-current-buffer buf
        (brds/pdf-set-last-viewed-bookmark))))

  (add-hook 'kill-buffer-hook 'brds/pdf-set-last-viewed-bookmark)
  (add-hook 'pdf-view-mode-hook 'brds/pdf-jump-last-viewed-bookmark)
  (unless noninteractive  ; as `save-place-mode' does
    (add-hook 'kill-emacs-hook #'brds/pdf-set-all-last-viewed-bookmarks))
#+END_SRC

#+RESULTS:
| tex-delete-last-temp-files | company-clang-set-prefix | company-statistics--maybe-save | brds/pdf-set-all-last-viewed-bookmarks | reftex-kill-emacs-hook | bookmark-exit-hook-internal | desktop-kill | keyfreq-mustsave--do | org-babel-remove-temporary-directory | savehist-autosave | save-place-kill-emacs-hook | server-force-stop |

*** COMMENT Projectile
#+BEGIN_SRC elisp
  (use-package projectile
    :init
    (setq projectile-known-projects-file "~/.emacs.d/backups/projectile-bookmarks.eld")
    (projectile-mode 1)
    :config
    (setq projectile-mode-line
          '(:eval (if
                      (file-remote-p default-directory)
                      ""
                    (format " [Pj %s]"
                            (projectile-project-name)))))

    (use-package counsel-projectile
      :init
      ;; install replacements for some standard projectile commands
      (counsel-projectile-mode 1))
    :bind*
    ("s-q" . project-find-file)
    ;; ("s-q" . projectile-command-map)
    )

#+END_SRC
*** COMMENT Rainbow delimiters
    I use it just to auto color unmatched parents.
#+BEGIN_SRC elisp
  (use-package rainbow-delimiters
    :init
    (add-hook 'prog-mode-hook #'rainbow-delimiters-mode)
    ;; (add-hook 'LaTeX-mode-hook #'rainbow-delimiters-mode)
    :config
    (setq rainbow-delimiters-max-face-count 1)
    (set-face-attribute 'rainbow-delimiters-depth-1-face nil
                        :foreground 'unspecified
                        :inherit 'default)
    (set-face-attribute 'rainbow-delimiters-unmatched-face nil
                        :foreground 'unspecified
                        :inherit 'error))

;;(defun brust-rainbow-delimiters-pick-face-function (DEPTH MATCH LOC)
;;  (if (< DEPTH 1)
;;      "error"
;;    "default"))
;;
;;(setq rainbow-delimiters-pick-face-function #'rainbow-delimiters-pick-face-function)
#+END_SRC

#+RESULTS:
: rainbow-delimiters-pick-face-function

*** Recentf
    Keep a list of recently opened files.
#+BEGIN_SRC elisp
  (use-package recentf
    :init
    (setq recentf-max-saved-items 200
          ;; recentf-max-menu-items 15
          recentf-save-file "~/.emacs.d/backups/recentf"
          recentf-exclude '("COMMIT_MSG" "COMMIT_EDITMSG" "github.*txt$"
                            "^.*png$" "^.*~$" "^.*-autoloads.el$"
                            "/elpa/" "^.*rel$" "^.*latexmk$" "^.*[0-9]$" "^.*fls$"))
    ;; :bind ("C-<f2>" . recentf-open-files)
    (recentf-mode 1))
    (run-with-timer 0 (* 30 60) 'recentf-save-list)

#+END_SRC

*** COMMENT SAGE
#+BEGIN_SRC elisp
  (use-package sage-shell-mode
    :init
    (setq sage-shell:sage-root "~/SageMath")
    :config
    ;; Run SageMath by M-x run-sage instead of M-x sage-shell:run-sage
    (sage-shell:define-alias)

    ;; Turn on eldoc-mode in Sage terminal and in Sage source files
    (add-hook 'sage-shell-mode-hook #'eldoc-mode)
    (add-hook 'sage-shell:sage-mode-hook #'eldoc-mode))
#+END_SRC

#+RESULTS:
: t

*** COMMENT SASS files
    For some reason turn-off aggressive-indent do not work :(
#+BEGIN_SRC elisp
  (use-package sass-mode
    :config
    (defun aggressive-indent-mode-off nil
      (aggressive-indent-mode -1))
    (setq scss-compile-at-save nil)
    (add-hook 'sass-mode-hook #'aggressive-indent-mode-off))
#+END_SRC

#+RESULTS:
: t

*** Smartparents
#+BEGIN_SRC elisp
  (use-package smartparens
    :init
    (setq sp-base-key-bindings nil
          sp-hybrid-kill-entire-symbol t
          sp-navigate-close-if-unbalanced t
          sp-show-pair-from-inside t
          sp-autoinsert-pair nil
          sp-use-subword t)
    :config
    ;; Yes
    (add-hook 'fundamental-mode-hook 'y-sp)
    (add-hook 'text-mode-hook 'y-sp)
    (add-hook 'org-mode-hook 'y-sp)
    (add-hook 'LaTeX-mode-hook 'y-sp)
    (add-hook 'emacs-lisp-mode-hook 'y-sp)
    (defun y-sp nil "Activate smartparents" (smartparens-mode 1))
    ;;(smartparens-global-mode t)
    :bind
    ("M-f" . sp-forward-sexp)
    ("M-d" . sp-backward-sexp)
    ;; ("C-M-d" . sp-down-sexp)
    ;; ("C-M-a" . sp-backward-down-sexp)
    ;; ("C-S-d" . sp-beginning-of-sexp)
    ;; ("C-S-a" . sp-end-of-sexp)
    ;;("C-M-e" . sp-up-sexp)
    ;;("C-M-u" . sp-backward-up-sexp)
    ("M-C-f" . sp-next-sexp)
    ("M-C-d" . sp-previous-sexp)

    ;; ("M-S-d" . sp-splice-sexp)
    ;; ("C-]" . sp-select-next-thing-exchange)
    ;; ("C-M-]" . sp-select-next-thing)
    ;;
    ;; ("C-M-k" . sp-kill-sexp)
    ;; ("C-M-w" . sp-copy-sexp)
    ("M-<delete>" . sp-unwrap-sexp)
    ("M-<backspace>" . sp-backward-unwrap-sexp)
    ;;("C-<right>" . 'sp-forward-slurp-sexp)
    ;;("C-<left>" . 'sp-forward-barf-sexp)
    ;;("C-M-<left>" . sp-backward-slurp-sexp)
    ;;("C-M-<right>" . sp-backward-barf-sexp)
    ;;("C-M-<delete>" . 'sp-splice-sexp-killing-forward)
    ;;("C-M-<backspace>" . sp-splice-sexp-killing-backward)
    ;;("C-S-<backspace>" . sp-splice-sexp-killing-around)
    ;;("M-F" . 'sp-forward-symbol)
    ;;("M-B" . 'sp-backward-symbol)
    )
#+END_SRC
*** COMMENT Smerge
See https://github.com/alphapapa/unpackaged.el#smerge-mode

#+begin_src elisp
(use-package smerge-mode
  :after hydra
  :config
  (defhydra unpackaged/smerge-hydra
    (:color pink :hint nil :post (smerge-auto-leave))
    "
^Move^       ^Keep^               ^Diff^                 ^Other^
^^-----------^^-------------------^^---------------------^^-------
_n_ext       _b_ase               _<_: upper/base        _C_ombine
_p_rev       _u_pper              _=_: upper/lower       _r_esolve
^^           _l_ower              _>_: base/lower        _k_ill current
^^           _a_ll                _R_efine
^^           _RET_: current       _E_diff
"
    ("n" smerge-next)
    ("p" smerge-prev)
    ("b" smerge-keep-base)
    ("u" smerge-keep-upper)
    ("l" smerge-keep-lower)
    ("a" smerge-keep-all)
    ("RET" smerge-keep-current)
    ("\C-m" smerge-keep-current)
    ("<" smerge-diff-base-upper)
    ("=" smerge-diff-upper-lower)
    (">" smerge-diff-base-lower)
    ("R" smerge-refine)
    ("E" smerge-ediff)
    ("C" smerge-combine-with-next)
    ("r" smerge-resolve)
    ("k" smerge-kill-current)
    ("ZZ" (lambda ()
            (interactive)
            (save-buffer)
            (bury-buffer))
     "Save and bury buffer" :color blue)
    ("q" nil "cancel" :color blue))
  :hook (magit-diff-visit-file . (lambda ()
                                   (when smerge-mode
                                     (unpackaged/smerge-hydra/body)))))
#+end_src

#+RESULTS:
| lambda | nil | (when smerge-mode (unpackaged/smerge-hydra/body)) |

*** Transpose buffers
#+BEGIN_SRC elisp
  (use-package transpose-frame
    :bind*
    ;; ("C-x |" . transpose-frame)
    ;; ("C-x 5" . transpose-frame)
    ("<f5> t"  . transpose-frame)
    ("<f5> h"  . flop-frame)
    ("<f5> v"  . flip-frame)
    ("<f5> r"  . rotate-frame-anticlockwise))
#+END_SRC
*** COMMENT Tweeter
#+begin_src elisp
(use-package twittering-mode
    :ensure t
    :commands twit
    :init
    (add-hook 'twittering-edit-mode-hook #'flyspell-mode)
    :config
    (setq twittering-use-master-password t
          twittering-icon-mode t
          twittering-use-icon-storage t
          ;; twittering-icon-storage-file (concat joe-emacs-temporal-directory "twittering-mode-icons.gz")
          twittering-convert-fix-size 52
          twittering-initial-timeline-spec-string '(":home")
          twittering-edit-skeleton 'inherit-any
          twittering-display-remaining t
          twittering-timeline-header  ""
          twittering-timeline-footer  ""
          twittering-status-format
          "%i  %S, %RT{%FACE[bold]{%S}} %@  %FACE[shadow]{%p%f%L%r}\n%FOLD[        ]{%T}\n")

      ;; set the new bindings
;;    :bind :map twittering-mode-map
;;                 ("\\" . hydra-twittering/body)
;;                 ("q" . twittering-kill-buffer)
;;                 ("Q" . twittering-edit-mode)
;;                 ("j" . twittering-goto-next-status)
;;                 ("k" . twittering-goto-previous-status)
;;                 ("h" . twittering-switch-to-next-timeline)
;;                 ("l" . twittering-switch-to-previous-timeline)
;;                 ("g" . beginning-of-buffer)
;;                 ("G" . end-of-buffer)
;;                 ("t" . twittering-update-status-interactive)
;;                 ("X" . twittering-delete-status)
;;                 ("RET" . twittering-reply-to-user)
;;                 ("r" . twittering-native-retweet)
;;                 ("R" . twittering-organic-retweet)
;;                 ("d" . twittering-direct-message)
;;                 ("u" . twittering-current-timeline)
;;                 ("b" . twittering-favorite)
;;                 ("B" . twittering-unfavorite)
;;                 ("f" . twittering-follow)
;;                 ("F" . twittering-unfollow)
;;                 ("i" . twittering-view-user-page)
;;                 ("/" . twittering-search)
;;                 ("." . twittering-visit-timeline)
;;                 ("@" . twittering-other-user-timeline)
;;                 ("T" . twittering-toggle-or-retrieve-replied-statuses)
;;                 ("o" . twittering-click)
;;                 ("TAB" . twittering-goto-next-thing)
;;                 ("<backtab>" . twittering-goto-previous-thing)
;;                 ("n" . twittering-goto-next-status-of-user)
;;                 ("p" . twittering-goto-previous-status-of-user)
;;                 ("SPC" . twittering-scroll-up)
;;                 ("S-SPC" . twittering-scroll-down)
;;                 ("y" . twittering-push-uri-onto-kill-ring)
;;                 ("Y" . twittering-push-tweet-onto-kill-ring)
;;                 ("a" . twittering-toggle-activate-buffer)
)
#+end_src

#+RESULTS:
: t

*** TODO Visual fill column
    It is like visual line mode but breaks the lines at =fill-column=
    :TODO: add hook with the correct fill-column number to each mode.
    or maybe not activate visual-fill-column??
#+BEGIN_SRC elisp
  (use-package visual-fill-column
    :init
    ;; (setq line-move-visual nil)
    (add-hook 'visual-line-mode-hook #'visual-fill-column-mode)
    (add-hook 'LaTeX-mode-hook #'visual-line-mode)
    ;; (add-hook 'org-mode-hook #'visual-fill-column-mode)
    (setq visual-line-fringe-indicators '(nil right-curly-arrow))
    (setq-default fill-column 80)
    (use-package adaptive-wrap ; to have the same indentation.
      :init
      (add-hook 'visual-line-mode-hook #'adaptive-wrap-prefix-mode)
      (add-hook 'visual-fill-column-mode-hook #'adaptive-wrap-prefix-mode)
      ;;(global-visual-line-mode 1)
      ;;(global-visual-fill-column-mode)
      ))
#+END_SRC

#+RESULTS:

*** COMMENT View Large files
#+BEGIN_SRC elisp
  (use-package vlf
    :config
    ;; (require 'vlf-setup)
    (setq vlf-batch-size 1024)
    )
#+END_SRC

#+RESULTS:
: t

*** Visual regexp
#+BEGIN_SRC elisp
  (use-package visual-regexp
    :bind
    ("M-s-r" . vr/replace)
    ("s-r"   . vr/query-replace))
  ;; Use multiple-cursors, this is for you:
  ;; ("C-c m" . vr/mc-mark)

#+END_SRC

*** Writable grep buffer

#+BEGIN_SRC elisp
  (use-package wgrep
    :config
    (setq wgrep-auto-save-buffer t
          wgrep-enable-key "r"))
#+END_SRC
*** Which key

#+BEGIN_SRC elisp
  (use-package which-key
    :defer 10
    :config
    (setq which-key-popup-type 'side-window) ; default
    ;; (setq which-key-popup-type 'minibuffer)

    ;; Replacements for how KEY is replaced when which-key displays
    ;;   KEY → FUNCTION
    ;; Eg: After "C-c", display "right → winner-redo" as "▶ → winner-redo"
    (setq which-key-key-replacement-alist
          '(("<\\([[:alnum:]-]+\\)>" . "\\1")
            ("left"                . "◀")
            ("right"               . "▶")
            ("up"                  . "▲")
            ("down"                . "▼")
            ("delete"              . "DLT") ; delete key
            ("\\`DEL\\'"           . "BS") ; backspace key
            ("next"                . "PgDn")
            ("prior"               . "PgUp")))

    ;; Replacements for how part or whole of FUNCTION is replaced when
    ;; which-key displays
    ;;   KEY → FUNCTION
    ;; Eg: After "d" in `calc', display "6 → calc-hex-radix" as "6 → 🖩hex-radix"
    (setq which-key-description-replacement-alist
          '(("Prefix Command" . "prefix")
            ("which-key-show-next-page" . "wk next pg")
            ("\\`calc-" . "") ; Hide "calc-" prefixes when listing M-x calc keys
            ("/body\\'" . "") ; Remove display the "/body" portion of hydra fn names
            ("modi/" . "m/") ; The car is intentionally not "\\`modi/" to cover
                                          ; cases like `hydra-toggle/modi/..'.
            ("\\`hydra-" . "+h/")
            ("\\`org-babel-" . "ob/")))
    ;;    (which-key-add-key-based-replacements
    ;;      "C-x 8 0" "ZWS")

    ;; List of "special" keys for which a KEY is displayed as just K but with
    ;; "inverted video" face.
    ;;  (setq which-key-special-keys
    ;;       '("SPC"
    ;;         "TAB"
    ;;         "RET"
    ;;         "DLT" ; delete key
    ;;         "BS" ; backspace key
    ;;         "ESC"))
    ;;
    ;;    (defface modi/wk-highlight-modi-face
    ;;      '((t . (:inherit which-key-command-description-face :foreground "indian red")))
    ;;      "Face for highlighting commands starting with \"modi/\".")
    ;;
    ;;    (setq which-key-highlighted-command-list
    ;;          '(("\\`hydra-" . which-key-group-description-face)
    ;;            ("\\`modi/" . modi/wk-highlight-modi-face)
    ;;            ;; Highlight using the default `which-key-highlighted-command-face'
    ;;            "\\(rectangle-\\)\\|\\(-rectangle\\)"
    ;;            "\\`org-"))

)
    (which-key-mode 1)
#+END_SRC
*** Whitespace cleanup
#+BEGIN_SRC elisp
  (use-package whitespace-cleanup-mode
    :init
    (setq-default indent-tabs-mode nil)
    (global-whitespace-cleanup-mode t)
    :config
    (setq whitespace-style '(empty indentation::space trailing))
    ;; (cl-pushnew 'space-before-tab::space whitespace-style)
    ;; (global-set-key [remap just-one-space] 'cycle-spacing)
    ;; :bind
    ;; ("C-<menu>" . brust-cycle-whitespace)
    ;; ("s-SPC" . brust-cycle-whitespace)
    )
#+END_SRC

#+RESULTS:
: t
*** Words
#+BEGIN_SRC elisp
  (require 'words)
  (setq words-languages  '(("German"    . "de")
                           ("Italian"   . "it")
                           ;;("Chinese" . "zh")
                           ("Spanish"   . "es")
                           ("Catalan"   . "ca")
                           ("French"    . "fr")
                           ("English"   . "en")
                           ("Sweden"    . "sv")))
#+END_SRC
*** YaSnippet

#+BEGIN_SRC elisp
  (use-package yasnippet
    :defer t ;; I don't now why, but without it, don't load correctly
    :commands (yas-global-mode)
    ;; bind (:map yas-minor-mode-map
    ;;          ("<tab>" . nil)
    ;;          ("TAB" . nil)
    ;;          ("SPC" . yas-expand)
    ;;          ;; ("<S-iso-lefttab>" . yas-expand)
    ;;          )
    :init
    (yas-global-mode 1)
    :config
    (setq yas-snippet-dirs '("~/.emacs.d/snippets" ;; personal snippets
                             yas-installed-snippets-dir) ;; the default collection
          ;; yas-prompt-functions '(yas-ido-prompt yas-completing-prompt)
          yas-wrap-around-region t)
    (yas-reload-all))

  (use-package ivy-yasnippet
    :config
    (setq ivy-yasnippet-create-snippet-if-not-matched t)
    :bind
    ("C-c y" . ivy-yasnippet))

  (use-package yasnippet-snippets
    :after yasnippet
    :config (yasnippet-snippets-initialize))
#+END_SRC

#+RESULTS:
: t
** TODO To still clean
*** Ivy
**** General ivy
    - Learn ivy-bibtex
#+BEGIN_SRC elisp
  (use-package ivy
    :init
    (ivy-mode)
    (setq ivy-use-virtual-buffers t
          counsel-find-file-at-point t
          ;; ivy-initial-inputs-alist nil ; remove initial ^ input.
          ivy-virtual-abbreviate 'full ; properly use of bookmarks
          ivy-height 10
          ivy-count-format "(%d/%d) "
          ivy-extra-directories nil ; remove . and .. directory.
          ivy-display-style 'fancy
          ;; Don't open in directory-mode
          ivy-extra-directories nil
          ;; Always ignore buffers set in `ivy-ignore-buffers'
          ivy-use-ignore-default 'always)
    :config
    ;; Ignore some buffers in `ivy-switch-buffer'
    ;; Ignore some files in `counsel-find-file'
    (cl-loop for xx in
             '("company-statistics-cache.el"
               "^\\*vc\\*$"
               "^\\*log-edit-files\\*$"
               "^\\*Ibuffer\\*$"
               ;; "^\\*Org Src .*$"
               "^\\*magit[-a-z]*:.*$")
             do  (cl-pushnew xx ivy-ignore-buffers))

    (setq counsel-find-file-ignore-regexp
          (concat "\\(^#.*#$\\)\\|\\(^.*~$\\)\\|\\(^\\..*$\\)"
                  (cl-loop for -xx in
                           '(".aux" ".bbl" ".blg" ".exe"
                             ".log" ".meta" ".out" ;;".pdf"
                             ".synctex.gz" ".tdo" ".toc"
                             ".elc" ".eld" ".tex~" ".el~")
                           ;; may be add '("-pkg.el" "-autoloads.el")
                           do
                           (cl-pushnew
                            (concat "^.*\\" -xx "$")
                            ivy-ignore-buffers)
                           concat (concat "\\|\\(^.*\\" -xx "\\)") into file-regexp
                           finally return file-regexp)))

    (ivy-set-actions
     t
     '(("i" insert "insert")
       ("w" kill-new "yank")))

    (ivy-set-actions
     'counsel-find-file
     `(("d"
        (lambda (x) (delete-file (expand-file-name x ivy--directory)))
        ,(propertize "delete" 'face 'font-lock-warning-face))
       ("x" xah-open-in-external-app "open-externally")))

    (ivy-set-occur 'counsel-git-grep
                   '(lambda nil
                      (counsel-git-grep-occur)
                      (ivy-wgrep-change-to-wgrep-mode)))

    ;; (use-package ivy-hydra)
    ;; (use-package ivy-bibtex)
    (use-package counsel)
    (use-package ivy-rich)
    ;; (ivy-set-display-transformer 'ivy-switch-buffer 'ivy-rich-switch-buffer-transformer)
    (ivy-rich-mode 1)
    (counsel-mode 1)
    :bind*
    ("s-s"      . counsel-grep-or-swiper)
    ;; ("C-x b" . ivy-switch-buffer)
    ("<f1> l"   . counsel-load-library)
    ("<f2> i"   . counsel-info-lookup-symbol)
    ;;("<f2> u" . counsel-unicode-char)
    ;; ("C-b"      . ivy-switch-buffer)
    ("s-g"      . counsel-git-grep)
    ("s-b"      . counsel-bookmark)
    ("C-M-b"    . ivy-resume)
    ("s-x"      . ivy-push-view)
    ("s-X"      . ivy-pop-view)
    :bind
    (:map ivy-minibuffer-map
          ("s-k"        . ivy-next-line)
          ("s-i"        . ivy-previous-line)
          ("s-u"        . ivy-backward-delete-char)
          ("s-C-k"      . ivy-next-line-and-call)
          ("s-C-i"      . ivy-previous-line-and-call)
          ("s-l"        . ivy-alt-done)
          ("s-j"        . ivy-immediate-done)
          ;; ("s-ñ"        . ivy-call)
          ;; ("s-u"        . ivy-insert-current)
          ("C-w"        . ivy-yank-word)
          ;; ("M-w"        . )
          ;; ("M-a"        . ivy-dispatching-done)
          ("s-h"        . ivy-hydra/body)
          ;; ("s-o"        . ivy-dispatching-done-hydra)
          ("<return>"   . nil)
          ;; ("C-<return>" . ivy-done)
          ;; ("C-f"        . eh-ivy-open-current-typed-path)
          ;; ("C-M-k"    . ivy-alt-done)
          ("C-<"        . ivy-minibuffer-shrink)
          ("C->"        . ivy-minibuffer-grow)
          ("<down>"     . ivy-next-history-element)
          ("<up>"       . ivy-previous-history-element)
          ;; ("<right>"    . ivy-insert-current)
          ))
#+END_SRC

#+RESULTS:
: ivy-previous-history-element

**** Flyspell-correct-ivy
#+BEGIN_SRC elisp
  ;; (require 'flyspell-correct-ivy)
  ;; (bind-key* "C-." 'flyspell-correct-previous-word-generic)

  ;;  (use-package flyspell-correct
  ;;    :init
  (use-package flyspell-correct-ivy)
  ;; (bind-key "C-." 'flyspell-correct-previous-word-generic flyspell-mode-map)
  ;;    ;; :config
  ;;    ;;(setq flyspell-correct-interface 'flyspell-correct-ivy)
  ;;)
#+END_SRC

**** counsel-org-clock
#+BEGIN_SRC elisp
  (use-package counsel-org-clock
    :bind
    ("C-c c c" . counsel-org-clock-context)
    ("C-c c h" . counsel-org-clock-history))
#+END_SRC
**** COMMENT TODO key bind
#+BEGIN_SRC elisp
  (defun counsel-elisp-completion nil
    "Elisp completion at point."
    (interactive)
    (let* ((bnd (bounds-of-thing-at-point 'symbol))
           (str (buffer-substring-no-properties (car bnd) (cdr bnd)))
           (candidates (all-completions str obarray))
           (ivy-height 7)
           (res (ivy-read (format "pattern (%s): " str)
                          candidates)))
      (when (stringp res)
        (delete-region (car bnd) (cdr bnd))
        (insert res))))
#+END_SRC

*** COMMENT Session
#+BEGIN_SRC elisp
  (use-package session
    :defer t
    :init
    (add-hook 'after-init-hook #'session-initialize)
    :config
    (setq session-save-file "~/.emacs.d/backups/session"
          session-initialize '(de-saveplace session places)
          session-jump-undo-remember 3
          ;; session-use-package t nil (session))
          session-use-package t)
    )

#+END_SRC

#+RESULTS:

*** COMMENT Hydra
**** Ignore warnings
     Needed to put art on hydra's docs. Reset to default with idle in =init.el=.
#+BEGIN_SRC elisp
(setq warning-minimum-log-level :emergency)
#+END_SRC
**** Regular Motion
     Put down-upper-capitaliza in the usual keys
***** It was
    Make cursor movement keys under right hand's home-row.

(global-set-key (kbd "M-i") 'previous-line) ;; was tab-to-tab-stop
(global-set-key (kbd "M-j") 'backward-char) ;; was indent-new-comment-line
(global-set-key (kbd "M-k") 'next-line)     ;; was kill-sentence
(global-set-key (kbd "M-l") 'forward-char)  ;; was endless/downcase

(global-set-key (kbd "M-u") 'backward-word)   ;; was endless/upcase
(global-set-key (kbd "M-o") 'forward-word)    ;; was anything (outline prefix)

***** Hydra
      key chord!!!
#+BEGIN_SRC elisp
  (defhydra hydra-motion (:color pink :hint nil)
  "
  ^^Chars   Words| ^  ^  ^ | Ch ^W ^ L ^Se ^Scr| ^_._/_,_:set/jump-mark
  ^^^^------------------------------------| ^_-_:undo
    ^_l_^  ^ ^  ^ _o_ ^  | Forw | ^_d_ ^ _c_ ^ _e_^  _h_^  _n_ | ^_z_:indent
  _j_   _ñ_  _u_   _p_ |^ Backw| ^_f_ ^ _v_ ^ _a_^  _g_^  _N_ | ^_s_:del indent
    ^_k_^     ^ _i_ ^  | Trans| _t_ ^ _w_ ^ _r_^  _y_^  _m_ | ^_x_:er/expand
^^^^b is free!!
  "
     ("k" next-line nil)
     ("l" previous-line nil)
     ("ñ" forward-char nil)
     ("j" backward-char nil)
     ("o" (forward-line -5))
     ("i" (forward-line 5))
     ("p" forward-word)
     ("u" backward-word)
     ("d" (delete-char 1))
     ("f" (delete-char -1))
     ("c" kill-word)
     ("v" backward-kill-word)
     ("t" (transpose-chars 1))
     ("w" (transpose-words 1))
     ("r" (transpose-lines 1))
     ("y" (transpose-sentences 1))
     ("a" beginning-of-line nil)
     ("e" move-end-of-line nil)
     ("h" forward-sentence)
     ("g" backward-sentence)
     ("n" scroll-up-command nil)
     ;; Converting M-v to V here by analogy.
     ("N" scroll-down-command nil)
     ("m" recenter-top-bottom nil)
     ("z" indent-for-tab-command)
     ("s" brust-delete-indentation)
     ("x" er/expand-region)
     ("-" undo-tree-undo)
     ("." set-mark-command)
     ("," (set-mark-command 4))
     ("q" nil "Exit" :color blue))

;;  (global-set-key (kbd "C-S-n") 'hydra-motion/body) ; by example

#+END_SRC

**** Multiple Cursors
#+BEGIN_SRC elisp
(defhydra hydra-multiple-cursors (:hint nil)
  "
     ^Up^            ^Down^        ^Miscellaneous^
----------------------------------------------
[_p_]   Next    [_n_]   Next    [_l_] Edit lines
[_P_]   Skip    [_N_]   Skip    [_a_] Mark all
[_M-p_] Unmark  [_M-n_] Unmark  [_q_] Quit"
  ("l" mc/edit-lines :exit t)
  ("a" mc/mark-all-like-this :exit t)
  ("n" mc/mark-next-like-this)
  ("N" mc/skip-to-next-like-this)
  ("M-n" mc/unmark-next-like-this)
  ("p" mc/mark-previous-like-this)
  ("P" mc/skip-to-previous-like-this)
  ("M-p" mc/unmark-previous-like-this)
  ("q" nil))
#+END_SRC

**** ORG Agenda
#+BEGIN_SRC elisp
  ;;(define-key org-agenda-mode-map
      ;; "v" 'hydra-org-agenda-view/body)

  (defun org-agenda-cts nil
    (let ((args (get-text-property
                 (min (1- (point-max)) (point))
                 'org-last-args)))
      (nth 2 args)))

  (defhydra hydra-org-agenda-view (:hint nil)
    "
  _d_: ?d? day        _g_: time grid=?g? _a_: arch-trees
  _w_: ?w? week       _[_: inactive      _A_: arch-files
  _t_: ?t? fortnight  _f_: follow=?f?    _r_: report=?r?
  _m_: ?m? month      _e_: entry =?e?    _D_: diary=?D?
  _y_: ?y? year       _q_: quit          _L__l__c_: ?l?"

    ("SPC" org-agenda-reset-view)
    ("d" org-agenda-day-view
     (if (eq 'day (org-agenda-cts))
         "[x]" "[ ]"))
    ("w" org-agenda-week-view
     (if (eq 'week (org-agenda-cts))
         "[x]" "[ ]"))
    ("t" org-agenda-fortnight-view
     (if (eq 'fortnight (org-agenda-cts))
         "[x]" "[ ]"))
    ("m" org-agenda-month-view
     (if (eq 'month (org-agenda-cts)) "[x]" "[ ]"))
    ("y" org-agenda-year-view
     (if (eq 'year (org-agenda-cts)) "[x]" "[ ]"))
    ("l" org-agenda-log-mode
     (format "% -3S" org-agenda-show-log))
    ("L" (org-agenda-log-mode '(4)))
    ("c" (org-agenda-log-mode 'clockcheck))
    ("f" org-agenda-follow-mode
     (format "% -3S" org-agenda-follow-mode))
    ("a" org-agenda-archives-mode)
    ("A" (org-agenda-archives-mode 'files))
    ("r" org-agenda-clockreport-mode
     (format "% -3S" org-agenda-clockreport-mode))
    ("e" org-agenda-entry-text-mode
     (format "% -3S" org-agenda-entry-text-mode))
    ("g" org-agenda-toggle-time-grid
     (format "% -3S" org-agenda-use-time-grid))
    ("D" org-agenda-toggle-diary
     (format "% -3S" org-agenda-include-diary))
    ("!" org-agenda-toggle-deadlines)
    ("["
     (let ((org-agenda-include-inactive-timestamps t))
       (org-agenda-check-type t 'timeline 'agenda)
       (org-agenda-redo)))
    ("q" (message "Abort") :exit t)
)

#+END_SRC

#+RESULTS:

**** Rectangle
     Art cat, only give problems :(!!
     |\\     _,,,--,,_
|   /,`.-'`'   ._  \-;;,_
   |,4-  ) )_   .;.(  `'-'
| '---''(_/._)-'(_\_)
#+BEGIN_SRC elisp
   (defhydra hydra-rectangle (:body-pre (rectangle-mark-mode 1)
                             :color pink
                             :post (deactivate-mark))
    "
    ^_k_^     _y_ank       _e_xchange  _i_nsert-str
  _h_   _l_   _d_elete     _r_eset     _s_tr-replace
    ^_j_^     _c_ut        _u_ndo      cle_a_r
  ^^^^        _n_ew-copy   _o_k        ^ ^
  ^^^^        ^ ^
  "
    ("h" backward-char nil)
    ("l" forward-char nil)
    ("k" previous-line nil)
    ("j" next-line nil)
    ("a" clear-rectangle nil)
    ("e" exchange-point-and-mark nil)
    ("n" copy-rectangle-as-kill nil)
    ("d" delete-rectangle nil)
    ("r" (if (region-active-p)
             (deactivate-mark)
           (rectangle-mark-mode 1)) nil)
    ("y" yank-rectangle nil)
    ("u" undo nil)
    ("s" string-rectangle nil)
    ("i" string-insert-rectangle nil)
    ("c" kill-rectangle nil)
    ("o" nil nil)
    ("RET" nil nil))
  (global-set-key (kbd "C-x SPC") 'hydra-rectangle/body)
#+END_SRC

**** Transpose
#+BEGIN_SRC elisp
  (defhydra hydra-transpose (:color red)
    "
  _t_/_c_haracters  _s_entences   _o_rg-words
  ^  _w_ords       _p_aragraphs  org-_e_lements
  ^  _l_ines       ^ ^           org-t_a_bles
  "

    ("c" transpose-chars nil :color blue)
    ("t" transpose-chars nil)
    ("w" transpose-words nil)
    ("o" org-transpose-words nil)
    ("l" transpose-lines nil)
    ("s" transpose-sentences nil)
    ("e" org-transpose-elements nil)
    ("p" transpose-paragraphs nil)
    ("a" org-table-transpose-table-at-point nil)
    ("q" nil "Quit" :color blue))

  (global-set-key (kbd "C-t") #'hydra-transpose/transpose-chars)
  (global-set-key (kbd "M-t") #'hydra-transpose/transpose-words)
  (global-set-key (kbd "C-p") #'hydra-transpose/transpose-paragraphs)
  (global-set-key (kbd "C-x C-t") #'hydra-transpose/body)
#+END_SRC

**** More hydras
#+BEGIN_SRC elisp
(defhydra eos/hydra-toggle-map nil
  "
^Toggle^
^^^^^^^^----------------------
_d_: debug-on-error             +: monitor jack in
_D_: debug-on-quit              -: monitor jack out
_f_: fixed/variable width mode  0: monitor reset
_F_: auto-fill-mode             R: code reading mode
_l_: toggle-truncate-lines
_h_: hl-line-mode
_r_: read-only-mode
v: viewing-mode
n: narrow-or-widen-dwim
_g_: golden-ratio-mode
_q_: quit
"
  ("d" toggle-debug-on-error :exit t)
  ("D" toggle-debug-on-quit :exit t)
  ("g" golden-ratio-mode :exit t)
  ("f" variable-pitch-mode :exit t)
  ("F" auto-fill-mode :exit t)
  ("l" toggle-truncate-lines :exit t)
  ("r" read-only-mode :exit t)
  ;; This gets turned on/off unconditionally (not the eos/turn-on-hl-line-mode)
  ("h" hl-line-mode :exit t)
  ;;("v" eos/turn-on-viewing-mode :exit t)
  ;;("n" eos/narrow-or-widen-dwim :exit t)
  ;;("+" eos/monitor-jack-in :exit t)
  ;;("-" eos/monitor-jack-out :exit t)
  ;;("0" eos/monitor-reset :exit t)
  ;;("R" eos/code-reading-mode :exit t)
  ("q" nil :exit t))

(defhydra eos/hydra-next-error nil
  "Error Selection"
  ("`" next-error "next")
  ("j" next-error "next" :bind nil)

  ("n" next-error "next" :bind nil)
  ("k" previous-error "previous" :bind nil)
  ("p" previous-error "previous" :bind nil)
  ("l" flycheck-list-errors "list-errors" :exit t)
  ("q" nil "quit" :color red))

(defhydra eos/hydra-macro
  (:pre
   (when defining-kbd-macro
     (kmacro-end-macro 1)))
  "
  ^Create-Cycle^   ^Basic^           ^Insert^        ^Save^         ^Edit^
╭─────────────────────────────────────────────────────────────────────────╯
     ^_k_^           [_e_] execute    [_n_] insert    [_b_] name      [_'_] previous
     ^^↑^^           [_d_] delete     [_t_] set       [_K_] key       [_,_] last
 ( ←   → )       [_o_] edit       [_a_] add       [_x_] register
     ^^↓^^           [_r_] region     [_f_] format    [_B_] defun
     ^_j_^           [_m_] step
    ^^   ^^          [_s_] swap
"
  ("(" kmacro-start-macro :color blue)
  (")" kmacro-end-or-call-macro-repeat)
  ("k" kmacro-cycle-ring-previous)
  ("j" kmacro-cycle-ring-next)
  ("r" apply-macro-to-region-lines)
  ("d" kmacro-delete-ring-head)
  ("e" kmacro-end-or-call-macro-repeat)
  ("o" kmacro-edit-macro-repeat)
  ("m" kmacro-step-edit-macro)
  ("s" kmacro-swap-ring)
  ("n" kmacro-insert-counter)
  ("t" kmacro-set-counter)
  ("a" kmacro-add-counter)
  ("f" kmacro-set-format)
  ("b" kmacro-name-last-macro)
  ("K" kmacro-bind-to-key)
  ("B" insert-kbd-macro)
  ("x" kmacro-to-register)
  ("'" kmacro-edit-macro)
  ("," edit-kbd-macro)
  ("q" nil :color blue))

;; Here's a Hydra for information about the system (and emacs) that I stole from a different user:

(defhydra eos/hydra-about-emacs ()
  "
    About Emacs                                                        [_q_] quit
    ^^--------------------------------------------------------------------------
    PID:             %s(emacs-pid)
    Uptime:          %s(emacs-uptime)
    Init time:       %s(emacs-init-time)
    Directory:       %s(identity user-emacs-directory)
    Invoked from:    %s(concat invocation-directory invocation-name)
    Version:         %s(identity emacs-version)

    User Info
    ^^--------------------------------------------------------------------------
    User name:       %s(user-full-name)
    Login (real):    %s(user-login-name) (%s(user-real-login-name))
      UID (real):    %s(user-uid) (%s(user-real-uid))
      GID (real):    %s(group-gid) (%s(group-real-gid))
    Mail address:    %s(identity user-mail-address)

    System Info
    ^^--------------------------------------------------------------------------
    System name:     %s(system-name)
    System type:     %s(identity system-type)
    System config:   %s(identity system-configuration)
    "
  ("q" nil nil))

;;And finally, the main EOS Hydra for entry:

(defhydra eos/hydra nil
  "
╭────────────────────────────────────────────────╯
  [_a_] Org Agenda  [_E_] ERC       [m] Mail
  [_t_] Toggle map  [T] Twitter   [_M_] Music
  [_s_] Skeletons   [P] Prodigy   [_g_] Gnus
  [p] Proced       [W] Weather   [(] Macros
  [_e_] EWW         [R] RSS       [`] Errors
  [d] Downloads   [_D_] Debbugs   [C] ES-CC
  [b] Project's Eshell          [_B_] Bookmarks
  [_q_] quit
"

  ("`" eos/hydra-next-error/body :exit t)
  ("(" eos/hydra-macro/body :exit t)
  ("a" (org-agenda nil " ") :exit t)
  ;;("b" eos/popup-project-eshell :exit t)
  ("A" eos/hydra-about-emacs/body :exit t)
  ("t" eos/hydra-toggle-map/body :exit t)
  ;;("T" eos/start-or-jump-to-twitter :exit t)
  ("g" gnus :exit t)
  ;;("d" eos/popup-downloads :exit t)
  ("D" debbugs-gnu :exit t)
  ("B" counsel-bookmark :exit t)
  ;;("C" es-command-center :exit t)
  ;;("m" eos/switch-to-mail :exit t)
  ("M" eos/hydra-mpd/body :exit t)
  ("e" eww :exit t)
  ("E" (when (y-or-n-p "Really start ERC?") (start-erc)) :exit t)
  ;;("R" elfeed :exit t)
  ("s" eos/hydra-skeleton/body :exit t)
  ;;("p" proced :exit t)
  ;;("P" prodigy :exit t)
  ;;("W" wttrin :exit t)
  ("q" nil :exit t))

;; Bind the main EOS hydra to M-t
(global-set-key (kbd "M-t") 'eos/hydra/body)

#+END_SRC

#+RESULTS:
: eos/hydra/body

** Singular
*** Config
#+BEGIN_SRC elisp
  (use-package singular
    :ensure nil
    :mode ("\\.sing\\'" . c++-mode)
    :mode ("\\.lib\\'" .  c++-mode)
    :load-path "lisp/Singular/"
    :init
    (setq singular-emacs-home-directory "~/.emacs.d/lisp/Singular")
    (add-hook 'c++-mode-hook #'brust-singular-mode-hook)
    (defun brust-singular-mode-hook nil
      ;; turn-on fontification for c++-mode
      (font-lock-mode 1)
      (set (make-local-variable 'singular-commands-alist) nil)
      (load "~/.emacs.d/lisp/Singular/cmd-cmpl")
      ;; turn on aut-new line
      (c-toggle-auto-newline 1)
      ;; tunr off hungry-delete
      (c-toggle-hungry-state -1)
      (company-mode -1)
      (local-set-key (kbd "<tab>") #'brust-singular-dynamic-complete)
      (local-set-key (kbd "C-a")   #'singular-beginning-of-line)
      (local-set-key (kbd "C-p")   #'brust-singular-add-print)
      (local-set-key (kbd "C-s")   #'brust-singular-add-std)
      (local-set-key (kbd "C-c C-c") #'brust-singular-eval-region-or-line)
      (local-set-key (kbd "C-c ;") #'comment-region)
      ;; (local-set-key (kbd "C-c l") #'brust-singular-eval-buffer)
      (local-set-key (kbd "C-c b") #'brust-singular-eval-buffer)
      (local-set-key (kbd "C-c s") #'brust-singular-fixed-region-set-region)
      (local-set-key (kbd "C-c f") #'brust-singular-fixed-region-eval)
      (local-set-key (kbd "C-c e") #'brust-singular-eval-proc)
      ;; (local-set-key (kbd "C-c c") #'brust-singular-finish-line-singular-edit-mode)
      (local-set-key (kbd "C-<return>") #'newline)
      (local-set-key (kbd "<return>") #'brust-singular-finish-line-singular-edit-mode))

    (defun brust-singular-intetractive-mode nil
      ;; (local-set-key (kbd "C-n") #'brust-ace-window)
      (local-set-key (kbd "C-p") #'brust-singular-add-print)
      (local-set-key (kbd "C-s") #'brust-singular-add-std)
      (brust-math-software-hookfun-to-intangify-prompt)
      (hl-line-mode 1))

    (add-hook 'singular-interactive-mode-hook #'brust-singular-intetractive-mode)

    (setq load-path (cons singular-emacs-home-directory load-path))
    (autoload 'singular "singular"
      "Start Singular using default values." t)
    (autoload 'singular-other "singular"
      "Ask for arguments and start Singular." t)
    :config
    (defadvice singular-send-or-copy-input (before finish-line activate)
      (brust-singular-finish-line-interaction-mode)))

#+END_SRC

#+RESULTS:
: ((\.lib\' . c++-mode) (\.sing\' . c++-mode) (\.odc\' . archive-mode) (\.odf\' . archive-mode) (\.odi\' . archive-mode) (\.otp\' . archive-mode) (\.odp\' . archive-mode) (\.otg\' . archive-mode) (\.odg\' . archive-mode) (\.ots\' . archive-mode) (\.ods\' . archive-mode) (\.odm\' . archive-mode) (\.ott\' . archive-mode) (\.odt\' . archive-mode) (\.[pP][dD][fF]\' . pdf-view-mode) (\.sty\' . LaTeX-mode) (\.tex\' . LaTeX-mode) (\.hva\' . latex-mode) (\.drv\' . latex-mode) (/git-rebase-todo\' . git-rebase-mode) (\.at\' . autotest-mode) (\.gpg\(~\|\.~[0-9]+~\)?\' nil epa-file) (\.\(?:3fr\|a\(?:r[tw]\|vs\)\|bmp[23]?\|c\(?:als?\|myka?\|r[2w]\|u[rt]\)\|d\(?:c[mrx]\|ds\|jvu\|ng\|px\)\|exr\|f\(?:ax\|its\)\|gif\(?:87\)?\|hrz\|ic\(?:on\|[bo]\)\|j\(?:\(?:pe\|[np]\)g\)\|k\(?:25\|dc\)\|m\(?:iff\|ng\|rw\|s\(?:l\|vg\)\|tv\)\|nef\|o\(?:rf\|tb\)\|p\(?:bm\|c\(?:ds\|[dltx]\)\|db\|ef\|gm\|i\(?:ct\|x\)\|jpeg\|n\(?:g\(?:24\|32\|8\)\|[gm]\)\|pm\|sd\|tif\|wp\)\|r\(?:a[fs]\|gb[ao]?\|l[ae]\)\|s\(?:c[rt]\|fw\|gi\|r[2f]\|un\|vgz?\)\|t\(?:ga\|i\(?:ff\(?:64\)?\|le\|m\)\|tf\)\|uyvy\|v\(?:da\|i\(?:car\|d\|ff\)\|st\)\|w\(?:bmp\|pg\)\|x\(?:3f\|bm\|cf\|pm\|wd\|[cv]\)\|y\(?:cbcra?\|uv\)\)\' . image-mode) (\.elc\' . elisp-byte-code-mode) (\.dz\' nil jka-compr) (\.xz\' nil jka-compr) (\.lzma\' nil jka-compr) (\.lz\' nil jka-compr) (\.g?z\' nil jka-compr) (\.bz2\' nil jka-compr) (\.Z\' nil jka-compr) (\.vr[hi]?\' . vera-mode) (\(?:\.\(?:rbw?\|ru\|rake\|thor\|jbuilder\|rabl\|gemspec\|podspec\)\|/\(?:Gem\|Rake\|Cap\|Thor\|Puppet\|Berks\|Vagrant\|Guard\|Pod\)file\)\' . ruby-mode) (\.re?st\' . rst-mode) (\.pyw?\' . python-mode) (\.scss\' . scss-mode) (\.awk\' . awk-mode) (\.\(u?lpc\|pike\|pmod\(\.in\)?\)\' . pike-mode) (\.idl\' . idl-mode) (\.java\' . java-mode) (\.m\' . objc-mode) (\.ii\' . c++-mode) (\.i\' . c-mode) (\.lex\' . c-mode) (\.y\(acc\)?\' . c-mode) (\.[ch]\' . c-mode) (\.\(CC?\|HH?\)\' . c++-mode) (\.[ch]\(pp\|xx\|\+\+\)\' . c++-mode) (\.\(cc\|hh\)\' . c++-mode) (\.\(bat\|cmd\)\' . bat-mode) (\.[sx]?html?\(\.[a-zA-Z_]+\)?\' . html-mode) (\.svgz?\' . image-mode) (\.svgz?\' . xml-mode) (\.x[bp]m\' . image-mode) (\.x[bp]m\' . c-mode) (\.p[bpgn]m\' . image-mode) (\.tiff?\' . image-mode) (\.gif\' . image-mode) (\.png\' . image-mode) (\.jpe?g\' . image-mode) (\.te?xt\' . text-mode) (\.[tT]e[xX]\' . tex-mode) (\.ins\' . tex-mode) (\.ltx\' . latex-mode) (\.dtx\' . doctex-mode) (\.org\' . org-mode) (\.el\' . emacs-lisp-mode) (Project\.ede\' . emacs-lisp-mode) (\.\(scm\|stk\|ss\|sch\)\' . scheme-mode) (\.l\' . lisp-mode) (\.li?sp\' . lisp-mode) (\.[fF]\' . fortran-mode) (\.for\' . fortran-mode) (\.p\' . pascal-mode) (\.pas\' . pascal-mode) (\.\(dpr\|DPR\)\' . delphi-mode) (\.ad[abs]\' . ada-mode) (\.ad[bs].dg\' . ada-mode) (\.\([pP]\([Llm]\|erl\|od\)\|al\)\' . perl-mode) (Imakefile\' . makefile-imake-mode) (Makeppfile\(?:\.mk\)?\' . makefile-makepp-mode) (\.makepp\' . makefile-makepp-mode) (\.mk\' . makefile-gmake-mode) (\.make\' . makefile-gmake-mode) ([Mm]akefile\' . makefile-gmake-mode) (\.am\' . makefile-automake-mode) (\.texinfo\' . texinfo-mode) (\.te?xi\' . texinfo-mode) (\.[sS]\' . asm-mode) (\.asm\' . asm-mode) (\.css\' . css-mode) (\.mixal\' . mixal-mode) (\.gcov\' . compilation-mode) (/\.[a-z0-9-]*gdbinit . gdb-script-mode) (-gdb\.gdb . gdb-script-mode) ([cC]hange\.?[lL]og?\' . change-log-mode) ([cC]hange[lL]og[-.][0-9]+\' . change-log-mode) (\$CHANGE_LOG\$\.TXT . change-log-mode) (\.scm\.[0-9]*\' . scheme-mode) (\.[ckz]?sh\'\|\.shar\'\|/\.z?profile\' . sh-mode) (\.bash\' . sh-mode) (\(/\|\`\)\.\(bash_\(profile\|history\|log\(in\|out\)\)\|z?log\(in\|out\)\)\' . sh-mode) (\(/\|\`\)\.\(shrc\|[kz]shrc\|bashrc\|t?cshrc\|esrc\)\' . sh-mode) (\(/\|\`\)\.\([kz]shenv\|xinitrc\|startxrc\|xsession\)\' . sh-mode) (\.m?spec\' . sh-mode) (\.m[mes]\' . nroff-mode) (\.man\' . nroff-mode) (\.sty\' . latex-mode) (\.cl[so]\' . latex-mode) (\.bbl\' . latex-mode) (\.bib\' . bibtex-mode) (\.bst\' . bibtex-style-mode) (\.sql\' . sql-mode) (\.m[4c]\' . m4-mode) (\.mf\' . metafont-mode) (\.mp\' . metapost-mode) (\.vhdl?\' . vhdl-mode) (\.article\' . text-mode) (\.letter\' . text-mode) (\.i?tcl\' . tcl-mode) (\.exp\' . tcl-mode) (\.itk\' . tcl-mode) (\.icn\' . icon-mode) (\.sim\' . simula-mode) (\.mss\' . scribe-mode) (\.f9[05]\' . f90-mode) (\.f0[38]\' . f90-mode) (\.indent\.pro\' . fundamental-mode) (\.\(pro\|PRO\)\' . idlwave-mode) (\.srt\' . srecode-template-mode) (\.prolog\' . prolog-mode) (\.tar\' . tar-mode) (\.\(arc\|zip\|lzh\|lha\|zoo\|[jew]ar\|xpi\|rar\|7z\|ARC\|ZIP\|LZH\|LHA\|ZOO\|[JEW]AR\|XPI\|RAR\|7Z\)\' . archive-mode) (\.oxt\' . archive-mode) (\.\(deb\|[oi]pk\)\' . archive-mode) (\`/tmp/Re . text-mode) (/Message[0-9]*\' . text-mode) (\`/tmp/fol/ . text-mode) (\.oak\' . scheme-mode) (\.sgml?\' . sgml-mode) (\.x[ms]l\' . xml-mode) (\.dbk\' . xml-mode) (\.dtd\' . sgml-mode) (\.ds\(ss\)?l\' . dsssl-mode) (\.jsm?\' . javascript-mode) (\.json\' . javascript-mode) (\.[ds]?vh?\' . verilog-mode) (\.by\' . bovine-grammar-mode) (\.wy\' . wisent-grammar-mode) ([:/\]\..*\(emacs\|gnus\|viper\)\' . emacs-lisp-mode) (\`\..*emacs\' . emacs-lisp-mode) ([:/]_emacs\' . emacs-lisp-mode) (/crontab\.X*[0-9]+\' . shell-script-mode) (\.ml\' . lisp-mode) (\.ld[si]?\' . ld-script-mode) (ld\.?script\' . ld-script-mode) (\.xs\' . c-mode) (\.x[abdsru]?[cnw]?\' . ld-script-mode) (\.zone\' . dns-mode) (\.soa\' . dns-mode) (\.asd\' . lisp-mode) (\.\(asn\|mib\|smi\)\' . snmp-mode) (\.\(as\|mi\|sm\)2\' . snmpv2-mode) (\.\(diffs?\|patch\|rej\)\' . diff-mode) (\.\(dif\|pat\)\' . diff-mode) (\.[eE]?[pP][sS]\' . ps-mode) (\.\(?:PDF\|DVI\|OD[FGPST]\|DOCX?\|XLSX?\|PPTX?\|pdf\|djvu\|dvi\|od[fgpst]\|docx?\|xlsx?\|pptx?\)\' . doc-view-mode-maybe) (configure\.\(ac\|in\)\' . autoconf-mode) (\.s\(v\|iv\|ieve\)\' . sieve-mode) (BROWSE\' . ebrowse-tree-mode) (\.ebrowse\' . ebrowse-tree-mode) (#\*mail\* . mail-mode) (\.g\' . antlr-mode) (\.mod\' . m2-mode) (\.ses\' . ses-mode) (\.docbook\' . sgml-mode) (\.com\' . dcl-mode) (/config\.\(?:bat\|log\)\' . fundamental-mode) (\.\(?:[iI][nN][iI]\|[lL][sS][tT]\|[rR][eE][gG]\|[sS][yY][sS]\)\' . conf-mode) (\.\(?:desktop\|la\)\' . conf-unix-mode) (\.ppd\' . conf-ppd-mode) (java.+\.conf\' . conf-javaprop-mode) (\.properties\(?:\.[a-zA-Z0-9._-]+\)?\' . conf-javaprop-mode) (\`/etc/\(?:DIR_COLORS\|ethers\|.?fstab\|.*hosts\|lesskey\|login\.?de\(?:fs\|vperm\)\|magic\|mtab\|pam\.d/.*\|permissions\(?:\.d/.+\)?\|protocols\|rpc\|services\)\' . conf-space-mode) (\`/etc/\(?:acpid?/.+\|aliases\(?:\.d/.+\)?\|default/.+\|group-?\|hosts\..+\|inittab\|ksysguarddrc\|opera6rc\|passwd-?\|shadow-?\|sysconfig/.+\)\' . conf-mode) ([cC]hange[lL]og[-.][-0-9a-z]+\' . change-log-mode) (/\.?\(?:gitconfig\|gnokiirc\|hgrc\|kde.*rc\|mime\.types\|wgetrc\)\' . conf-mode) (/\.\(?:enigma\|gltron\|gtk\|hxplayer\|net\|neverball\|qt/.+\|realplayer\|scummvm\|sversion\|sylpheed/.+\|xmp\)rc\' . conf-mode) (/\.\(?:gdbtkinit\|grip\|orbital/.+txt\|rhosts\|tuxracer/options\)\' . conf-mode) (/\.?X\(?:default\|resource\|re\)s\> . conf-xdefaults-mode) (/X11.+app-defaults/\|\.ad\' . conf-xdefaults-mode) (/X11.+locale/.+/Compose\' . conf-colon-mode) (/X11.+locale/compose\.dir\' . conf-javaprop-mode) (\.~?[0-9]+\.[0-9][-.0-9]*~?\' nil t) (\.\(?:orig\|in\|[bB][aA][kK]\)\' nil t) ([/.]c\(?:on\)?f\(?:i?g\)?\(?:\.[a-zA-Z0-9._-]+\)?\' . conf-mode-maybe) (\.[1-9]\' . nroff-mode) (\.tgz\' . tar-mode) (\.tbz2?\' . tar-mode) (\.txz\' . tar-mode))

*** function to send the working file.
#+BEGIN_SRC elisp

  (defvar brust-singular-fixed-region-poss nil "Cons of positions delimiting the fixed region")

  (defun brust-singular-fixed-region-set-region (args)
    (interactive "P")
    (unless (use-region-p) (user-error "Region has to be activate"))
    (let ((beg (region-beginning))
          (end (region-end)))
      (setq brust-singular-fixed-region-poss (cons beg end))
      (message "Fixed-region seted from line %d to %d"
               (line-number-at-pos beg)
               (line-number-at-pos end)))
    (deactivate-mark t))

  (defun brust-singular-fixed-region-eval (args)
    (interactive "P")
    (message "Evaluated region (%d:%d) in [[%s]]"
             (line-number-at-pos (car brust-singular-fixed-region-poss))
             (line-number-at-pos (cdr brust-singular-fixed-region-poss))
             buffer-file-name)
    (brust-singular--eval-string
     (buffer-substring-no-properties
      (car brust-singular-fixed-region-poss)
      (cdr brust-singular-fixed-region-poss))
     args))

  (defun brust-singular-eval-region-or-line (args)
    (interactive "P")
    (let (-str)
      (if (not (use-region-p))
          (save-excursion
            (while (not (or (brust-singular--ending-semicolon-p) (bobp)))
              (forward-line -1))
            (setq -str (thing-at-point 'line t))
            (unless (brust-singular--ending-semicolon-p -str)
              (user-error "There is no line to eval"))
            (unless (brust-singular--check-parents -str)
              (user-error "Unbalanced Parents!!!"))
            (message "Evaluated line (%d) in [[ %s ]]"
                     (line-number-at-pos (point))
                     (buffer-name)))
        (message "Evaluated region between lines (%d:%d) in [[ %s ]]"
                 (line-number-at-pos (region-beginning))
                 (line-number-at-pos (region-end))
                 (buffer-name))
        (setq -str (buffer-substring-no-properties
                    (region-beginning) (region-end))))
      (brust-singular--eval-string -str args)))

  (defun brust-singular--ending-semicolon-p (&optional -string)
    (unless -string
      (setq -string (thing-at-point 'line t)))
    (string= ";"
             (substring (s-trim
                         (car
                          (split-string
                           -string "//")))
                        -1)))

  (defun brust-singular--check-parents (&optional -string)
    (unless -string
      (setq -string (thing-at-point 'line t)))
    (with-temp-buffer
      (insert -string)
      (ignore-errors (check-parens) t)))

  (defun brust-singular--eval-string (-str &optional args)
    (save-window-excursion
      (singular)
      (goto-char (point-max))
      (let ((process (singular-process))
            (--str (concat (s-trim -str)
                           (unless (string= (substring -str -1) ";")
                             "\n;"))))
        (when args (singular-control-c 'restart))
        (singular-input-filter process --str)
        (singular-send-string process --str))))

  (defun brust-singular--delete-comments (&optional -string)
    (unless -string
      (setq -string (thing-at-point 'line t)))
    (with-temp-buffer
      (insert -string)
      (goto-char (point-min))
      (while (search-forward "//" nil t)
        (forward-char -2)
        (delete-region (point) (line-end-position)))
      (buffer-string)))

  (defun brust-singular-eval-proc (args)
    "Eval last proc declaration."
    (interactive "P")
    (save-excursion
      (search-backward "proc" nil t)
      (let ((-beg (point))
            (-name
             (if (re-search-forward "[ \s\t]+" (line-end-position) t)
                 (let ((-beg2 (point)))
                   (if (search-forward "(" (line-end-position) t)
                       (s-trim (buffer-substring-no-properties -beg2 (1- (point))))
                     nil))
               nil)))
        (search-forward "{" nil t)
        (forward-char -1)
        (sp-forward-sexp)
        (brust-singular--eval-string
         (buffer-substring-no-properties -beg (point))
         args)
        (if -name
            (message "Evaluated proc {{%s}}, between lines (%d:%d), in file [[%s]]"
                     -name
                     (line-number-at-pos -beg)
                     (line-number-at-pos (point))
                     (file-name-base (buffer-name)))
          (message "Evaluated proc between lines (%d:%d) and file [[%s]] (Warring:: its name is not on the definition line)"
                   (line-number-at-pos -beg)
                   (line-number-at-pos (point))
                   (file-name-base (buffer-name)))))))

      ;;(defun brust-singular-eval-buffer-line-by-line nil
      ;;  (interactive)
      ;;  (let ((-total-str (buffer-string))
      ;;        (-base-name (file-name-base (buffer-name))))
      ;;    (with-temp-buffer
      ;;      (insert -total-str)
      ;;      (brust-singular--delete-comments)
      ;;      (goto-char (point-min))
      ;;      (while (not (eobp))
      ;;        ;;(or (brust-check-line-parents) (user-error "Unbalanced Parent!!!"))
      ;;        (let ((-str (s-trim (buffer-substring-no-properties
      ;;                             (line-beginning-position)
      ;;                             (line-end-position))))
      ;;              (-line (line-number-at-pos)))
      ;;          (unless
      ;;              (cond ((string= -str "") t)
      ;;                    ((string= (substring -str -1) ";")
      ;;                     (brust-singular--eval-string
      ;;                      -str
      ;;                      (format "line:%d:of::%s--" -line -base-name)
      ;;                      nil)
      ;;                     t)
      ;;                    (t (brust-singular-eval-environment args) t))
      ;;            (message "Error on line:%d (%s)" -line -str)
      ;;            (goto-char (point-max)))
      ;;          ;;(when err (goto-char err))
      ;;          (forward-line 1))))))

      ;;(defun brust-singular--temp-file (-str -name)
      ;;  (let ((-temp-file
      ;;         (make-temp-file
      ;;          (replace-regexp-in-string "[.]" "-" -name)
      ;;          nil ".sing")))
      ;;    (with-temp-buffer
      ;;      (insert -str)
      ;;      (append-to-file (point-min) (point-max) -temp-file))
      ;;    -temp-file))
#+END_SRC

#+RESULTS:
: brust-singular-eval-proc

*** functions for *singular*
**** Add print std...
#+BEGIN_SRC elisp
  (defun brust-singular-add-print nil
    (interactive)
    (brust-singular-add-function "print"))

  (defun brust-singular-add-std nil
    (interactive)
    (brust-singular-add-function "std"))

  (defun brust-singular-add-function (-fun)
    (let* ((-bounds (if (region-active-p)
                        `(,(region-beginning) . ,(region-end))
                      (save-excursion
                        (move-beginning-of-line 1)
                        (search-forward "> " (point-at-eol) t)
                        `(,(point) . ,(progn
                                        (move-end-of-line 1)
                                        (search-backward ";" (point-at-bol) t)
                                        (point))))))
           (-str (buffer-substring-no-properties (car -bounds) (cdr -bounds))))
      (goto-char (car -bounds))
      (delete-region (car -bounds) (cdr -bounds))
      (insert -fun "(" -str ")")
      (move-end-of-line 1)
      (insert ";")))
#+END_SRC

#+RESULTS:
: brust-singular-finish-line
**** Finish line
#+BEGIN_SRC elisp
  (defun brust-singular-finish-line-singular-edit-mode nil
    (interactive)
    (if (or (bolp) (eobp)) (insert "\n")
      (move-end-of-line 1)
      (when (search-backward "//" (point-at-bol) t)
        (skip-chars-backward "[:space:]"))
      (let ((-main-line (s-trim-right
                         (buffer-substring-no-properties (point-at-bol) (point))))
            (-comment-line (buffer-substring-no-properties (point) (point-at-eol))))
        (delete-region (point-at-bol) (point-at-eol))
        (if (or (< (length -main-line) 1))
            (insert (concat -comment-line "\n"))
          (insert
           (concat ;;compare (insert (concat nil "hello")) vs (insert nil "hello")
            (with-temp-buffer ;; To close-all-open-paren-r just of this line and do not use narrow
              (insert (concat -main-line
                              (unless (string= (substring -main-line -1) ";")
                                ";")))
              (forward-char -1)
              (close-all-open-paren-right)
              (buffer-string))
            -comment-line
            "\n"))))))

  (defun brust-singular-finish-line-interaction-mode nil
    (interactive)
    (narrow-to-region (point-at-bol) (point-at-eol))
    (move-end-of-line 1)
    (delete-horizontal-space)
    (unless (string= (string (char-before (point))) ";")
      (insert ";"))
    (forward-char -1)
    (close-all-open-paren-right)
    (widen))

#+END_SRC

#+RESULTS:
: brust-singular-finish-line-interaction-mode

**** Dynamic expand in non-running Singular buffer
#+BEGIN_SRC elisp
  (defun brust-singular-dynamic-complete ()
    "Dynamic complete word before point.
      Performs completion of Singular commands."
    (interactive)
    (let* ((end (point))
           (beg
            (save-excursion
              (skip-chars-backward "a-zA-Z0-9")
              (point)))
           (str (buffer-substring-no-properties beg end)))
      (if (string= str "")
          (indent-region (point-at-bol) (point-at-eol))
        ;; (call-interactively 'indent-region)
        (if singular-commands-alist
            (singular-completion-do str beg end singular-commands-alist)
          (message "Completion of Singular commands disabled.")
          (ding)))))
#+END_SRC

#+RESULTS:
: brust-singular-dynamic-complete

** LaTeX-mode-config
*** General
#+BEGIN_SRC elisp
  (use-package tex
    :ensure auctex
    :defer t
    :mode ("\\.tex\\'"  . LaTeX-mode)
    :mode ("\\.sty\\'"  . LaTeX-mode)
    :mode ("\\.bib\\'"  . bibtex-mode)
    :init
    (brust-endless/org-eval-eblocks "~/.emacs.d/lisp/brusts-latex-config.org" "init" t)
    :config
    (brust-endless/org-eval-eblocks "~/.emacs.d/lisp/brusts-latex-config.org" "config" t)
    (brust-endless/org-eval-eblocks "~/.emacs.d/lisp/brusts-latex-config.org" "LaTeX-extra" t)
    (use-package cdlatex
      :config
      (brust-endless/org-eval-eblocks "~/.emacs.d/lisp/brusts-latex-config.org" "cdLaTeX" t)
      :bind
      (:map cdlatex-mode-map
            ("'" . nil)
            ("`" . nil)
            ("¿" . cdlatex-math-modify)
            ("¡" . cdlatex-math-modify)
            ("ñ" . cdlatex-math-symbol)
            ("M-ñ" . brust-LaTeX-insert-ñ)))
    (use-package reftex
      :ensure nil
      :config
      (brust-endless/org-eval-eblocks "~/.emacs.d/lisp/brusts-latex-config.org" "RefTeX" t))
    :bind
    (:map LaTeX-mode-map
          ("ç"            . brust-LaTeX-insert-math1)
          ("Ç"            . brust-LaTeX-insert-math2)
          ("M-ç"          . brust-LaTeX-insert-ç)
          ;; ("           ."              . brust-LaTeX-smart-period)
          ;; ("<backtab>"    . TeX-complete-symbol) ;; Auto-complete funcion of AUCTeX
          ;; ("C-x C-s"      . brust-LaTeX-save)
          ("C-c C-e"      . brust-LaTeX-env)
          ("C-c n"        . TeX-next-error)
          ("s-e"          . brust-LaTeX-next-error)
          ;; ("C-c e"        . TeX-error-overview)
          ("s-5"          . latex-replace-in-math)
          ("s-C-5"        . latex-replace-regexp-in-math)
          ;; ("C-c C-a"      . brust-compile-only)
          ;; ("s-0"          . reftex-toc)
          ("M-m"          . brust-LaTeX-insert-up)
          ("M-n"          . brust-LaTeX-insert-down)
          ;; ("s-ç"          . brust-LaTeX-smart-selection)
          ("C-c C-q"      . latex/clean-fill-indent-environment)
          ("C-c C-w C-s"  . brust-wc-save-words)
          ;; ("C-c C-a"   . latex/compile-commands-until-done)
          ;; ("C-c C-a"   . TeX-texify) ;; subtitut by latex-extra
                            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Out-line and Extra-motion
          ;; ("<M-S-up>"  . latex/up-section)
          ;; ("<tab>"     . latex/hide-show)
          ;; ("<backtab>" . latex/hide-show-all)
          ;; (""          . latex/next-section)
          ;; (""          . latex/next-section-same-level)
          ;; (""          . latex/beginning-of-line)
          ;; ("C-M-e"        . latex/end-of-environment)
          ;; ("C-M-a"        . latex/beginning-of-environment)
          ;; ("C-M-p"        . latex/backward-environment)
          ;; ("C-M-n"        . latex/forward-environment)
          ("s-9"          . brust-cycle-texmath)
          ))
#+END_SRC

#+RESULTS:

*** Bibretrive
#+BEGIN_SRC elisp
  (byte-recompile-directory "~/.emacs.d/lisp/bibretrieve" 0)
  (load "bibretrieve")
  (setq bibretrieve-backends '(("msn" . 10) ("arxiv" . 5)))
#+END_SRC

#+RESULTS:
: ((msn . 10) (arxiv . 5))

*** Bralatex
    Load before auctex ??2
#+BEGIN_SRC elisp
  (require 'bratex)

  (defun bratex-config nil
    (local-set-key (kbd "<M-up>") #'bratex-cycle-size)
    (local-set-key (kbd "<M-down>") #'bratex-cycle-size-reverse)
    (local-set-key (kbd "<M-right>") #'bratex-cycle-bracket)
    (local-set-key (kbd "<M-left>") #'bratex-cycle-bracket-reverse))

#+END_SRC

#+RESULTS:
: bratex-config

** MyRegExp
*** Create it
#+BEGIN_SRC elisp
  (defvar brust--myregexp-itself)

  (setq brust--myregexp-itself
        (regexp-opt
         (cl-loop for -line in (append
                                (with-temp-buffer
                                  (insert-file-contents "~/.emacs.d/arxiv-rx-people.txt")
                                  (split-string (buffer-string) "\n"))
                                (with-temp-buffer
                                  (insert-file-contents "~/.emacs.d/arxiv-rx-topics.txt")
                                  (split-string (buffer-string) "\n")))
                  collect -line
                  collect (downcase -line)
                  collect (upcase-initials -line))))
#+END_SRC

#+RESULTS:
: \(?:Hilber \(?:[Ss]cheme\)\|Oneto\|Quim\|Roé\|hilber scheme\|oneto\|quim\|roé\)?
*** The function
#+BEGIN_SRC elisp
  (defun brust-myregexp nil
  "Do occur in the current buffer with my regexpresion build from the files bla bla bla"
    (interactive)
    ;; (grep (concat "\"" brust--myregexp-itself "\"" " " (buffer-name)))
    (occur brust--myregexp-itself))
#+END_SRC

#+RESULTS:
: brust-myregexp


* Old stuff
** Tab and indentation
**** Distance
#+BEGIN_SRC elisp
(setq tab-width 3
      default-tab-width 3)
#+END_SRC
** Untabify
     I heat =tabs=, so I always untabify when a filed is saved.
***** Function
#+BEGIN_SRC elisp
  (defun brust-untabify-whole-buffer nil
    (interactive)
    (untabify (point-min) (point-max)))

#+END_SRC
***** Binding
#+BEGIN_SRC elisp
  (add-hook 'before-save-hook 'brust-untabify-whole-buffer)

#+END_SRC
** Minibuffer-up/down complete history element
*** COMMENT Key binding
#+BEGIN_SRC elisp
;;  (define-key minibuffer-local-must-match-map (kbd "<up>") 'previous-complete-history-element)
 (define-key minibuffer-local-map (kbd "M-p") 'previous-complete-history-element)
 (define-key minibuffer-local-map (kbd "M-n") 'brust-next-complete-history-element)
 (define-key minibuffer-local-map (kbd "<up>") 'previous-complete-history-element)
 (define-key minibuffer-local-map (kbd "<down>") 'brust-next-complete-history-element)

#+END_SRC
*** COMMENT Next function
#+BEGIN_SRC elisp
  (defun brust-next-complete-history-element nil
    (interactive)
     (unless  (ignore-errors (next-complete-history-element 1))
       (delete-region (minibuffer-prompt-end) (line-end-position))))

#+END_SRC

** Auto fill yes/no
#+BEGIN_SRC elisp
(defun y-auto-fill nil "" (auto-fill-mode 1))
(defun n-auto-fill nil "" (auto-fill-mode 0))
;; Yes
(add-hook 'fundamental-mode-hook 'y-auto-fill)
(add-hook 'text-mode-hook 'y-auto-fill)
(add-hook 'LaTeX-mode-hook 'n-auto-fill)
;; No
(add-hook 'org-mode-hook 'n-auto-fill)
(add-hook 'emacs-lisp-mode-hook 'n-auto-fill)

#+END_SRC

** Improve isearch function
   I don't use it, I use =C-w= inseat.
*** COMMENT Function
#+BEGIN_SRC elisp
(defun endless/isearch-symbol-with-prefix (p)
  "Like isearch, unless prefix argument is provided.
With a prefix argument P, isearch for the symbol at point."
  (interactive "P")
  (let ((current-prefix-arg nil))
    (call-interactively
     (if p #'isearch-forward-symbol-at-point
       #'isearch-forward))))

#+END_SRC
*** COMMENT Key bind
#+BEGIN_SRC elisp
(global-set-key [remap isearch-forward]
                #'endless/isearch-symbol-with-prefix)

#+END_SRC

** The olds open<->close parent functions
#+BEGIN_SRC elisp
  (defun close-quoted-open-paren-right (args)
    (interactive "P")
    (or args (setq args 1))
    (with-syntax-table all-paren-syntax-table
      (cl-loop repeat args do
               (let* ((pos (save-excursion (up-list -1) (point)))
                      (closing (matching-paren (char-after pos))))
                 (message "pos :: %d" pos)
                 (while (eq (char-before pos) ?\\)
                   (insert "\\")
                   (setq pos (1- pos)))
                 (insert closing))))
    t) ;; to use with 'close-all-open-paren

(defun close-quoted-open-paren-left (args)
    (interactive "P")
    (or args (setq args 1))
    (with-syntax-table all-paren-syntax-table
      (cl-loop repeat args do
               (let* ((i 1)
                      (pos (save-excursion (up-list 1) (point)))
                      (closing (matching-paren (char-before pos))))
                 (while (eq (char-before (- pos i)) ?\\)
                   (setq i (1+ i)))
                 (dotimes (j (1- i)) (insert "\\")) ;;insert after to count right
                 (insert closing)
                 (backward-char i))))
    t)

#+END_SRC

** Switch fast between user/emacs buffers
*** Defvar
#+BEGIN_SRC elisp
(defvar xah-switch-buffer-ignore-dired t "If t, ignore dired buffer when calling `xah-next-user-buffer' or `xah-previous-user-buffer'")

#+END_SRC

*** User buffers
#+BEGIN_SRC elisp
  (defun brust-xah-arg-switch-user-buffer (args)
    "Switch to the next (or if args to the previous) user buffer.
   “user buffer” is a buffer whose name does not start with “*”.
  If `xah-switch-buffer-ignore-dired' is true, also skip directory buffer.
  2015-01-05 URL `http://ergoemacs.org/emacs/elisp_next_prev_user_buffer.html'"
    (interactive "P")
    (let ((i 0) (fun (if args 'previous-buffer 'next-buffer)))
      (while (< i 20)
        (funcall fun)
        (or (or (re-member (buffer-name) ido-ignore-buffers)
                (string-equal "*" (substring (buffer-name) 0 1))
                (if (string-equal major-mode "dired-mode")
                    xah-switch-buffer-ignore-dired
                  nil))
            (setq i 100))
        (setq i (1+ i)))))

#+END_SRC
*** Emacs buffers
#+BEGIN_SRC elisp
  (defun brust-xah-arg-switch-emacs-buffer (args)
    "Switch to the next (or with args to the previous) emacs buffer.
   (buffer name that starts with “*”)"
    (interactive "P")
    (let ((i 0) (fun (if args 'previous-buffer 'next-buffer)))
      (while (< i 20)
        (funcall fun)
        (or (not (and (string= "*" (substring (buffer-name) 0 1))
                      (string= "*" (substring (buffer-name) -1))))
            (setq i 100))
        (setq i (1+ i)))))

#+END_SRC

*** Keybinding
#+BEGIN_SRC elisp
;;;;;;;;;;;;;;;; Caution C-M-<f12> is an Ubuntu short keybinding!!!
(global-set-key (kbd "M-<f12>") 'brust-xah-arg-switch-emacs-buffer)
(global-set-key (kbd "C-<f12>") 'brust-xah-arg-switch-user-buffer)
#+END_SRC

** vCard mode
   To edit vCard files in Emacs
#+BEGIN_SRC elisp
  (push "~/.emacs.d/lisp/vCard/" load-path)
  (autoload 'vcard "vcard-mode" "Major mode for vCard files" t)
  (add-to-list 'auto-mode-alist '("\\.vc\\(f\\|ard\\)\\'" . vcard-mode))
(require 'vcard)

#+END_SRC

** Wraparound Cursor Movement in Ibuffer
*** Advanced motion
**** COMMENT _fun
#+BEGIN_SRC elisp
  (defun ibuffer-advance-motion (_fun)
      (funcall _fun)
      (beginning-of-line)
      (if (or (get-text-property (point) 'ibuffer-summary)
              (get-text-property (point) 'ibuffer-filter-group-name))
          (progn (while (or (get-text-property (point) 'ibuffer-summary)
                            (get-text-property (point) 'ibuffer-filter-group-name))
                   (funcall _fun))
                 (beginning-of-line)
                 nil)
        t))

#+END_SRC
**** direction
#+BEGIN_SRC elisp
  (defun ibuffer-advance-motion (direction)
        (forward-line direction)
        (beginning-of-line)
        (if (not (get-text-property (point) 'ibuffer-filter-group-name)) t
          (ibuffer-skip-properties '(ibuffer-filter-group-name) direction)
          nil))

#+END_SRC

*** Previous line
#+BEGIN_SRC elisp
  (defun ibuffer-previous-line (&optional arg)
    "Move backwards ARG lines, wrapping around the list if necessary."
    (interactive "P")
    (or arg (setq arg 1))
    (let (err1 err2)
      (while (> arg 0)
        (cl-decf arg)
        (setq err1 (ibuffer-advance-motion -1)
              err2 (if (not (get-text-property (point) 'ibuffer-title))
                       t
                     (goto-char (point-max))
                     (beginning-of-line)
                     (ibuffer-skip-properties '(ibuffer-summary
                                                ibuffer-filter-group-name)
                                              -1)
                     nil)))
      (and err1 err2)))

#+END_SRC
*** Next line
#+BEGIN_SRC elisp
  (defun ibuffer-next-line (&optional arg)
    "Move forward ARG lines, wrapping around the list if necessary."
    (interactive "P")
    (or arg (setq arg 1))
    (let (err1 err2)
      (while (> arg 0)
        (cl-decf arg)
        (setq err1 (ibuffer-advance-motion 1)
              err2 (if (not (get-text-property (point) 'ibuffer-summary))
                       t
                     (goto-char (point-min))
                     (beginning-of-line)
                     (ibuffer-skip-properties '(ibuffer-summary
                                                ibuffer-filter-group-name
                                                ibuffer-title)
                                              1)
                     nil)))
      (and err1 err2)))

#+END_SRC

*** Next header
#+BEGIN_SRC elisp
  (defun brust-ibuffer-next-header nil
    (interactive)
    (while (ibuffer-next-line)))

#+END_SRC

*** Previous header
#+BEGIN_SRC elisp
  (defun brust-ibuffer-previous-header nil
    (interactive)
    (while (ibuffer-previous-line)))

#+END_SRC

*** COMMENT Old functions
**** COMMENT Skip headers
#+BEGIN_SRC elisp
    (defun brust-ibuffer-skip-headers (fun)
      (funcall fun)
      (if (looking-at-p "\\[.*\\]")
        (while (looking-at-p "\\[.*\\]")
          (funcall fun) nil)
      t))

#+END_SRC

**** COMMENT Previous line
#+BEGIN_SRC elisp
  (defun ibuffer-previous-line nil
    (interactive)
    (if (> 5 (line-number-at-pos))
        (progn (goto-line (- (line-number-at-pos (point-max)) 2)) nil)
      (brust-ibuffer-skip-headers 'previous-line)))

#+END_SRC
**** COMMENT Next line
#+BEGIN_SRC elisp
  (defun ibuffer-next-line nil
    (interactive)
    (if (< (- (line-number-at-pos (point-max)) 3) (line-number-at-pos))
        (progn (goto-line 4) nil)
      (brust-ibuffer-skip-headers 'next-line)))
#+END_SRC

** bm
*** bm
#+BEGIN_SRC elisp
  (use-package bm
    :bind (("<f9>" . hydra-bm/body)
           ("<C-f9>" . bm-next)
           ("<C-S-f9>" . bm-previous)
           ;; bind left mouse clicks and scrolls in left margin/fringe
           ("<left-fringe> <mouse-5>" . bm-next-mouse)
           ("<left-margin> <mouse-5>" . bm-next-mouse)
           ("<left-fringe> <mouse-4>" . bm-previous-mouse)
           ("<left-margin> <mouse-4>" . bm-previous-mouse)
           ("<left-fringe> <mouse-1>" . bm-toggle-mouse)
           ("<left-margin> <mouse-1>" . bm-toggle-mouse)
           (:map bm-show-mode-map
                 ("n" . bm-show-next)
                 ("p" . bm-show-prev)
                 ("<return>" . bm-show-goto-bookmark)))

    :chords ("bk" . hydra-bm/body)
    :commands bm-repository-load bm-toggle bm-next bm-previous bm-show-all
    :init
    (setq-default bm-buffer-persistence t ; buffer persistence on by default
                  bm-restore-repository-on-load t)

    (add-hook' after-init-hook 'bm-repository-load)
    ;; (add-hook' after-init-hook 'bm-show-all)



    (defun brust-bm-motion (all fun)
      (let ((bm-cycle-all-buffers val))
        (funcall fun)))

    (defun brust-bm-next-same-buffer nil
      (interactive)
      (brust-bm-motion nil 'bm-next))

    (defun brust-bm-next-all-buffer nil
      (interactive)
      (brust-bm-motion t 'bm-next))

    (defun brust-bm-previous-same-buffer nil
      (interactive)
      (brust-bm-motion nil 'bm-previous))

    (defun brust-bm-previous-all-buffer nil
      (interactive)
      (brust-bm-motion t 'bm-previous))


    (defvar brust-bookmark-name-hist nil)

    (defun bm-bookmark-add--sync (&optional annotation time temporary-bookmark)
      "Add a standard Emacs bookmarks when setting a bm-bookmark."
      ;; create a unique name for the bookmark
      (let ((name (if (y-or-n-p-with-timeout "Do an auto-name? (default y):" 0.5 t)
                      (concat (buffer-name)
                              " l:" (int-to-string (line-number-at-pos (point))))
                    (read-string "Give the name:" (concat (buffer-name) "::") brust-bookmark-name-hist))))
        ;; store the bookmark name as an annotation
        (bm-bookmark-annotate (bm-bookmark-at (point)) name)
        (bookmark-set name)))

    (advice-add 'bm-bookmark-add :after #'bm-bookmark-add--sync)


    (defun bm-bookmark-remove--sync (&optional bookmark)
      "Remove a standard Emacs bookmarks when setting a bm-bookmark."
      (if (null bookmark)
          (setq bookmark (bm-bookmark-at (point))))
      (if (bm-bookmarkp bookmark)
          ;; delete bookmark by name (from annotation)
          (bookmark-delete (overlay-get bookmark 'annotation))))

    (advice-add 'bm-bookmark-remove :before #'bm-bookmark-remove--sync)


    :config
    (setq ;;bm-cycle-all-buffers nil ;; default nil
     bm-highlight-style (quote bm-highlight-only-fringe)
     bm-recenter nil
     bm-repository-file "~/.emacs.d/backups/.bm-persistent"
     bm-repository-size 1000)

    ;; Saving bookmarks
    (add-hook 'kill-buffer-hook #'bm-buffer-save)

    ;; Saving the repository to file when on exit.
    ;; kill-buffer-hook is not called when Emacs is killed, so we
    ;; must save all bookmarks first.
    (defun modi/bm-save-all-bm-to-repository nil
      (bm-buffer-save-all)
      (bm-repository-save))
    (add-hook 'kill-emacs-hook #'modi/bm-save-all-bm-to-repository)
    (add-hook 'after-save-hook #'bm-buffer-save)
    ;; The `after-save-hook' is not necessary to use to achieve persistence,
    ;; but it makes the bookmark data in repository more in sync with the file
    ;; state.

    ;; Restoring bookmarks
    (add-hook 'find-file-hooks   #'bm-buffer-restore)

    (add-hook 'after-revert-hook #'bm-buffer-restore)
    ;; The `after-revert-hook' is not necessary to use to achieve persistence,
    ;; but it makes the bookmark data in repository more in sync with the file
    ;; state. This hook might cause trouble when using packages
    ;; that automatically reverts the buffer (like vc after a check-in).
    ;; This can easily be avoided if the package provides a hook that is
    ;; called before the buffer is reverted (like `vc-before-checkin-hook').
    ;; Then new bookmarks can be saved before the buffer is reverted.
    ;; Make sure bookmarks is saved before check-in (and revert-buffer)
    (add-hook 'vc-before-checkin-hook #'bm-buffer-save))

  ;;(require 'bm)
#+END_SRC
*** bm-open-function
#+BEGIN_SRC elisp


  (defvar bm-init-show-buffer-name "*bm-all-bookmark(init)*"
      "The name of the buffer used to show bookmarks by `bm-init-show-all'.")

  (defun bm-init-show-all nil
    (interactive)
    (let ((bm-bn bm-show-buffer-name) (bm-es bm-electric-show))
      (bm-repository-load)
      (setq bm-show-buffer-name  bm-init-show-buffer-name
            bm-electric-show t)
      (apply #'bm-show-display-lines
             (bm-init-show-find-bookmarks bm-in-lifo-order))))


  (defun bm-init-show-find-bookmarks (&optional lifo-order)
    "Return (HEADER BOOKMARK-LIST) for displaying a list of bookmarks from
  list `bm-repository'.
  Both are strings to be used in the bookmark lists provided to
  users by the likes of `bm-show' and `bm-show-all'."
    ;; format-non-nil is just like format except it ignores any nil
    ;; arguments.  For example, (format-non-nil "%s %s" "foo" nil "bar")
    ;; yields "foo bar".  This is useful below where we conditionally
    ;; omit annotations.
    ;;
    ;; lstrip strips trailing white space from STR.  lstrip was stolen
    ;; from s.el and
    ;; http://ergoemacs.org/emacs/modernization_elisp_lib_problem.html.
    (cl-flet ((format-non-nil (format-string &rest args)
                (apply #'format format-string (delete nil args)))
              (lstrip (str)
                (if (string-match "\\`[ \t\n\r]+" str)
                    (replace-match "" t t str)
                  str)))
      (let* ((bookmarks (if lifo-order
                            (bm-overlays-lifo-order all)
                          (if all (bm-overlay-all)
                            (bm-overlay-in-buffer))))
             (file-line-width (bm-find-file-line-max-width bookmarks all))
             (format-string (concat (format "%%-%ds" file-line-width)
                                    (when bm-show-annotations
                                      (format " %%-%ds" bm-annotation-width))
                                    " %s")))
        (list
         ;; The header
         (format-non-nil format-string
                         (if all
                             (format "%s:%s" bm-header-buffer-name
                                     bm-header-line)
                           bm-header-line)
                         (when bm-show-annotations
                           bm-header-annotation)
                         bm-header-contents)
         ;; The bookmark list
         (mapconcat
          #'(lambda (bm)
              (with-current-buffer (overlay-buffer bm)
                (let* ((line (lstrip (buffer-substring (overlay-start bm)
                                                       (overlay-end bm))))
                       (line-num (count-lines (point-min) (overlay-start bm)))
                       (string
                        (format-non-nil format-string
                                        (if all
                                            (format "%s:%d" (buffer-name)
                                                    line-num)
                                          line-num)
                                        (when bm-show-annotations
                                          (or (overlay-get bm 'annotation) ""))
                                        (if (string-match "\n$" line)
                                            line
                                          (concat line "\n")))))
                  (put-text-property 0 (length string) 'bm-buffer (buffer-name)
                                     string)
                  (put-text-property 0 (length string) 'bm-bookmark bm string)
                  string)))
          bookmarks
          "")))))




  (cons (remq nil (mapcar 'bm-bookmarkp (car (overlay-lists))))
          (remq nil (mapcar 'bm-bookmarkp (cdr (overlay-lists)))))

  (bm-lists)


  (insert "\n" (car (cdr (bm-show-extract-bookmarks nil t))))


  (dolist (bm bm-repository)
    (insert "\n" (file-name-base (car bm)) "." (file-name-extension (car bm))))

  (mapc 'insert (mapc 'car (mapc 'car bm-repository)))


  (cl-flet ((format-non-nil (format-string &rest args)
                (apply #'format format-string (delete nil args)))
              (lstrip (str)
                (if (string-match "\\`[ \t\n\r]+" str)
                    (replace-match "" t t str)
                  str)))

  (mapconcat
          #'(lambda (bm)
              (with-current-buffer (overlay-buffer bm)
                (let* ((line (lstrip (buffer-substring (overlay-start bm)
                                                       (overlay-end bm))))
                       (line-num (count-lines (point-min) (overlay-start bm)))
                       (string
                        (format-non-nil format-string
                                        (if all
                                            (format "%s:%d" (buffer-name)
                                                    line-num)
                                          line-num)
                                        (when bm-show-annotations
                                          (or (overlay-get bm 'annotation) ""))
                                        (if (string-match "\n$" line)
                                            line
                                          (concat line "\n")))))
                  (put-text-property 0 (length string) 'bm-buffer (buffer-name)
                                     string)
                  (put-text-property 0 (length string) 'bm-bookmark bm string)
                  string)))

  (let ((bookmarks (bm-lists)))
      (append
       ;; xemacs has the list sorted after buffer position, while
       ;; gnu emacs list is sorted relative to current position.
       (if (featurep 'xemacs)
           (car bookmarks)
         (reverse (car bookmarks)))
       (cdr bookmarks)))
          ""))

    (overlay-lists)
#+END_SRC

*** bm Bookmark hydra
#+BEGIN_SRC elisp
  (defhydra hydra-bm (:color pink
                      :hint nil
                      :body-pre (when (not (use-region-p)) (push-mark)))
    "
           same (lifo) | all     _<f9>_/_8_ toggle book_m_/_M_ark    ^^_/_  bm lines matching regexp
     next: _<f10>_/_n_ (_N_) | _9_/_a_      _<f12>_ anno_t_ate            _x_/_X_ remove bm current/all buffer(s)
     prev:  _<f8>_/_p_ (_P_) | _7_/_e_   _<f11>_(_0_) _s_how (a_l_l) bm(s)     _r_eturn to from where you started
        "
    ("m"       bm-toggle :color blue)
    ("<f9>"    bm-toggle :color blue)
    ("8"       bm-toggle)
    ("M"       bm-toggle)

    ("n"       bm-common-next)
    ("<f10>"   bm-common-next)
    ("N"       bm-lifo-next)
    ("a"       brust-bm-next-all-buffer)
    ("9"       brust-bm-next-all-buffer)

    ("p"       bm-common-previous)
    ("<f8>"    bm-common-previous)
    ("e"       brust-bm-previous-all-buffer)
    ("7"       brust-bm-previous-all-buffer)
    ("P"       bm-lifo-previous)

    ("s"       bm-show :color blue)
    ("l"       bm-show-all :color blue)
    ("<f11>"   bm-show :color blue)
    ("0"       bm-show-all :color blue)


    ("/"       modi/bm-bookmark-regexp :color blue)
    ("t"       bm-bookmark-annotate :color blue)
    ("<f12>"   bm-bookmark-annotate :color blue)
    ;; ("s"    bm-toggle-buffer-persistence)
    ("x"       bm-remove-all-current-buffer :color blue)
    ("X"       bm-remove-all-all-buffers :color blue)
    ("r"       pop-to-mark-command :color blue)
    ("RET"     nil "cancel" :color blue)
    ("q"       nil "cancel" :color blue))


  (defun modi/bm-bookmark-regexp nil
    (interactive)
    (if (use-region-p)
        (progn
          (bm-bookmark-regexp-region (region-beginning) (region-end))
          (deactivate-mark))
      (bm-bookmark-regexp)))


#+END_SRC

** Winner mode - undo and redo window configuration

=winner-mode= lets you use =C-c <left>= and =C-c <right>= to switch between window configurations. This is handy when something has popped up a buffer that you want to look at briefly before returning to whatever you were working on. When you're done, press =C-c <left>=.

#+BEGIN_SRC emacs-lisp
  (use-package winner
    :config (winner-mode 1))

#+END_SRC
** Undo tree mode - visualize your undos and branches

People often struggle with the Emacs undo model, where there's really no concept of "redo" - you simply undo the undo.
#
This lets you use =C-x u= (=undo-tree-visualize=) to visually walk through the changes you've made, undo back to a certain point (or redo), and go down different branches.

#+BEGIN_SRC emacs-lisp
    (use-package undo-tree
      :defer 5
      :chords (("uu" . undo)
               ("jr" . undo-tree-redo)
               ("UU" . undo-tree-visualize))

      :bind (:map undo-tree-map
                  ("C-_" . undo-tree-redo)
                  ("C--" . undo-tree-undo)
                  ("C-M--" . undo-tree-visualize))
      :config
        (global-undo-tree-mode)
        (setq undo-tree-visualizer-timestamps t)
        (setq undo-tree-visualizer-diff t))

#+END_SRC

** Old ido config (before ivy)
#+BEGIN_SRC elisp
  (use-package ido
    :init
    (setq ido-use-virtual-buffers t
          ;; make ido display choices vertically
          ido-separator "\n"
          ;; display any item that contains the chars you typed. e.g. "mfl" might match "my-file-latex"!!
          ido-enable-flex-matching t
          ;; Create new buffer (or file) without confirmation
          ido-create-new-buffer 'always
          ido-use-filename-at-point 'guess
          ;; first extensions to show
          ido-file-extensions-order '(".tex" ".el" ".bib" ".org")
          ;; Set ido use "completion-ignore-case" (see above)
          ido-ignore-extensions t
          ido-ignore-buffers '("\\` " "\\*\\(.*\\)\\*")) ;; ignore virtual and system buffers, can toggle with C-a
    (mapc (lambda (x)
            (if (string-match-p "/" x)
                (if (string-match-p "\\." x)
                    (add-to-list 'ido-ignore-buffers (concat ".*\\" x ".*")) ;; regex for .dir/
                  (add-to-list 'ido-ignore-buffers (concat ".*" x ".*")))  ;; regex for dir/
              (add-to-list 'ido-ignore-buffers (concat ".*\\" x))))  ;; regex for .xx (where xx is an extension)
          completion-ignored-extensions) ;; ignore compile buffers and more, can toggle with C-a


    :bind
    ("C-n" . ido-find-file)
    ("C-b" . ido-switch-buffer)
    :chords
    ("nn" . ido-find-file)
    ("bb" . ido-switch-buffer)
    :config
    ;; Allow the same buffer to be open in different frames.
    ;;
    ;; http://www.reddit.com/r/emacs/comments/21a4p9/use_recentf_and_ido_together/cgbprem
    (add-hook 'ido-setup-hook
              (lambda nil
                (define-key ido-completion-map [up] 'ido-prev-match)
                (define-key ido-completion-map [down] 'ido-next-match)
                (define-key ido-completion-map [left] 'previous-history-element)
                (define-key ido-completion-map [right] 'brust-next-complete-history-element)))
    ;;(ido-mode t)
    ;;(ido-everywhere t)
    )

#+END_SRC

** Smex
#+BEGIN_SRC elisp
  (use-package smex
    :init
    (setq smex-save-file "~/.emacs.d/backups/smex-items")
    (smex-initialize)
    :config
    (setq smex-completion-method 'ivy)
    :bind*
    ;; ("M-x"        . smex)
    ("M-S-x"      . smex-major-mode-commands)
    ;; ("<menu>"     . smex)
    ("<S-menu>"   . smex-major-mode-commands))

#+END_SRC
*** Ido
     Simple config, just to use as smex by =smex-major-mode-commands=
#+BEGIN_SRC elisp
  (use-package ido
    :init
    (setq ido-separator "\n")
    :config
    (add-hook 'ido-setup-hook
              (lambda nil
                (define-key ido-completion-map [up] 'ido-prev-match)
                (define-key ido-completion-map [down] 'ido-next-match)
                (define-key ido-completion-map [left] 'previous-history-element)
                (define-key ido-completion-map [right] 'brust-next-complete-history-element))))
#+END_SRC

** COMMENT Old smart mode line
#+BEGIN_SRC elisp
  (use-package smart-mode-line
    :init
    (setq sml/theme nil
          ;; sml/theme 'smart-mode-line-powerline
          ;; sml/theme 'light
          ;; sml/theme 'respectful
          sml/no-confirm-load-theme t
         ;; sml/replacer-regexp-list ;; now I use mode-line-buffer-identication
         ;; '(
         ;;   ;; ("^~/Dropbox/config/emacs/" ":con4e:")
         ;;   (".*/[Tt]hesis/" ":Ths:")
         ;;   ("^~/org/" ":Org:")
         ;;   ("^~/\\.emacs\\.d/" ":E.D:")
         ;;   ("^/sudo:.*:" ":SU:")
         ;;   ("^~/Documents/" ":Doc:")
         ;;   ("^~/Dropbox/" ":DB:")
         ;;   ("^:\\([^:]*\\):Documento?s/" ":\\1/Doc:")
         ;;   ("^~/[Gg]it/" ":Git:")
         ;;   ("^~/[Gg]it[Hh]ub/" ":Git:")
         ;;   ("^~/[Gg]it\\([Hh]ub\\|\\)-?[Pp]rojects/" ":Git:"))
         )
    ;; (add-to-list 'sml/replacer-regexp-list '("^~/Git-Projects/" ":Git:") t)
    (sml/setup))
#+END_SRC
#+RESULTS:

* Not usual packages
  Load each with =brust-endless/org-eval-current-header=
** Singular
#+BEGIN_SRC elisp
  (use-package singular
    :ensure nil
    :mode ("\\.sing\\'" . c++-mode)
    :mode ("\\.lib\\'" .  c++-mode)
    :load-path "lisp/Singular/"
    :init
    (add-hook 'c++-mode-hook #'brust-singular-mode-hook)
    (defun brust-singular-mode-hook nil
      ;; turn-on fontification for c++-mode
      (font-lock-mode 1)
      ;; turn on aut-new line and hungry-delete
      (c-toggle-auto-hungry-state 1)
      (company-mode -1)
      (local-set-key (kbd "C-c a") #'brust-singular-eval-file-current-buffer)
      (local-set-key (kbd "C-c l") #'brust-singular-eval-line)
      (local-set-key (kbd "C-c s") #'brust-singular-eval-string))

    ;; (setq load-path (cons "<singular-emacs-home-directory>" load-path))
    (autoload 'singular "singular"
      "Start Singular using default values." t)
    (autoload 'singular-other "singular"
      "Ask for arguments and start Singular." t))

#+END_SRC

#+RESULTS:

*** function to send the working file.
#+BEGIN_SRC elisp
  (defun brust-singular-eval-file-current-buffer (args)
    (interactive "P")
    (let ((file  (buffer-file-name))
          (buffer (current-buffer)))
      (save-buffer)
      (singular)
      (when args (singular-control-c 'restart))
      (singular-load-file file t)
      (insert ";")
      (singular-send-or-copy-input nil)
      (switch-to-buffer buffer)))

  (defun brust-singular-delete-comments nil
    (interactive)
    (save-excursion
      (goto-char (point-min))
      (while (search-forward "//" nil t)
        (forward-char -2)
        (delete-char (- (line-end-position) (point))))))

  (defun brust-singular-eval-buffer-line-by-line nil
    (interactive)
    (let ((_buffer (buffer-string)))
      (with-temp-buffer
        (insert _buffer)
        (brust-singular-delete-comments)
        (goto-char (point-min))
        (while (not (eobp))
          ;;(or (brust-check-line-parents) (user-error "Unbalanced Parent!!!"))
          (let ((str (s-trim (buffer-substring-no-properties
                              (line-beginning-position)
                              (line-end-position)))))
            (unless
                (cond ((string= str "") t)
                      ((string= (substring str -1) ";")
                       (brust-singular-eval-string str) t)
                      (t (brust-singular-eval-environment) t))
              (message "despres del let line: %s" str)
              ;;(when err (goto-char err))
              (forward-line 1)))))))

  (defun brust-singular-eval-environment nil
    (interactive)
    (save-excursion
      (let ((beg (line-beginning-position)))
        (search-forward "{" nil t)
        (forward-char -1)
        (sp-forward-sexp)
        (brust-singular-eval-string
         (concat (buffer-substring-no-properties beg (point)) ";"))
        (point))))

  (defun brust-singular-eval-line nil
    (interactive)
    (or (brust-check-line-parents) (user-error "Unbalanced Parent!!!"))
    (let ((str (s-trim
                (buffer-substring-no-properties
                 (line-beginning-position)
                 (line-end-position)))))
      (unless (string= str "")
        (or (string= (substring str -1) ";") (setq str (concat str ";")))
        (brust-singular-eval-string str))))


  (defun brust-check-line-parents nil
    (interactive)
    (narrow-to-region (line-beginning-position) (line-end-position))
    (save-excursion
      (let ((err (ignore-errors (check-parens) t)))
        (widen)
        err)))

  (defun brust-singular-eval-string (_str)
    (let ((_buffer (current-buffer)))
      (ignore-errors
        (singular)
        (let ((proces (singular-process)))
          ;; insert string into history
          (singular-history-insert _str)
          ;; send string to process
          (singular-send-string process _str)
          ;; "insert" it into buffer
          (singular-input-filter process _str)))
      (switch-to-buffer _buffer)))
#+END_SRC

** Maxima
*** Load-path
#+BEGIN_SRC elisp
(push "/usr/share/emacs/site-lisp/maxima/" load-path)

#+END_SRC
*** Auto-load
#+BEGIN_SRC elisp
(autoload 'maxima-mode "maxima" "Maxima mode" t)
(autoload 'maxima "maxima" "Maxima interaction" t)
(autoload 'imaxima "imaxima" "Frontend for maxima with Image support" t)
;(autoload 'imath-mode "imath" "Imath mode for math formula input" t)
;(autoload 'imath "imath" "Interactive Math mode" t)
;(autoload 'imath-mode "imath" "Interactive Math mode" t);;

#+END_SRC
*** Auto-mode
#+BEGIN_SRC elisp
(add-to-list 'auto-mode-alist '("\\.ma[cx]" . maxima-mode))

#+END_SRC
*** Config:
**** COMMENT setq
#+BEGIN_SRC elisp
  (setq imaxima-fnt-size "huge"
        ;;  imaxima-latex-preamble "\\usepackage{concrete}\\usepackage{euler}"
        imaxima-use-maxima-mode-flag t
        maxima-save-input-history t
        ;; maxima-use-full-color-in-process-buffer t
        maxima-minibuffer-2d t
        imaxima-pt-size 12)

#+END_SRC
**** COMMENT An advice
     For a correct use of imaxima.
#+BEGIN_SRC elisp
(defadvice maxima-send-region (before maxima-start-imaxima first)
  "Ensures that imaxima is running and the correct flag is set."
  (setq imaxima-use-maxima-mode-flag t)
  (unless (get-buffer "*maxima*")
    (with-temp-buffer (imaxima))))
(ad-activate 'maxima-send-region)

#+END_SRC
*** Keybindings
**** COMMENT Maxima
#+BEGIN_SRC elisp
(defun customize-maxima-mode nil
  (interactive)
  (local-set-key (kbd "TAB") 'maxima-complete)
  (local-set-key (kbd "C-2") 'AcMe-new-parameter))

(add-hook 'maxima-mode-hook 'customize-maxima-mode)

#+END_SRC
**** COMMENT iMaxima
#+BEGIN_SRC elisp
(defun customize-imaxima nil
 "For the imaxima buffer"
  (interactive)
  (local-set-key (kbd "TAB") 'maxima-complete)
  (local-set-key (kbd "<f6>") 'transpose-buffers))
(add-hook 'imaxima-startup-hook 'customize-imaxima)

#+END_SRC
*** DeFuns AcMe
**** COMMENT AcMe-max-to-xml
#+BEGIN_SRC elisp
(defun AcMe-max-to-xml (xmlFileName); pNumber)
  "Convert standard maxima file to xml, you need an xml template.
   This function only changes the math content of the xml file.
   The xml template doesn't need to have the same number of parameters that
   your code, but must have some parameter defined.
   In your .max file, each parameter must be enclosed between the lines <parameter> and <end code>
   and the solution between <solution> and <end code>"
 (interactive (list (read-file-name "Path to the .xml \"tamplete\":"))); (read-number "Number of parameters:")))
 (let (maxbuffer xmlbuffer (xmlpos1 1) (xmlpos2 1) (maxpos1 1) (maxpos2 1) (i 1))
   (setq maxbuffer (buffer-name))
   (find-file xmlFileName)
   (setq xmlbuffer (buffer-name))
   (goto-char 1)
(if (y-or-n-p "Erase the parameters of the .xml?")
    (progn
      (re-search-forward "<parameters>") (forward-line) (setq xmlpos1 (line-beginning-position))
      (re-search-forward "</parameters>") (forward-line -1); (setq xmlpos2 (line-end-position))
      (delete-region xmlpos1 (line-end-position))
      (set-buffer maxbuffer)
   (goto-char 1)
   (while (re-search-forward "<parameter>" nil t)
     (forward-line) (setq maxpos1 (line-beginning-position))
     (re-search-forward "<end code>") (forward-line -1) (setq maxpos2 (line-end-position))
     (set-buffer xmlbuffer)
     (insert (concat "                       <parameter>
         <number>" (number-to-string i) "</number>
         <type>calculated</type>
         <value>
            <program>2</program>
            <mathCode>

            </mathCode>
         </value>
      </parameter>\n"))
     (re-search-backward "<mathCode>") (forward-line)
     (insert-buffer-substring-no-properties maxbuffer maxpos1 maxpos2)
     (set-buffer maxbuffer)
     (setq i (+ i 1))))
  (progn
    (set-buffer maxbuffer)
    (goto-char 1)
    (while (re-search-forward "<parameter>" nil t)
     (forward-line) (setq maxpos1 (line-beginning-position))
     (re-search-forward "<end code>") (forward-line -1) (setq maxpos2 (line-end-position))
     (set-buffer xmlbuffer)
     (re-search-forward "<mathCode>") (forward-line) (setq xmlpos1 (line-beginning-position))
     (re-search-forward "</mathCode>") (forward-line -1); (setq xmlpos2 (line-end-position))
     (delete-region xmlpos1 (line-end-position))
     (insert-buffer-substring-no-properties maxbuffer maxpos1 maxpos2)
     (set-buffer maxbuffer) )))
   (set-buffer xmlbuffer)
   (goto-char 1)
   (set-buffer maxbuffer)
   (goto-char 1)
   (while (search-forward "<solution>" nil t)
     (forward-line) (setq maxpos1 (line-beginning-position))
     (search-forward "<end code>") (forward-line -1) (setq maxpos2 (line-end-position))
     (set-buffer xmlbuffer)
   (re-search-forward "<solution>")
   (re-search-forward "<text>") (forward-line) (setq xmlpos1 (line-beginning-position))
   (re-search-forward "</text>") (forward-line -1) ;(setq xmlpos2 (line-end-position))
   (delete-region xmlpos1 (line-end-position))
   (insert-buffer-substring-no-properties maxbuffer maxpos1 maxpos2)
   (set-buffer maxbuffer))
   (set-buffer xmlbuffer) (save-buffer)
   (if (y-or-n-p "Kill .xml buffer?") (kill-buffer xmlbuffer) ())))

#+END_SRC
**** COMMENT AcMe-xml-to-max
#+BEGIN_SRC elisp
  (defun AcMe-xml-to-max (maxFileName); pNumber)
    "Convert AcMe standard .xml file to a maxima file with the conventions to the reverse convertion.
     Any content of the .max file is deleted. Puts the solution on top."
    (interactive (list (read-file-name "Path to the .max file:"))); (read-number "Number of parameters:")))
    (let (maxbuffer xmlbuffer (xmlpos1 1) (xmlpos2 1) (maxpos1 1) (maxpos2 1) maxStr moreLines (i 1))
      (setq xmlbuffer (buffer-name))
      (find-file maxFileName)
      (setq maxbuffer (buffer-name))
      (if (y-or-n-p "Erase the file .max?") (erase-buffer) (goto-char 1))
      (set-buffer xmlbuffer)
      (goto-char 1)
      (while (re-search-forward "<solution>" nil t)
        (re-search-forward "<text>") (forward-line) (setq xmlpos1 (line-beginning-position))
        (re-search-forward "</text>") (forward-line -1) (setq xmlpos2 (line-end-position))
        (set-buffer maxbuffer)
        (insert "/************ <solution> <"(number-to-string i)">***************/\n")
        (insert-buffer-substring-no-properties xmlbuffer xmlpos1 xmlpos2)
        (insert "\n/********* <end code> solution <"(number-to-string i)"> *************/\n\n\n\n")
        (set-buffer xmlbuffer)
        (setq i (+ i 1)))
      (goto-char 1)
      (setq i 1)
      (while (re-search-forward "<mathCode>" nil t)
                 ;      (goto-char 1) (re-serch-forward (concat "<number>"(number-to-string i)"</number>"))
        (forward-line) (setq xmlpos1 (line-beginning-position))
        (re-search-forward "</mathCode>") (forward-line -1) (setq xmlpos2 (line-end-position))
        (setq maxStr (buffer-substring-no-properties xmlpos1 xmlpos2))
        (set-buffer maxbuffer)
        (insert (concat "/******** <parameter> <" (number-to-string i) ">  ****************/\n" maxStr
              "\n/*********** <end code> parameter <"(number-to-string i)"> ***************/\n\n\n\n"))
        (setq i (+ 1 i))
        (set-buffer xmlbuffer))
      (set-buffer maxbuffer)
      (goto-char 1)
      (setq moreLines t)
      (while moreLines
        (setq maxStr (buffer-substring-no-properties (line-beginning-position) (line-end-position))
              maxStr (replace-regexp-in-string "\&quot;" "\"" maxStr)
              maxStr (replace-regexp-in-string "\&gt;" ">" maxStr)
              maxStr (replace-regexp-in-string "\&lt;" "<" maxStr))
        (insert (s-trim maxStr))
        (delete-region (point) (line-end-position))
        (setq moreLines (= 0 (forward-line 1))))
      (save-buffer)
    (if (y-or-n-p "Kill .xml buffer?") (kill-buffer xmlbuffer) ())))

#+END_SRC
**** COMMENT AcMe-new-parameter
#+BEGIN_SRC elisp
(defun AcMe-new-parameter (paramater_num)
  "Example function taking a prefix arg, or reading a number if no prefix arg"
  (interactive
   (if (and current-prefix-arg (not (consp current-prefix-arg)))
       (list (prefix-numeric-value current-prefix-arg))
     (list (read-number "Paramater number: "))))
  (let ((char 1))
    (insert (concat "/******** <parameter> <" (number-to-string paramater_num) ">  ****************/\n"))
    (setq char (point))
    (insert (concat "\n valor_calcul : $\nvalor_visual :  $\nprint(\"#\",valor_visual,\"#\",valor_calcul,\"#\")$\n/*********** <end code> parameter <"(number-to-string paramater_num)"> ***************/\n\n\n\n"))
    (goto-char char)))


#+END_SRC
** Yanki
#+BEGIN_SRC elisp
  (setq auto-mode-alist
        (append '(("\\.yanki\\'"    . Yanki-mode)
                  ("\\.yanki-b\\'"  . Yanki-build-mode))
                auto-mode-alist))
  (with-temp-buffer
    (insert-file-contents "~/.emacs.d/Yanki/Yanki-mode.el")
    (eval-buffer))

#+END_SRC

** Table org duplicates into columns
  #+BEGIN_SRC elisp
      (defun brust-org-table-delete-duplicates-by-current-column (args)
        (interactive "P")
        (unless (org-at-table-p) (user-error "No table at point"))
        (org-table-align)          ; Make sure we have everything we need.
        (narrow-to-region (org-table-begin) (org-table-end))
        (let ((nn (current-column)) (lines (line-number-at-pos (point-max))) (str (brust-org-table-field)))
          (while (not (eobp))
            (delete-matching-lines str)
            (brust-down-vertically nn)
            (setq str (brust-org-table-field)))
          (message "I've deleted %d lines." (- lines (line-number-at-pos (point-max))))
          (widen)))


  (defun brust-down-vertically (nn)
    (interactive "nColumn number:")
        (ignore-errors
          (forward-line 1)
          (forward-char nn)))

  (defun brust-down-vertically nil
    (interactive)
    (ignore-errors
      (goto-char (+ (1- (line-end-position)) (current-column)))))


      (defun brust-org-table-field nil
        (let ((n0 (point)))
          (org-forward-sentence)
          (s-trim (buffer-substring-no-properties n0 (point)))))

  (defun brust-org-table-leave-only-Si nil
      (interactive)
      (unless (org-at-table-p) (user-error "No table at point"))
      (org-table-align)          ; Make sure we have everything we need.
      (narrow-to-region (org-table-begin) (org-table-end))
      (let ((nn (current-column)) (lines (line-number-at-pos (point-max))))
          (while (not (eobp))
            (unless (looking-at-p "S[ií] ")
              (message "%s" (buffer-substring-no-properties (line-beginning-position) (line-end-position)))
              (delete-region (line-beginning-position) (line-end-position)))
            (brust-down-vertically nn))
      (message "The table has %d lines." (- lines (line-number-at-pos (point-max)))))
      (widen))

    (defun brust-org-table-count-lines nil
      (interactive)
      (unless (org-at-table-p) (user-error "No table at point"))
      (org-table-align)          ; Make sure we have everything we need.
      (narrow-to-region (org-table-begin) (org-table-end))
      (message "The table has %d lines."  (line-number-at-pos (point-max)))
      (widen))

#+END_SRC

** My-dictionary
#+BEGIN_SRC elisp
  (global-set-key (kbd "<C-M-return>") 'brust-my-dictionary-edit-an-entry)

  (global-set-key (kbd "<s-return>") 'brust-my-dictionary-new-entry)

  (defvar brust-my-dictionary-dir "Directory where is the dictionary")

  (setq brust-my-dictionary-dir "~/Dropbox/English/My-dictionary/")

  (defun brust-my-dictionary-open-an-entry (header)
    (let ((TeX-master t))
      (find-file (concat brust-my-dictionary-dir
                       "sections/"
                       (capitalize (substring header 0 1))
                       "/"
                       (replace-regexp-in-string "[ ]" "-" header)
                       ".tex"))))

    (defun brust-my-dictionary-new-entry (header)
      (interactive (list
                    (read-string "Give me the header:")))
      (brust-my-dictionary-open-an-entry header)
      (erase-buffer)
      (insert-file-contents (concat brust-my-dictionary-dir "tamplate-new-entry.tex"))
      (goto-char (point-min))
      (search-forward "entry{}{}{}{}" nil t)
      (backward-char 7)
      (insert header)
      (forward-char 2)
      (save-buffer))

  (defun brust-my-dictionary-edit-an-entry (header)
    (interactive
     (list
      (headlong-with
       (completing-read
        "Give me the entry to edit:"
        (cl-remove-duplicates
         (mapcar (lambda (x) (replace-regexp-in-string "[-]" " " (file-name-base x)))
                 (directory-files-recursively (concat brust-my-dictionary-dir "sections") ".+[.]tex"))
         :test (lambda (x y) (string= x y)))
        nil t))))
    (brust-my-dictionary-open-an-entry header))

  ;; From abo-abo, his headlong.el
  (defmacro headlong-with (&rest forms)
    "Execute FORMS with completion headlong."
    `(if (window-minibuffer-p)
         (user-error "Already in minibuffer")
       (let ((minibuffer-local-must-match-map headlong-minibuffer-map)
             (completing-read-function 'completing-read-default))
         ,@forms)))

  (defvar headlong-minibuffer-map
    (let ((map (copy-keymap minibuffer-local-must-match-map)))
      (define-key map [remap self-insert-command] 'headlong-self-insert-complete-and-exit)
      (define-key map "\C-i" (lambda nil
                               (interactive)
                               (minibuffer-complete)
                               (minibuffer-completion-help)))
      map)
    "Keymap for headlong minibuffer completion.")

  (defun headlong-self-insert-complete-and-exit (n)
    "Insert the character you type and try to complete.
                                               If this results in:
                                               - zero candidates: remove char and show completions
                                               - one candidate: immediately exit the minibuffer.
                                               N is passed to `self-insert-command'."
    (interactive "p")
    (self-insert-command n)
    (let ((candidates (completion-all-sorted-completions)))
      (cond
       ((null candidates)
        (backward-delete-char-untabify 1)
        (minibuffer-complete))
       ((eq 1 (safe-length candidates))
        (minibuffer-complete-and-exit)))))

  (defun headlong-bookmark-jump (bookmark)
    "Jump to BOOKMARK headlong."
    (interactive
     (list (headlong-with
            (completing-read "Jump to bookmark: " bookmark-alist nil t))))
    (ignore-errors
      (bookmark-jump bookmark)))

  ;; end abo-abo.

#+END_SRC

#+RESULTS:
: headlong-bookmark-jump

** CoCoA
*** Common settings
#+BEGIN_SRC elisp
  ;; ------------------------------------------------------------
  ;; DISCARD ALL ctrl-m CHARACTERS FROM SHELL OUTPUT
  (add-hook 'comint-output-filter-functions 'comint-strip-ctrl-m)

  ;; ------------------------------------------------------------
  ;; WORD COMPLETION:
  ;; dynamic abbrev expansion (M-/) replace also CASE PATTERN
  ;; (setq dabbrev-case-replace nil)

  ;; ------------------------------------------------------------
  ;; MY PREFERRED SET OF COLOURS ;-)
  ;;(if window-system
  ;;    (progn
  ;;      (set-face-foreground font-lock-comment-face       "red3" )
  ;;      (set-face-foreground font-lock-keyword-face       "SteelBlue4" )
  ;;      (set-face-foreground font-lock-string-face        "green4" )
  ;;      (set-face-foreground font-lock-constant-face      "Orange3" )
  ;;      (set-face-foreground font-lock-function-name-face "Blue" )
  ;;      (set-face-foreground font-lock-reference-face     "Sienna" )
  ;;      (set-face-foreground font-lock-type-face          "Orchid3" )
  ;;      )
  ;;  nil
  ;;  )

#+END_SRC
*** CoCoA 4.7

#+BEGIN_SRC elisp
  ;;==============================================================>
  ;;    CoCoA-Emacs CUSTOMIZATION:
  ;;==============================================================>
  ;; ------------------------------------------------------------
  ;; MY PREFERRED SET KEYBINDING ;-)

  (defun brust-cocoa-send-region-or-buffer nil
    "When region is active send region, when not send current buffer as input to CoCoA. See \\[cocoa-send-region] for
  more information. Does not save the buffer, so it's useful for trying
  experimental versions.
  See \\[cocoa-send-file] for an alternative.

  Note: if the *cocoa* buffer has no process, CoCoA will be restarted
  automatically when this function is called.
  "
    (interactive)
    (cocoa-shell-check-process)
    (let ((-str
           (if (use-region-p)
               (progn
                 (message "Evaluated region (%d:%d) in [[%s]]"
                          (line-number-at-pos (region-beginning))
                          (line-number-at-pos (region-end))
                          buffer-file-name)
                 (buffer-substring-no-properties (region-beginning) (region-end)))
             (message "File [[%s]] evaluated"
                      buffer-file-name)
             (buffer-substring-no-properties (region-beginning) (region-end)))))
      (cocoa-shell-check-window)
      (save-excursion
        (switch-to-buffer-other-window "*cocoa*")
        (if (not (eq (process-status "cocoa") "run")) (cocoa-make-shell))
        (goto-char (point-max))
        (insert -str)
        (comint-send-input))
      ;; (switch-to-buffer-other-window cocoa-file-buffer-name)
      (other-window 1)))


  (add-hook 'cocoa-mode-hook #'brust-cocoa-mode-hook)
  (defun brust-cocoa-mode-hook nil
    (company-mode -1)
    ;;   "\C-c\C-l" 'cocoa-send-line
    ;;   "\C-c\C-b" 'cocoa-send-buffer
    ;;   "\C-c\C-r" 'cocoa-send-region
    ;;   "\C-c\C-f" 'cocoa-source-file
    ;;   "\C-c\C-c" 'comment-region
    ;;   "\C-c\C-e" 'cocoa-close-block  ;; writes the appropriate "End"
    ;;   "\C-c\C-w" 'cocoa-open-wordlist-file
    ;;   "\C-c\C-q" 'cocoa-shell-quit
    ;;   "\C-c?"    'cocoa-word-man
    ;;   "\C-cm"    'cocoa-word-man
    ;;   "\C-c\C-m" 'cocoa-word-man
    ;; (local-set-key (kbd "C-c s") #'brust-singular-fixed-region-set-region)
    ;; (local-set-key (kbd "C-c f") #'brust-singular-fixed-region-eval)
    ;; (local-set-key (kbd "C-c e") #'brust-singular-eval-proc)
    ;; (setq last-command-char ";")
    (local-set-key (kbd "M->") #'cocoa-beg-of-defun)
    (local-set-key (kbd "C-c a") #'brust-cocoa-send-region-or-buffer)
    (local-set-key (kbd "C-c l") #'cocoa-send-line)
    (local-set-key (kbd "C-c d") #'cocoa-send-line))

  ;; PATH of the CoCoA directory:
  (setq cocoa-install-dir "~/sources/cocoa-4.7/")     ;Unix/Linux

  ;; PATH for the "cocoa.el" file
  (setq load-path (cons (concat cocoa-install-dir "emacs/") load-path))

  ;; PATH for the "cocoa" start-up script file
  ;; this usually works:
  (setq cocoa-executable (concat cocoa-install-dir "cocoa_text"))
  (setq cocoaserver-executable (concat cocoa-install-dir "CoCoAServer"))

  ;; PATH for the file containing the function names (to use dabbrev)
  (setq cocoa-wordlist-default-file (concat cocoa-install-dir "wordlist.txt"))

  ;; PATH of the directory where you usually save your CoCoA files:
  (setq cocoa-dir "~/CoCoA/")

  ;;==============================================================>

  ;; ------------------------------------------------------------
  ;; AUTO-LOAD cocoa.el for running CoCoA and cocoa-mode for files
  ;; with CoCoA extensions
  (autoload 'cocoa       "cocoa.el" "CoCoA running mode" 't)
  (autoload 'cocoaserver "cocoa.el" "CoCoA running mode" 't)
  (autoload 'cocoa-mode  "cocoa.el" "CoCoA editing mode" 't)

  (setq auto-mode-alist  (append auto-mode-alist '(
                                                   ("\\.\\(coc\\|cocoa\\|cocoarc\\|pkg\\|cpkg\\|ts\\)\\'" . cocoa-mode) )))

  ;; ------------------------------------------------------------
  ;; AUTO-LOAD wordlist when running CoCoA or using cocoa-mode
  (setq cocoa-auto-load-wordlist 't)

  ;; ------------------------------------------------------------
  ;; TAB FOR COMPLETION
  ;; *customize* with menu "CoCoA --> Preferences"
  ;;     [ same as "<ESC>-x  customize-group <RET> cocoa"
  ;;       sets (defvar cocoa-tab-is-completion nil)  ]
  ;; *or* uncomment the following line
  (defvar cocoa-tab-is-completion 't)

  ;; ------------------------------------------------------------
#+END_SRC

*** CoCoA 5.2
#+BEGIN_SRC elisp
  (setq cocoa5-emacs-dir
        "/home/lazycat/sources/cocoa-5.2/emacs/")

  ;;==============================================================>
  ;;    CoCoA5-Emacs CUSTOMIZATION:
  ;;==============================================================>

  (add-hook 'cocoa5-mode-hook #'brust-cocoa5-mode-hook)
  (defun brust-cocoa5-mode-hook nil
    (company-mode -1)
    ;; you can edit a CoCoA file and send commands from it to *cocoa5*:
    ;; "\C-c\C-l" 'cocoa5-send-line
    ;; "\C-c\C-r" 'cocoa5-send-region
    ;; "\C-c\C-f" 'cocoa5-source-file
    ;; "\C-c\C-c" 'cocoa5-interrupt-or-comment-region
    ;; "\C-c\C-e" 'cocoa5-close-block  ;; writes the appropriate "End"
    ;; "\C-c ]"   'cocoa5-close-block  ;; same as above
    ;; "\C-c\C-w" 'cocoa5-open-wordlist-file
    ;; "\C-c\C-q" 'cocoa5-shell-quit
    ;; "\C-c?"    'cocoa5-word-man
    ;; "\C-cm"    'cocoa5-word-man
    ;; "\C-c\C-m" 'cocoa5-word-man

    ;; (local-set-key (kbd "C-c s") #'brust-singular-fixed-region-set-region)
    ;; (local-set-key (kbd "C-c f") #'brust-singular-fixed-region-eval)
    ;; (local-set-key (kbd "C-c e") #'brust-singular-eval-proc)

    ;;  (define-key cocoa5-mode-map "\C-cm"    'cocoa5-word-man)
    ;;  (define-key cocoa5-mode-map "\C-c?"    'cocoa5-word-man)
    ;;  (define-key cocoa5-mode-map "\C-c\C-n" 'cocoa5-open-file)
    ;;  (define-key cocoa5-mode-map "\C-c\C-o" 'cocoa5-shell-panic-string)
    ;;  (define-key cocoa5-mode-map "\C-c " 'cocoa5-rotate-split)

    (local-set-key (kbd "C-c C-w")   #'cocoa5-open-wordlist-file)
    (local-set-key (kbd "C-c C-SPC") #'cocoa5-rotate-split)
    (local-set-key (kbd "C-c h")     #'cocoa5-word-man)
    (local-set-key (kbd ".")         #'cocoa5-electric-semi-or-dot)
    (local-set-key (kbd "M->")       #'cocoa5-beg-of-defun)
    (local-set-key (kbd "C-c a")     #'cocoa5-send-line-or-region)
    (local-set-key (kbd "C-c l")     #'cocoa5-send-line)
    (local-set-key (kbd "C-c d")     #'cocoa5-send-line))

  ;; PATH for the "cocoa5.el" file
  (setq load-path (cons cocoa5-emacs-dir load-path))

  ;; PATH for the "cocoa5" start-up script file
  (setq cocoa5-executable (concat cocoa5-emacs-dir "../cocoa5"))

  ;; FOR WINDOWS set these two lines:
                                          ; (setq cocoa5-executable (concat cocoa5-emacs-dir "../CoCoAInterpreter.exe"))
                                          ; (setq cocoa5-packages (concat cocoa5-emacs-dir "../packages"))

  ;; PATH for the file containing the function names (to use dabbrev)
  (setq cocoa5-wordlist-default-file (concat cocoa5-emacs-dir "../CoCoAManual/wordlist.txt"))

  ;; PATH of the directory where you usually save your CoCoA files:
  (setq cocoa5-dir "~/CoCoA/")

  ;; DEFAULT PROMPT IN EMACS
  (setq  cocoa5-default-prompt "/**/")

  ;;==============================================================>

  ;; ------------------------------------------------------------
  ;; AUTO-LOAD cocoa5.el for running CoCoA5 and cocoa5-mode for files
  ;; with CoCoA5 extensions
  (autoload 'c5           "cocoa5.el" "CoCoA5 running mode" 't)
  (autoload 'cpkg5        "cocoa5.el" "CoCoA5 running mode" 't)
  (autoload 'cocoa5       "cocoa5.el" "CoCoA5 running mode" 't)
  (autoload 'cocoa5server "cocoa5.el" "CoCoA5 running mode" 't)
  (autoload 'cocoa5-mode  "cocoa5.el" "CoCoA5 editing mode" 't)

  (setq auto-mode-alist  (append auto-mode-alist '(
                                                   ("\\.\\(cpkg5\\|cocoa5\\|cocoa5rc\\|c5\\)\\'" . cocoa5-mode) )))

  ;; ------------------------------------------------------------
  ;; AUTO-LOAD wordlist when running CoCoA5 or using cocoa5-mode
  (setq cocoa5-auto-load-wordlist 't)

  ;; ------------------------------------------------------------
  ;; AUTOMATIC CAPITALIZATION of CoCoA5 keywords:
  ;; (add-hook 'cocoa5-mode-hook '(lambda () (abbrev-mode 't)))

  ;; ------------------------------------------------------------
  ;; TAB FOR COMPLETION
  ;; *customize* with menu "CoCoA5 --> Preferences"
  ;;     [ same as "<ESC>-x  customize-group <RET> cocoa5"
  ;;       sets (defvar cocoa-tab-is-completion nil)  ]
  ;; *or* uncomment the following line
  (defvar cocoa5-tab-is-completion 't)

  ;; ------------------------------------------------------------

#+END_SRC

** Macaulay2
#+BEGIN_SRC elisp
;; add "/usr/share/emacs/site-lisp" to load-path if it isn't there
(if (not (member "/usr/share/emacs/site-lisp" load-path))
     (setq load-path (cons "/usr/share/emacs/site-lisp" load-path)))

;; add "/usr/share/info" to Info-default-directory-list if it isn't there
(if (not (member "/usr/share/info" Info-default-directory-list))
     (setq Info-default-directory-list (cons "/usr/share/info" Info-default-directory-list)))

;; add "/usr/bin" to PATH if it isn't there
(if (not (string-match "/usr/bin" (getenv "PATH")))
     (setenv "PATH" "/usr/bin:$PATH" t))

;; this version will give an error if M2-init.el is not found:
(load "M2-init")

;; this version will not give an error if M2-init.el is not found:
;;(load "M2-init" t)

;; You may comment out the following line with an initial semicolon if you
;; want to use your f12 key for something else.  However, this action
;; will be undone the next time you run setup() or setupEmacs().
;; (global-set-key [ f12 ] 'M2)

#+END_SRC

** Teaching
   From Excel save the table in csv format into /"tmp/my-table.csv"/ using {tab} as separators.
   Eval =C-c C-c=:
#+BEGIN_SRC elisp
  (find-file (concat temporary-file-directory "new-notes.org"))
  (insert "#+NAME: alumnes\n")
  (org-table-import (concat temporary-file-directory "my-table.csv") nil)
  (goto-char (point-max))
  (insert "\n\n")
#+END_SRC

#+RESULTS:

  And copy the following subtree =C-c C-x M-w= under the table and eval the code.

*** Teaching functions
#+BEGIN_SRC elisp :command export :var data=alumnes
  (require 's)

  (defvar brust-mark-column "Column number (starting from 1) where to insert marks (hard-code)")
  (defvar brust-niu-column "Column number (starting from 1) where nius are (hard-code)")
  (defvar brust-whatever-to-comma-p "It has to be a string or nil. If it is nil do nothing, if not, then replace whatever string or char using as separator into its value")
  (defvar brust-time-if-there-was-a-mark "Time in seconds to wait for an acction if the studen had a mark")
  ;;  (defvar brust-marks-let-line-highlight-p "t doen't turn down the highlighted line between NIUs")
  (defvar brust-do-visible-bell-p)

  (setq brust-whatever-to-comma-p ",")
  (setq brust-mark-column 4)
  (setq brust-niu-column 1)
  (setq brust-time-if-there-was-a-mark 0)
  ;;  (setq brust-marks-let-line-highlight-p t)
  (setq brust-do-visible-bell-p t)

  (global-set-key (kbd "<s-return>") 'brust-call-niu-insert-mark)

  (defvar brust-niu-list "List with nius (autoload)")
  (defvar brust-marks-hist "The history of inserted marks (auxiliar)")
  (setq brust-marks-hist '("5"))


  ;; From abo-abo, his headlong.el
  (defmacro headlong-with (&rest forms)
    "Execute FORMS with completion headlong."
    `(if (window-minibuffer-p)
         (user-error "Already in minibuffer")
       (let ((minibuffer-local-must-match-map headlong-minibuffer-map)
             (completing-read-function 'completing-read-default))
         ,@forms)))

  (defvar headlong-minibuffer-map
    (let ((map (copy-keymap minibuffer-local-must-match-map)))
      (define-key map [remap self-insert-command] 'headlong-self-insert-complete-and-exit)
      (define-key map "\C-i" (lambda nil
                               (interactive)
                               (minibuffer-complete)
                               (minibuffer-completion-help)))
      map)
    "Keymap for headlong minibuffer completion.")

  (defun headlong-self-insert-complete-and-exit (n)
    "Insert the character you type and try to complete.
                                           If this results in:
                                           - zero candidates: remove char and show completions
                                           - one candidate: immediately exit the minibuffer.
                                           N is passed to `self-insert-command'."
    (interactive "p")
    (self-insert-command n)
    (let ((candidates (completion-all-sorted-completions)))
      (cond
       ((null candidates)
        (backward-delete-char-untabify 1)
        (minibuffer-complete))
       ((eq 1 (safe-length candidates))
        (minibuffer-complete-and-exit)))))

  (defun headlong-bookmark-jump (bookmark)
    "Jump to BOOKMARK headlong."
    (interactive
     (list (headlong-with
            (completing-read "Jump to bookmark: " bookmark-alist nil t))))
    (ignore-errors
      (bookmark-jump bookmark)))
  ;; end abo-abo.

  (defun string-reverse (str)
    "Reverse the str where str is a string"
    (apply #'string
           (reverse
            (string-to-list str))))

  (defun number-to-string-reverse (num)
    "Reverse the num where num is a number"
    (string-reverse
     (number-to-string num)))

  (setq brust-niu-list
        (mapcar 'number-to-string-reverse
                (cl-remove-if-not 'numberp
                                  (mapcar '(lambda (x) (nth (1- brust-niu-column) x))
                                          data))))

  (defun brust-do-visible-bell nil
    (and brust-do-visible-bell-p
         (let ((visible-bell t))
           (ding))))

    (defun brust-replace-whatever-into-comma (str)
      (if (and brust-whatever-to-comma-p (string-match-p "[^0-9]" str))
          (let ((number (split-string str "[^0-9]+")))
            (concat (if (string= "" (car number)) "0" (car number))
                    brust-whatever-to-comma-p
                    (if (string= "" (car (cdr number))) "0" (car (cdr number)))))
        str))

    (defun brust-search-new-niu (NIU)
      (unless (org-at-table-p) (user-error "No table at point"))
      (org-table-align)          ; Make sure we have everything we need.
      (narrow-to-region (org-table-begin) (org-table-end))
      (goto-char (point-min))
      (let ((p (if (search-forward NIU nil t)
                   (hl-line-mode 1)
                 nil)))
        (widen)
        p))

    (defun brust-call-niu-insert-mark nil
      (interactive)
      (hl-line-mode 0)
      (let ((NIU (string-reverse
                  (headlong-with
                   (completing-read "Insert NIU: "
                                    brust-niu-list nil t)))))
        (brust-do-visible-bell)
        (if (brust-search-new-niu NIU)
            (let ((old-mark (s-trim (org-table-get-field brust-mark-column))))
              (when (or (s-blank? old-mark)
                        (y-or-n-p-with-timeout
                         (format "This stundent had the mark %s. Continue? (default yes)" old-mark)
                         brust-time-if-there-was-a-mark
                         t))
                (org-table-get-field brust-mark-column
                                     (brust-replace-whatever-into-comma
                                      (read-string "Enter mark:" nil 'brust-marks-hist)))
                (org-table-align)))
          (user-error "Error: NIU %d is in the list but not in the table!! (Reload all)" niu)))
      (brust-call-niu-insert-mark))

#+END_SRC

#+RESULTS:
: brust-call-niu-insert-mark


* To Improve
** Smart naviagtion inside line
[[*Smarter navigation inside a line][Smarter navigation inside a line]]

Comment charts hard coded :(
** Close open parents: more smart
